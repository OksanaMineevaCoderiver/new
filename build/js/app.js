/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "js/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function($) {\n\n$('.slider-close').click(function () {\n  $('.slider-block').removeClass('slider-block_is-active');\n});\n$('.navigation__prev').click(function () {\n  $.getJSON('../templates/data/products.json', function (json) {\n    var idEl = $('.slider__img').attr('id');\n    var amount = json.length;\n\n    if (idEl > 1) {\n      $('.slider__img').attr('id', json[idEl - 2].id);\n      $('.slider__img').attr('src', json[idEl - 2].url);\n      $('.navigation__slide-number').html(json[idEl - 2].id);\n    } else {\n      $('.slider__img').attr('id', json[amount - 1].id);\n      $('.slider__img').attr('src', json[amount - 1].url);\n      $('.navigation__slide-number').html(json[amount - 1].id);\n    }\n  });\n});\n$('.navigation__next').click(function () {\n  $.getJSON('../templates/data/products.json', function (json) {\n    var idEl = $('.slider__img').attr('id');\n    var amount = json.length;\n\n    if (idEl < amount) {\n      $('.slider__img').attr('id', json[idEl].id);\n      $('.slider__img').attr('src', json[idEl].url);\n      $('.navigation__slide-number').html(json[idEl].id);\n    } else {\n      $('.slider__img').attr('id', json[0].id);\n      $('.slider__img').attr('src', json[0].url);\n      $('.navigation__slide-number').html(json[0].id);\n    }\n  });\n});\n$('#back').click(function () {\n  $('.slider-block').addClass('slider-block_is-active');\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvanMvbGliL3Byb2R1Y3RzLmpzP2EyNzYiXSwic291cmNlc0NvbnRlbnQiOlsiJCgnLnNsaWRlci1jbG9zZScpLmNsaWNrKGZ1bmN0aW9uKCkge1xyXG4gICQoJy5zbGlkZXItYmxvY2snKS5yZW1vdmVDbGFzcygnc2xpZGVyLWJsb2NrX2lzLWFjdGl2ZScpO1xyXG59KTtcclxuJCgnLm5hdmlnYXRpb25fX3ByZXYnKS5jbGljayhmdW5jdGlvbigpIHtcclxuICAkLmdldEpTT04oJy4uL3RlbXBsYXRlcy9kYXRhL3Byb2R1Y3RzLmpzb24nLCBmdW5jdGlvbihqc29uKSB7XHJcbiAgXHRcdGxldCBpZEVsID0gJCgnLnNsaWRlcl9faW1nJykuYXR0cignaWQnKTtcclxuICBcdFx0bGV0IGFtb3VudCA9IGpzb24ubGVuZ3RoO1xyXG5cclxuICBcdFx0aWYgKGlkRWwgPiAxKSB7XHJcbiAgXHRcdFx0JCgnLnNsaWRlcl9faW1nJykuYXR0cignaWQnLCBqc29uW2lkRWwtMl0uaWQpO1xyXG4gICBcdFx0XHQkKCcuc2xpZGVyX19pbWcnKS5hdHRyKCdzcmMnLCBqc29uW2lkRWwtMl0udXJsKTtcclxuICAgXHRcdFx0JCgnLm5hdmlnYXRpb25fX3NsaWRlLW51bWJlcicpLmh0bWwoanNvbltpZEVsLTJdLmlkKTtcclxuICAgXHRcdH0gZWxzZSB7XHJcbiAgIFx0XHRcdCQoJy5zbGlkZXJfX2ltZycpLmF0dHIoJ2lkJywganNvblthbW91bnQtMV0uaWQpO1xyXG4gICBcdFx0XHQkKCcuc2xpZGVyX19pbWcnKS5hdHRyKCdzcmMnLCBqc29uW2Ftb3VudC0xXS51cmwpO1xyXG4gICBcdFx0XHQkKCcubmF2aWdhdGlvbl9fc2xpZGUtbnVtYmVyJykuaHRtbChqc29uW2Ftb3VudC0xXS5pZCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgfSk7XHJcbn0pO1xyXG4kKCcubmF2aWdhdGlvbl9fbmV4dCcpLmNsaWNrKGZ1bmN0aW9uKCkge1xyXG4gICQuZ2V0SlNPTignLi4vdGVtcGxhdGVzL2RhdGEvcHJvZHVjdHMuanNvbicsIGZ1bmN0aW9uKGpzb24pIHtcclxuICBcdFx0bGV0IGlkRWwgPSAkKCcuc2xpZGVyX19pbWcnKS5hdHRyKCdpZCcpO1xyXG4gIFx0XHRsZXQgYW1vdW50ID0ganNvbi5sZW5ndGg7XHJcblxyXG4gIFx0XHRpZiAoaWRFbCA8IGFtb3VudCkge1xyXG4gIFx0XHRcdCQoJy5zbGlkZXJfX2ltZycpLmF0dHIoJ2lkJywganNvbltpZEVsXS5pZCk7XHJcbiAgIFx0XHRcdCQoJy5zbGlkZXJfX2ltZycpLmF0dHIoJ3NyYycsIGpzb25baWRFbF0udXJsKTtcclxuICAgXHRcdFx0JCgnLm5hdmlnYXRpb25fX3NsaWRlLW51bWJlcicpLmh0bWwoanNvbltpZEVsXS5pZCk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgIFx0XHRcdCQoJy5zbGlkZXJfX2ltZycpLmF0dHIoJ2lkJywganNvblswXS5pZCk7XHJcbiAgIFx0XHRcdCQoJy5zbGlkZXJfX2ltZycpLmF0dHIoJ3NyYycsIGpzb25bMF0udXJsKTtcclxuICAgXHRcdFx0JCgnLm5hdmlnYXRpb25fX3NsaWRlLW51bWJlcicpLmh0bWwoanNvblswXS5pZCk7XHJcbiAgXHRcdH1cclxuICB9KTtcclxufSk7XHJcbiQoJyNiYWNrJykuY2xpY2soZnVuY3Rpb24oKSB7XHJcbiAgJCgnLnNsaWRlci1ibG9jaycpLmFkZENsYXNzKCdzbGlkZXItYmxvY2tfaXMtYWN0aXZlJyk7XHJcbn0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2pzL2xpYi9wcm9kdWN0cy5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(0);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvanMvYXBwLmpzPzcxNmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICcuL2xpYi9wcm9kdWN0cy5qcyc7XHJcblxyXG5cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9qcy9hcHAuanMiXSwibWFwcGluZ3MiOiI7O0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*!\n * jQuery JavaScript Library v3.3.1\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2018-01-20T17:24Z\n */\n(function (global, factory) {\n\n  'use strict';\n\n  if (( false ? 'undefined' : _typeof(module)) === 'object' && _typeof(module.exports) === 'object') {\n\n    // For CommonJS and CommonJS-like environments where a proper `window`\n    // is present, execute the factory and get jQuery.\n    // For environments that do not have a `window` with a `document`\n    // (such as Node.js), expose a factory as module.exports.\n    // This accentuates the need for the creation of a real `window`.\n    // e.g. var jQuery = require(\"jquery\")(window);\n    // See ticket #14549 for more info.\n    module.exports = global.document ? factory(global, true) : function (w) {\n      if (!w.document) {\n        throw new Error('jQuery requires a window with a document');\n      }\n      return factory(w);\n    };\n  } else {\n    factory(global);\n  }\n\n  // Pass this if window is not defined yet\n})(typeof window !== 'undefined' ? window : undefined, function (window, noGlobal) {\n\n  // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n  // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n  // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n  // enough that all such attempts are guarded in a try block.\n  'use strict';\n\n  var arr = [];\n\n  var document = window.document;\n\n  var getProto = Object.getPrototypeOf;\n\n  var _slice = arr.slice;\n\n  var concat = arr.concat;\n\n  var push = arr.push;\n\n  var indexOf = arr.indexOf;\n\n  var class2type = {};\n\n  var toString = class2type.toString;\n\n  var hasOwn = class2type.hasOwnProperty;\n\n  var fnToString = hasOwn.toString;\n\n  var ObjectFunctionString = fnToString.call(Object);\n\n  var support = {};\n\n  var isFunction = function isFunction(obj) {\n\n    // Support: Chrome <=57, Firefox <=52\n    // In some browsers, typeof returns \"function\" for HTML <object> elements\n    // (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\n    // We don't want to classify *any* DOM node as a function.\n    return typeof obj === 'function' && typeof obj.nodeType !== 'number';\n  };\n\n  var isWindow = function isWindow(obj) {\n    return obj != null && obj === obj.window;\n  };\n\n  var preservedScriptAttributes = {\n    type: true,\n    src: true,\n    noModule: true\n  };\n\n  function DOMEval(code, doc, node) {\n    doc = doc || document;\n\n    var i,\n        script = doc.createElement('script');\n\n    script.text = code;\n    if (node) {\n      for (i in preservedScriptAttributes) {\n        if (node[i]) {\n          script[i] = node[i];\n        }\n      }\n    }\n    doc.head.appendChild(script).parentNode.removeChild(script);\n  }\n\n  function toType(obj) {\n    if (obj == null) {\n      return obj + '';\n    }\n\n    // Support: Android <=2.3 only (functionish RegExp)\n    return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' || typeof obj === 'function' ? class2type[toString.call(obj)] || 'object' : typeof obj === 'undefined' ? 'undefined' : _typeof(obj);\n  }\n  /* global Symbol */\n  // Defining this global in .eslintrc.json would create a danger of using the global\n  // unguarded in another place, it seems safer to define global only for this module\n\n\n  var version = '3.3.1',\n\n\n  // Define a local copy of jQuery\n  jQuery = function jQuery(selector, context) {\n\n    // The jQuery object is actually just the init constructor 'enhanced'\n    // Need init if jQuery is called (just allow error to be thrown if not included)\n    return new jQuery.fn.init(selector, context);\n  },\n\n\n  // Support: Android <=4.0 only\n  // Make sure we trim BOM and NBSP\n  rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\n  jQuery.fn = jQuery.prototype = {\n\n    // The current version of jQuery being used\n    jquery: version,\n\n    constructor: jQuery,\n\n    // The default length of a jQuery object is 0\n    length: 0,\n\n    toArray: function toArray() {\n      return _slice.call(this);\n    },\n\n    // Get the Nth element in the matched element set OR\n    // Get the whole matched element set as a clean array\n    get: function get(num) {\n\n      // Return all the elements in a clean array\n      if (num == null) {\n        return _slice.call(this);\n      }\n\n      // Return just the one element from the set\n      return num < 0 ? this[num + this.length] : this[num];\n    },\n\n    // Take an array of elements and push it onto the stack\n    // (returning the new matched element set)\n    pushStack: function pushStack(elems) {\n\n      // Build a new jQuery matched element set\n      var ret = jQuery.merge(this.constructor(), elems);\n\n      // Add the old object onto the stack (as a reference)\n      ret.prevObject = this;\n\n      // Return the newly-formed element set\n      return ret;\n    },\n\n    // Execute a callback for every element in the matched set.\n    each: function each(callback) {\n      return jQuery.each(this, callback);\n    },\n\n    map: function map(callback) {\n      return this.pushStack(jQuery.map(this, function (elem, i) {\n        return callback.call(elem, i, elem);\n      }));\n    },\n\n    slice: function slice() {\n      return this.pushStack(_slice.apply(this, arguments));\n    },\n\n    first: function first() {\n      return this.eq(0);\n    },\n\n    last: function last() {\n      return this.eq(-1);\n    },\n\n    eq: function eq(i) {\n      var len = this.length,\n          j = +i + (i < 0 ? len : 0);\n      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);\n    },\n\n    end: function end() {\n      return this.prevObject || this.constructor();\n    },\n\n    // For internal use only.\n    // Behaves like an Array's method, not like a jQuery method.\n    push: push,\n    sort: arr.sort,\n    splice: arr.splice\n  };\n\n  jQuery.extend = jQuery.fn.extend = function () {\n    var options,\n        name,\n        src,\n        copy,\n        copyIsArray,\n        clone,\n        target = arguments[0] || {},\n        i = 1,\n        length = arguments.length,\n        deep = false;\n\n    // Handle a deep copy situation\n    if (typeof target === 'boolean') {\n      deep = target;\n\n      // Skip the boolean and the target\n      target = arguments[i] || {};\n      i++;\n    }\n\n    // Handle case when target is a string or something (possible in deep copy)\n    if ((typeof target === 'undefined' ? 'undefined' : _typeof(target)) !== 'object' && !isFunction(target)) {\n      target = {};\n    }\n\n    // Extend jQuery itself if only one argument is passed\n    if (i === length) {\n      target = this;\n      i--;\n    }\n\n    for (; i < length; i++) {\n\n      // Only deal with non-null/undefined values\n      if ((options = arguments[i]) != null) {\n\n        // Extend the base object\n        for (name in options) {\n          src = target[name];\n          copy = options[name];\n\n          // Prevent never-ending loop\n          if (target === copy) {\n            continue;\n          }\n\n          // Recurse if we're merging plain objects or arrays\n          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {\n\n            if (copyIsArray) {\n              copyIsArray = false;\n              clone = src && Array.isArray(src) ? src : [];\n            } else {\n              clone = src && jQuery.isPlainObject(src) ? src : {};\n            }\n\n            // Never move original objects, clone them\n            target[name] = jQuery.extend(deep, clone, copy);\n\n            // Don't bring in undefined values\n          } else if (copy !== undefined) {\n            target[name] = copy;\n          }\n        }\n      }\n    }\n\n    // Return the modified object\n    return target;\n  };\n\n  jQuery.extend({\n\n    // Unique for each copy of jQuery on the page\n    expando: 'jQuery' + (version + Math.random()).replace(/\\D/g, ''),\n\n    // Assume jQuery is ready without the ready module\n    isReady: true,\n\n    error: function error(msg) {\n      throw new Error(msg);\n    },\n\n    noop: function noop() {},\n\n    isPlainObject: function isPlainObject(obj) {\n      var proto, Ctor;\n\n      // Detect obvious negatives\n      // Use toString instead of jQuery.type to catch host objects\n      if (!obj || toString.call(obj) !== '[object Object]') {\n        return false;\n      }\n\n      proto = getProto(obj);\n\n      // Objects with no prototype (e.g., `Object.create( null )`) are plain\n      if (!proto) {\n        return true;\n      }\n\n      // Objects with prototype are plain iff they were constructed by a global Object function\n      Ctor = hasOwn.call(proto, 'constructor') && proto.constructor;\n      return typeof Ctor === 'function' && fnToString.call(Ctor) === ObjectFunctionString;\n    },\n\n    isEmptyObject: function isEmptyObject(obj) {\n\n      /* eslint-disable no-unused-vars */\n      // See https://github.com/eslint/eslint/issues/6125\n      var name;\n\n      for (name in obj) {\n        return false;\n      }\n      return true;\n    },\n\n    // Evaluates a script in a global context\n    globalEval: function globalEval(code) {\n      DOMEval(code);\n    },\n\n    each: function each(obj, callback) {\n      var length,\n          i = 0;\n\n      if (isArrayLike(obj)) {\n        length = obj.length;\n        for (; i < length; i++) {\n          if (callback.call(obj[i], i, obj[i]) === false) {\n            break;\n          }\n        }\n      } else {\n        for (i in obj) {\n          if (callback.call(obj[i], i, obj[i]) === false) {\n            break;\n          }\n        }\n      }\n\n      return obj;\n    },\n\n    // Support: Android <=4.0 only\n    trim: function trim(text) {\n      return text == null ? '' : (text + '').replace(rtrim, '');\n    },\n\n    // results is for internal usage only\n    makeArray: function makeArray(arr, results) {\n      var ret = results || [];\n\n      if (arr != null) {\n        if (isArrayLike(Object(arr))) {\n          jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr);\n        } else {\n          push.call(ret, arr);\n        }\n      }\n\n      return ret;\n    },\n\n    inArray: function inArray(elem, arr, i) {\n      return arr == null ? -1 : indexOf.call(arr, elem, i);\n    },\n\n    // Support: Android <=4.0 only, PhantomJS 1 only\n    // push.apply(_, arraylike) throws on ancient WebKit\n    merge: function merge(first, second) {\n      var len = +second.length,\n          j = 0,\n          i = first.length;\n\n      for (; j < len; j++) {\n        first[i++] = second[j];\n      }\n\n      first.length = i;\n\n      return first;\n    },\n\n    grep: function grep(elems, callback, invert) {\n      var callbackInverse,\n          matches = [],\n          i = 0,\n          length = elems.length,\n          callbackExpect = !invert;\n\n      // Go through the array, only saving the items\n      // that pass the validator function\n      for (; i < length; i++) {\n        callbackInverse = !callback(elems[i], i);\n        if (callbackInverse !== callbackExpect) {\n          matches.push(elems[i]);\n        }\n      }\n\n      return matches;\n    },\n\n    // arg is for internal usage only\n    map: function map(elems, callback, arg) {\n      var length,\n          value,\n          i = 0,\n          ret = [];\n\n      // Go through the array, translating each of the items to their new values\n      if (isArrayLike(elems)) {\n        length = elems.length;\n        for (; i < length; i++) {\n          value = callback(elems[i], i, arg);\n\n          if (value != null) {\n            ret.push(value);\n          }\n        }\n\n        // Go through every key on the object,\n      } else {\n        for (i in elems) {\n          value = callback(elems[i], i, arg);\n\n          if (value != null) {\n            ret.push(value);\n          }\n        }\n      }\n\n      // Flatten any nested arrays\n      return concat.apply([], ret);\n    },\n\n    // A global GUID counter for objects\n    guid: 1,\n\n    // jQuery.support is not used in Core but other projects attach their\n    // properties to it so it needs to exist.\n    support: support\n  });\n\n  if (typeof Symbol === 'function') {\n    jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];\n  }\n\n  // Populate the class2type map\n  jQuery.each('Boolean Number String Function Array Date RegExp Object Error Symbol'.split(' '), function (i, name) {\n    class2type['[object ' + name + ']'] = name.toLowerCase();\n  });\n\n  function isArrayLike(obj) {\n\n    // Support: real iOS 8.2 only (not reproducible in simulator)\n    // `in` check used to prevent JIT error (gh-2145)\n    // hasOwn isn't used here due to false negatives\n    // regarding Nodelist length in IE\n    var length = !!obj && 'length' in obj && obj.length,\n        type = toType(obj);\n\n    if (isFunction(obj) || isWindow(obj)) {\n      return false;\n    }\n\n    return type === 'array' || length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj;\n  }\n  var Sizzle =\n  /*!\n   * Sizzle CSS Selector Engine v2.3.3\n   * https://sizzlejs.com/\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license\n   * http://jquery.org/license\n   *\n   * Date: 2016-08-08\n   */\n  function (window) {\n\n    var i,\n        support,\n        Expr,\n        getText,\n        isXML,\n        tokenize,\n        compile,\n        select,\n        outermostContext,\n        sortInput,\n        hasDuplicate,\n\n\n    // Local document vars\n    setDocument,\n        document,\n        docElem,\n        documentIsHTML,\n        rbuggyQSA,\n        rbuggyMatches,\n        matches,\n        contains,\n\n\n    // Instance-specific data\n    expando = 'sizzle' + 1 * new Date(),\n        preferredDoc = window.document,\n        dirruns = 0,\n        done = 0,\n        classCache = createCache(),\n        tokenCache = createCache(),\n        compilerCache = createCache(),\n        sortOrder = function sortOrder(a, b) {\n      if (a === b) {\n        hasDuplicate = true;\n      }\n      return 0;\n    },\n\n\n    // Instance methods\n    hasOwn = {}.hasOwnProperty,\n        arr = [],\n        pop = arr.pop,\n        push_native = arr.push,\n        push = arr.push,\n        slice = arr.slice,\n\n    // Use a stripped-down indexOf as it's faster than native\n    // https://jsperf.com/thor-indexof-vs-for/5\n    indexOf = function indexOf(list, elem) {\n      var i = 0,\n          len = list.length;\n      for (; i < len; i++) {\n        if (list[i] === elem) {\n          return i;\n        }\n      }\n      return -1;\n    },\n        booleans = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped',\n\n\n    // Regular expressions\n\n    // http://www.w3.org/TR/css3-selectors/#whitespace\n    whitespace = '[\\\\x20\\\\t\\\\r\\\\n\\\\f]',\n\n\n    // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n    identifier = '(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+',\n\n\n    // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n    attributes = '\\\\[' + whitespace + '*(' + identifier + ')(?:' + whitespace +\n    // Operator (capture 2)\n    '*([*^$|!~]?=)' + whitespace +\n    // \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n    \"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + '))|)' + whitespace + '*\\\\]',\n        pseudos = ':(' + identifier + ')(?:\\\\((' +\n    // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n    // 1. quoted (capture 3; capture 4 or capture 5)\n    \"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n    // 2. simple (capture 6)\n    '((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|' + attributes + ')*)|' +\n    // 3. anything else (capture 2)\n    '.*' + ')\\\\)|)',\n\n\n    // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n    rwhitespace = new RegExp(whitespace + '+', 'g'),\n        rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)' + whitespace + '+$', 'g'),\n        rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'),\n        rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'),\n        rattributeQuotes = new RegExp('=' + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + '*\\\\]', 'g'),\n        rpseudo = new RegExp(pseudos),\n        ridentifier = new RegExp('^' + identifier + '$'),\n        matchExpr = {\n      'ID': new RegExp('^#(' + identifier + ')'),\n      'CLASS': new RegExp('^\\\\.(' + identifier + ')'),\n      'TAG': new RegExp('^(' + identifier + '|[*])'),\n      'ATTR': new RegExp('^' + attributes),\n      'PSEUDO': new RegExp('^' + pseudos),\n      'CHILD': new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(' + whitespace + '*(even|odd|(([+-]|)(\\\\d*)n|)' + whitespace + '*(?:([+-]|)' + whitespace + '*(\\\\d+)|))' + whitespace + '*\\\\)|)', 'i'),\n      'bool': new RegExp('^(?:' + booleans + ')$', 'i'),\n      // For use in libraries implementing .is()\n      // We use this for POS matching in `select`\n      'needsContext': new RegExp('^' + whitespace + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(' + whitespace + '*((?:-\\\\d)?\\\\d*)' + whitespace + '*\\\\)|)(?=[^-]|$)', 'i')\n    },\n        rinputs = /^(?:input|select|textarea|button)$/i,\n        rheader = /^h\\d$/i,\n        rnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\n    // Easily-parseable/retrievable ID or TAG or CLASS selectors\n    rquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n        rsibling = /[+~]/,\n\n\n    // CSS escapes\n    // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n    runescape = new RegExp('\\\\\\\\([\\\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig'),\n        funescape = function funescape(_, escaped, escapedWhitespace) {\n      var high = '0x' + escaped - 0x10000;\n      // NaN means non-codepoint\n      // Support: Firefox<24\n      // Workaround erroneous numeric interpretation of +\"0x\"\n      return high !== high || escapedWhitespace ? escaped : high < 0 ?\n      // BMP codepoint\n      String.fromCharCode(high + 0x10000) :\n      // Supplemental Plane codepoint (surrogate pair)\n      String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n    },\n\n\n    // CSS string/identifier serialization\n    // https://drafts.csswg.org/cssom/#common-serializing-idioms\n    rcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n        fcssescape = function fcssescape(ch, asCodePoint) {\n      if (asCodePoint) {\n\n        // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n        if (ch === '\\0') {\n          return '\\uFFFD';\n        }\n\n        // Control characters and (dependent upon position) numbers get escaped as code points\n        return ch.slice(0, -1) + '\\\\' + ch.charCodeAt(ch.length - 1).toString(16) + ' ';\n      }\n\n      // Other potentially-special ASCII characters get backslash-escaped\n      return '\\\\' + ch;\n    },\n\n\n    // Used for iframes\n    // See setDocument()\n    // Removing the function wrapper causes a \"Permission Denied\"\n    // error in IE\n    unloadHandler = function unloadHandler() {\n      setDocument();\n    },\n        disabledAncestor = addCombinator(function (elem) {\n      return elem.disabled === true && ('form' in elem || 'label' in elem);\n    }, { dir: 'parentNode', next: 'legend' });\n\n    // Optimize for push.apply( _, NodeList )\n    try {\n      push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);\n      // Support: Android<4.0\n      // Detect silently failing push.apply\n      arr[preferredDoc.childNodes.length].nodeType;\n    } catch (e) {\n      push = { apply: arr.length ?\n\n        // Leverage slice if possible\n        function (target, els) {\n          push_native.apply(target, slice.call(els));\n        } :\n\n        // Support: IE<9\n        // Otherwise append directly\n        function (target, els) {\n          var j = target.length,\n              i = 0;\n          // Can't trust NodeList.length\n          while (target[j++] = els[i++]) {}\n          target.length = j - 1;\n        }\n      };\n    }\n\n    function Sizzle(selector, context, results, seed) {\n      var m,\n          i,\n          elem,\n          nid,\n          match,\n          groups,\n          newSelector,\n          newContext = context && context.ownerDocument,\n\n\n      // nodeType defaults to 9, since context defaults to document\n      nodeType = context ? context.nodeType : 9;\n\n      results = results || [];\n\n      // Return early from calls with invalid selector or context\n      if (typeof selector !== 'string' || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {\n\n        return results;\n      }\n\n      // Try to shortcut find operations (as opposed to filters) in HTML documents\n      if (!seed) {\n\n        if ((context ? context.ownerDocument || context : preferredDoc) !== document) {\n          setDocument(context);\n        }\n        context = context || document;\n\n        if (documentIsHTML) {\n\n          // If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n          // (excepting DocumentFragment context, where the methods don't exist)\n          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {\n\n            // ID selector\n            if (m = match[1]) {\n\n              // Document context\n              if (nodeType === 9) {\n                if (elem = context.getElementById(m)) {\n\n                  // Support: IE, Opera, Webkit\n                  // TODO: identify versions\n                  // getElementById can match elements by name instead of ID\n                  if (elem.id === m) {\n                    results.push(elem);\n                    return results;\n                  }\n                } else {\n                  return results;\n                }\n\n                // Element context\n              } else {\n\n                // Support: IE, Opera, Webkit\n                // TODO: identify versions\n                // getElementById can match elements by name instead of ID\n                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {\n\n                  results.push(elem);\n                  return results;\n                }\n              }\n\n              // Type selector\n            } else if (match[2]) {\n              push.apply(results, context.getElementsByTagName(selector));\n              return results;\n\n              // Class selector\n            } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {\n\n              push.apply(results, context.getElementsByClassName(m));\n              return results;\n            }\n          }\n\n          // Take advantage of querySelectorAll\n          if (support.qsa && !compilerCache[selector + ' '] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {\n\n            if (nodeType !== 1) {\n              newContext = context;\n              newSelector = selector;\n\n              // qSA looks outside Element context, which is not what we want\n              // Thanks to Andrew Dupont for this workaround technique\n              // Support: IE <=8\n              // Exclude object elements\n            } else if (context.nodeName.toLowerCase() !== 'object') {\n\n              // Capture the context ID, setting it first if necessary\n              if (nid = context.getAttribute('id')) {\n                nid = nid.replace(rcssescape, fcssescape);\n              } else {\n                context.setAttribute('id', nid = expando);\n              }\n\n              // Prefix every selector in the list\n              groups = tokenize(selector);\n              i = groups.length;\n              while (i--) {\n                groups[i] = '#' + nid + ' ' + toSelector(groups[i]);\n              }\n              newSelector = groups.join(',');\n\n              // Expand context for sibling selectors\n              newContext = rsibling.test(selector) && testContext(context.parentNode) || context;\n            }\n\n            if (newSelector) {\n              try {\n                push.apply(results, newContext.querySelectorAll(newSelector));\n                return results;\n              } catch (qsaError) {} finally {\n                if (nid === expando) {\n                  context.removeAttribute('id');\n                }\n              }\n            }\n          }\n        }\n      }\n\n      // All others\n      return select(selector.replace(rtrim, '$1'), context, results, seed);\n    }\n\n    /**\n    * Create key-value caches of limited size\n    * @returns {function(string, object)} Returns the Object data after storing it on itself with\n    *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n    *\tdeleting the oldest entry\n    */\n    function createCache() {\n      var keys = [];\n\n      function cache(key, value) {\n        // Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n        if (keys.push(key + ' ') > Expr.cacheLength) {\n          // Only keep the most recent entries\n          delete cache[keys.shift()];\n        }\n        return cache[key + ' '] = value;\n      }\n      return cache;\n    }\n\n    /**\n    * Mark a function for special use by Sizzle\n    * @param {Function} fn The function to mark\n    */\n    function markFunction(fn) {\n      fn[expando] = true;\n      return fn;\n    }\n\n    /**\n    * Support testing using an element\n    * @param {Function} fn Passed the created element and returns a boolean result\n    */\n    function assert(fn) {\n      var el = document.createElement('fieldset');\n\n      try {\n        return !!fn(el);\n      } catch (e) {\n        return false;\n      } finally {\n        // Remove from its parent by default\n        if (el.parentNode) {\n          el.parentNode.removeChild(el);\n        }\n        // release memory in IE\n        el = null;\n      }\n    }\n\n    /**\n    * Adds the same handler for all of the specified attrs\n    * @param {String} attrs Pipe-separated list of attributes\n    * @param {Function} handler The method that will be applied\n    */\n    function addHandle(attrs, handler) {\n      var arr = attrs.split('|'),\n          i = arr.length;\n\n      while (i--) {\n        Expr.attrHandle[arr[i]] = handler;\n      }\n    }\n\n    /**\n    * Checks document order of two siblings\n    * @param {Element} a\n    * @param {Element} b\n    * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n    */\n    function siblingCheck(a, b) {\n      var cur = b && a,\n          diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;\n\n      // Use IE sourceIndex if available on both nodes\n      if (diff) {\n        return diff;\n      }\n\n      // Check if b follows a\n      if (cur) {\n        while (cur = cur.nextSibling) {\n          if (cur === b) {\n            return -1;\n          }\n        }\n      }\n\n      return a ? 1 : -1;\n    }\n\n    /**\n    * Returns a function to use in pseudos for input types\n    * @param {String} type\n    */\n    function createInputPseudo(type) {\n      return function (elem) {\n        var name = elem.nodeName.toLowerCase();\n        return name === 'input' && elem.type === type;\n      };\n    }\n\n    /**\n    * Returns a function to use in pseudos for buttons\n    * @param {String} type\n    */\n    function createButtonPseudo(type) {\n      return function (elem) {\n        var name = elem.nodeName.toLowerCase();\n        return (name === 'input' || name === 'button') && elem.type === type;\n      };\n    }\n\n    /**\n    * Returns a function to use in pseudos for :enabled/:disabled\n    * @param {Boolean} disabled true for :disabled; false for :enabled\n    */\n    function createDisabledPseudo(disabled) {\n\n      // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n      return function (elem) {\n\n        // Only certain elements can match :enabled or :disabled\n        // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n        // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n        if ('form' in elem) {\n\n          // Check for inherited disabledness on relevant non-disabled elements:\n          // * listed form-associated elements in a disabled fieldset\n          //   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n          //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n          // * option elements in a disabled optgroup\n          //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n          // All such elements have a \"form\" property.\n          if (elem.parentNode && elem.disabled === false) {\n\n            // Option elements defer to a parent optgroup if present\n            if ('label' in elem) {\n              if ('label' in elem.parentNode) {\n                return elem.parentNode.disabled === disabled;\n              } else {\n                return elem.disabled === disabled;\n              }\n            }\n\n            // Support: IE 6 - 11\n            // Use the isDisabled shortcut property to check for disabled fieldset ancestors\n            return elem.isDisabled === disabled ||\n\n            // Where there is no isDisabled, check manually\n            /* jshint -W018 */\n            elem.isDisabled !== !disabled && disabledAncestor(elem) === disabled;\n          }\n\n          return elem.disabled === disabled;\n\n          // Try to winnow out elements that can't be disabled before trusting the disabled property.\n          // Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n          // even exist on them, let alone have a boolean value.\n        } else if ('label' in elem) {\n          return elem.disabled === disabled;\n        }\n\n        // Remaining elements are neither :enabled nor :disabled\n        return false;\n      };\n    }\n\n    /**\n    * Returns a function to use in pseudos for positionals\n    * @param {Function} fn\n    */\n    function createPositionalPseudo(fn) {\n      return markFunction(function (argument) {\n        argument = +argument;\n        return markFunction(function (seed, matches) {\n          var j,\n              matchIndexes = fn([], seed.length, argument),\n              i = matchIndexes.length;\n\n          // Match elements found at the specified indexes\n          while (i--) {\n            if (seed[j = matchIndexes[i]]) {\n              seed[j] = !(matches[j] = seed[j]);\n            }\n          }\n        });\n      });\n    }\n\n    /**\n    * Checks a node for validity as a Sizzle context\n    * @param {Element|Object=} context\n    * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n    */\n    function testContext(context) {\n      return context && typeof context.getElementsByTagName !== 'undefined' && context;\n    }\n\n    // Expose support vars for convenience\n    support = Sizzle.support = {};\n\n    /**\n    * Detects XML nodes\n    * @param {Element|Object} elem An element or a document\n    * @returns {Boolean} True iff elem is a non-HTML XML node\n    */\n    isXML = Sizzle.isXML = function (elem) {\n      // documentElement is verified for cases where it doesn't yet exist\n      // (such as loading iframes in IE - #4833)\n      var documentElement = elem && (elem.ownerDocument || elem).documentElement;\n      return documentElement ? documentElement.nodeName !== 'HTML' : false;\n    };\n\n    /**\n    * Sets document-related variables once based on the current document\n    * @param {Element|Object} [doc] An element or document object to use to set the document\n    * @returns {Object} Returns the current document\n    */\n    setDocument = Sizzle.setDocument = function (node) {\n      var hasCompare,\n          subWindow,\n          doc = node ? node.ownerDocument || node : preferredDoc;\n\n      // Return early if doc is invalid or already selected\n      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {\n        return document;\n      }\n\n      // Update global variables\n      document = doc;\n      docElem = document.documentElement;\n      documentIsHTML = !isXML(document);\n\n      // Support: IE 9-11, Edge\n      // Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n      if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {\n\n        // Support: IE 11, Edge\n        if (subWindow.addEventListener) {\n          subWindow.addEventListener('unload', unloadHandler, false);\n\n          // Support: IE 9 - 10 only\n        } else if (subWindow.attachEvent) {\n          subWindow.attachEvent('onunload', unloadHandler);\n        }\n      }\n\n      /* Attributes\n      ---------------------------------------------------------------------- */\n\n      // Support: IE<8\n      // Verify that getAttribute really returns attributes and not properties\n      // (excepting IE8 booleans)\n      support.attributes = assert(function (el) {\n        el.className = 'i';\n        return !el.getAttribute('className');\n      });\n\n      /* getElement(s)By*\n      ---------------------------------------------------------------------- */\n\n      // Check if getElementsByTagName(\"*\") returns only elements\n      support.getElementsByTagName = assert(function (el) {\n        el.appendChild(document.createComment(''));\n        return !el.getElementsByTagName('*').length;\n      });\n\n      // Support: IE<9\n      support.getElementsByClassName = rnative.test(document.getElementsByClassName);\n\n      // Support: IE<10\n      // Check if getElementById returns elements by name\n      // The broken getElementById methods don't pick up programmatically-set names,\n      // so use a roundabout getElementsByName test\n      support.getById = assert(function (el) {\n        docElem.appendChild(el).id = expando;\n        return !document.getElementsByName || !document.getElementsByName(expando).length;\n      });\n\n      // ID filter and find\n      if (support.getById) {\n        Expr.filter['ID'] = function (id) {\n          var attrId = id.replace(runescape, funescape);\n          return function (elem) {\n            return elem.getAttribute('id') === attrId;\n          };\n        };\n        Expr.find['ID'] = function (id, context) {\n          if (typeof context.getElementById !== 'undefined' && documentIsHTML) {\n            var elem = context.getElementById(id);\n            return elem ? [elem] : [];\n          }\n        };\n      } else {\n        Expr.filter['ID'] = function (id) {\n          var attrId = id.replace(runescape, funescape);\n          return function (elem) {\n            var node = typeof elem.getAttributeNode !== 'undefined' && elem.getAttributeNode('id');\n            return node && node.value === attrId;\n          };\n        };\n\n        // Support: IE 6 - 7 only\n        // getElementById is not reliable as a find shortcut\n        Expr.find['ID'] = function (id, context) {\n          if (typeof context.getElementById !== 'undefined' && documentIsHTML) {\n            var node,\n                i,\n                elems,\n                elem = context.getElementById(id);\n\n            if (elem) {\n\n              // Verify the id attribute\n              node = elem.getAttributeNode('id');\n              if (node && node.value === id) {\n                return [elem];\n              }\n\n              // Fall back on getElementsByName\n              elems = context.getElementsByName(id);\n              i = 0;\n              while (elem = elems[i++]) {\n                node = elem.getAttributeNode('id');\n                if (node && node.value === id) {\n                  return [elem];\n                }\n              }\n            }\n\n            return [];\n          }\n        };\n      }\n\n      // Tag\n      Expr.find['TAG'] = support.getElementsByTagName ? function (tag, context) {\n        if (typeof context.getElementsByTagName !== 'undefined') {\n          return context.getElementsByTagName(tag);\n\n          // DocumentFragment nodes don't have gEBTN\n        } else if (support.qsa) {\n          return context.querySelectorAll(tag);\n        }\n      } : function (tag, context) {\n        var elem,\n            tmp = [],\n            i = 0,\n\n        // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n        results = context.getElementsByTagName(tag);\n\n        // Filter out possible comments\n        if (tag === '*') {\n          while (elem = results[i++]) {\n            if (elem.nodeType === 1) {\n              tmp.push(elem);\n            }\n          }\n\n          return tmp;\n        }\n        return results;\n      };\n\n      // Class\n      Expr.find['CLASS'] = support.getElementsByClassName && function (className, context) {\n        if (typeof context.getElementsByClassName !== 'undefined' && documentIsHTML) {\n          return context.getElementsByClassName(className);\n        }\n      };\n\n      /* QSA/matchesSelector\n      ---------------------------------------------------------------------- */\n\n      // QSA and matchesSelector support\n\n      // matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n      rbuggyMatches = [];\n\n      // qSa(:focus) reports false when true (Chrome 21)\n      // We allow this because of a bug in IE8/9 that throws an error\n      // whenever `document.activeElement` is accessed on an iframe\n      // So, we allow :focus to pass through QSA all the time to avoid the IE error\n      // See https://bugs.jquery.com/ticket/13378\n      rbuggyQSA = [];\n\n      if (support.qsa = rnative.test(document.querySelectorAll)) {\n        // Build QSA regex\n        // Regex strategy adopted from Diego Perini\n        assert(function (el) {\n          // Select is set to empty string on purpose\n          // This is to test IE's treatment of not explicitly\n          // setting a boolean content attribute,\n          // since its presence should be enough\n          // https://bugs.jquery.com/ticket/12359\n          docElem.appendChild(el).innerHTML = \"<a id='\" + expando + \"'></a>\" + \"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" + \"<option selected=''></option></select>\";\n\n          // Support: IE8, Opera 11-12.16\n          // Nothing should be selected when empty strings follow ^= or $= or *=\n          // The test attribute must be unknown in Opera but \"safe\" for WinRT\n          // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n          if (el.querySelectorAll(\"[msallowcapture^='']\").length) {\n            rbuggyQSA.push('[*^$]=' + whitespace + \"*(?:''|\\\"\\\")\");\n          }\n\n          // Support: IE8\n          // Boolean attributes and \"value\" are not treated correctly\n          if (!el.querySelectorAll('[selected]').length) {\n            rbuggyQSA.push('\\\\[' + whitespace + '*(?:value|' + booleans + ')');\n          }\n\n          // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n          if (!el.querySelectorAll('[id~=' + expando + '-]').length) {\n            rbuggyQSA.push('~=');\n          }\n\n          // Webkit/Opera - :checked should return selected option elements\n          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n          // IE8 throws error here and will not see later tests\n          if (!el.querySelectorAll(':checked').length) {\n            rbuggyQSA.push(':checked');\n          }\n\n          // Support: Safari 8+, iOS 8+\n          // https://bugs.webkit.org/show_bug.cgi?id=136851\n          // In-page `selector#id sibling-combinator selector` fails\n          if (!el.querySelectorAll('a#' + expando + '+*').length) {\n            rbuggyQSA.push('.#.+[+~]');\n          }\n        });\n\n        assert(function (el) {\n          el.innerHTML = \"<a href='' disabled='disabled'></a>\" + \"<select disabled='disabled'><option/></select>\";\n\n          // Support: Windows 8 Native Apps\n          // The type and name attributes are restricted during .innerHTML assignment\n          var input = document.createElement('input');\n          input.setAttribute('type', 'hidden');\n          el.appendChild(input).setAttribute('name', 'D');\n\n          // Support: IE8\n          // Enforce case-sensitivity of name attribute\n          if (el.querySelectorAll('[name=d]').length) {\n            rbuggyQSA.push('name' + whitespace + '*[*^$|!~]?=');\n          }\n\n          // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n          // IE8 throws error here and will not see later tests\n          if (el.querySelectorAll(':enabled').length !== 2) {\n            rbuggyQSA.push(':enabled', ':disabled');\n          }\n\n          // Support: IE9-11+\n          // IE's :disabled selector does not pick up the children of disabled fieldsets\n          docElem.appendChild(el).disabled = true;\n          if (el.querySelectorAll(':disabled').length !== 2) {\n            rbuggyQSA.push(':enabled', ':disabled');\n          }\n\n          // Opera 10-11 does not throw on post-comma invalid pseudos\n          el.querySelectorAll('*,:x');\n          rbuggyQSA.push(',.*:');\n        });\n      }\n\n      if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {\n\n        assert(function (el) {\n          // Check to see if it's possible to do matchesSelector\n          // on a disconnected node (IE 9)\n          support.disconnectedMatch = matches.call(el, '*');\n\n          // This should fail with an exception\n          // Gecko does not error, returns false instead\n          matches.call(el, \"[s!='']:x\");\n          rbuggyMatches.push('!=', pseudos);\n        });\n      }\n\n      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));\n      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));\n\n      /* Contains\n      ---------------------------------------------------------------------- */\n      hasCompare = rnative.test(docElem.compareDocumentPosition);\n\n      // Element contains another\n      // Purposefully self-exclusive\n      // As in, an element does not contain itself\n      contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {\n        var adown = a.nodeType === 9 ? a.documentElement : a,\n            bup = b && b.parentNode;\n        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));\n      } : function (a, b) {\n        if (b) {\n          while (b = b.parentNode) {\n            if (b === a) {\n              return true;\n            }\n          }\n        }\n        return false;\n      };\n\n      /* Sorting\n      ---------------------------------------------------------------------- */\n\n      // Document order sorting\n      sortOrder = hasCompare ? function (a, b) {\n\n        // Flag for duplicate removal\n        if (a === b) {\n          hasDuplicate = true;\n          return 0;\n        }\n\n        // Sort on method existence if only one input has compareDocumentPosition\n        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n        if (compare) {\n          return compare;\n        }\n\n        // Calculate position if both inputs belong to the same document\n        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) :\n\n        // Otherwise we know they are disconnected\n        1;\n\n        // Disconnected nodes\n        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {\n\n          // Choose the first element that is related to our preferred document\n          if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {\n            return -1;\n          }\n          if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {\n            return 1;\n          }\n\n          // Maintain original order\n          return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;\n        }\n\n        return compare & 4 ? -1 : 1;\n      } : function (a, b) {\n        // Exit early if the nodes are identical\n        if (a === b) {\n          hasDuplicate = true;\n          return 0;\n        }\n\n        var cur,\n            i = 0,\n            aup = a.parentNode,\n            bup = b.parentNode,\n            ap = [a],\n            bp = [b];\n\n        // Parentless nodes are either documents or disconnected\n        if (!aup || !bup) {\n          return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;\n\n          // If the nodes are siblings, we can do a quick check\n        } else if (aup === bup) {\n          return siblingCheck(a, b);\n        }\n\n        // Otherwise we need full lists of their ancestors for comparison\n        cur = a;\n        while (cur = cur.parentNode) {\n          ap.unshift(cur);\n        }\n        cur = b;\n        while (cur = cur.parentNode) {\n          bp.unshift(cur);\n        }\n\n        // Walk down the tree looking for a discrepancy\n        while (ap[i] === bp[i]) {\n          i++;\n        }\n\n        return i ?\n        // Do a sibling check if the nodes have a common ancestor\n        siblingCheck(ap[i], bp[i]) :\n\n        // Otherwise nodes in our document sort first\n        ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;\n      };\n\n      return document;\n    };\n\n    Sizzle.matches = function (expr, elements) {\n      return Sizzle(expr, null, null, elements);\n    };\n\n    Sizzle.matchesSelector = function (elem, expr) {\n      // Set document vars if needed\n      if ((elem.ownerDocument || elem) !== document) {\n        setDocument(elem);\n      }\n\n      // Make sure that attribute selectors are quoted\n      expr = expr.replace(rattributeQuotes, \"='$1']\");\n\n      if (support.matchesSelector && documentIsHTML && !compilerCache[expr + ' '] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {\n\n        try {\n          var ret = matches.call(elem, expr);\n\n          // IE 9's matchesSelector returns false on disconnected nodes\n          if (ret || support.disconnectedMatch ||\n          // As well, disconnected nodes are said to be in a document\n          // fragment in IE 9\n          elem.document && elem.document.nodeType !== 11) {\n            return ret;\n          }\n        } catch (e) {}\n      }\n\n      return Sizzle(expr, document, null, [elem]).length > 0;\n    };\n\n    Sizzle.contains = function (context, elem) {\n      // Set document vars if needed\n      if ((context.ownerDocument || context) !== document) {\n        setDocument(context);\n      }\n      return contains(context, elem);\n    };\n\n    Sizzle.attr = function (elem, name) {\n      // Set document vars if needed\n      if ((elem.ownerDocument || elem) !== document) {\n        setDocument(elem);\n      }\n\n      var fn = Expr.attrHandle[name.toLowerCase()],\n\n      // Don't get fooled by Object.prototype properties (jQuery #13807)\n      val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;\n\n      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n    };\n\n    Sizzle.escape = function (sel) {\n      return (sel + '').replace(rcssescape, fcssescape);\n    };\n\n    Sizzle.error = function (msg) {\n      throw new Error('Syntax error, unrecognized expression: ' + msg);\n    };\n\n    /**\n    * Document sorting and removing duplicates\n    * @param {ArrayLike} results\n    */\n    Sizzle.uniqueSort = function (results) {\n      var elem,\n          duplicates = [],\n          j = 0,\n          i = 0;\n\n      // Unless we *know* we can detect duplicates, assume their presence\n      hasDuplicate = !support.detectDuplicates;\n      sortInput = !support.sortStable && results.slice(0);\n      results.sort(sortOrder);\n\n      if (hasDuplicate) {\n        while (elem = results[i++]) {\n          if (elem === results[i]) {\n            j = duplicates.push(i);\n          }\n        }\n        while (j--) {\n          results.splice(duplicates[j], 1);\n        }\n      }\n\n      // Clear input after sorting to release objects\n      // See https://github.com/jquery/sizzle/pull/225\n      sortInput = null;\n\n      return results;\n    };\n\n    /**\n    * Utility function for retrieving the text value of an array of DOM nodes\n    * @param {Array|Element} elem\n    */\n    getText = Sizzle.getText = function (elem) {\n      var node,\n          ret = '',\n          i = 0,\n          nodeType = elem.nodeType;\n\n      if (!nodeType) {\n        // If no nodeType, this is expected to be an array\n        while (node = elem[i++]) {\n          // Do not traverse comment nodes\n          ret += getText(node);\n        }\n      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\n        // Use textContent for elements\n        // innerText usage removed for consistency of new lines (jQuery #11153)\n        if (typeof elem.textContent === 'string') {\n          return elem.textContent;\n        } else {\n          // Traverse its children\n          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n            ret += getText(elem);\n          }\n        }\n      } else if (nodeType === 3 || nodeType === 4) {\n        return elem.nodeValue;\n      }\n      // Do not include comment or processing instruction nodes\n\n      return ret;\n    };\n\n    Expr = Sizzle.selectors = {\n\n      // Can be adjusted by the user\n      cacheLength: 50,\n\n      createPseudo: markFunction,\n\n      match: matchExpr,\n\n      attrHandle: {},\n\n      find: {},\n\n      relative: {\n        '>': { dir: 'parentNode', first: true },\n        ' ': { dir: 'parentNode' },\n        '+': { dir: 'previousSibling', first: true },\n        '~': { dir: 'previousSibling' }\n      },\n\n      preFilter: {\n        'ATTR': function ATTR(match) {\n          match[1] = match[1].replace(runescape, funescape);\n\n          // Move the given value to match[3] whether quoted or unquoted\n          match[3] = (match[3] || match[4] || match[5] || '').replace(runescape, funescape);\n\n          if (match[2] === '~=') {\n            match[3] = ' ' + match[3] + ' ';\n          }\n\n          return match.slice(0, 4);\n        },\n\n        'CHILD': function CHILD(match) {\n          /* matches from matchExpr[\"CHILD\"]\n          1 type (only|nth|...)\n          2 what (child|of-type)\n          3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n          4 xn-component of xn+y argument ([+-]?\\d*n|)\n          5 sign of xn-component\n          6 x of xn-component\n          7 sign of y-component\n          8 y of y-component\n          */\n          match[1] = match[1].toLowerCase();\n\n          if (match[1].slice(0, 3) === 'nth') {\n            // nth-* requires argument\n            if (!match[3]) {\n              Sizzle.error(match[0]);\n            }\n\n            // numeric x and y parameters for Expr.filter.CHILD\n            // remember that false/true cast respectively to 0/1\n            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));\n            match[5] = +(match[7] + match[8] || match[3] === 'odd');\n\n            // other types prohibit arguments\n          } else if (match[3]) {\n            Sizzle.error(match[0]);\n          }\n\n          return match;\n        },\n\n        'PSEUDO': function PSEUDO(match) {\n          var excess,\n              unquoted = !match[6] && match[2];\n\n          if (matchExpr['CHILD'].test(match[0])) {\n            return null;\n          }\n\n          // Accept quoted arguments as-is\n          if (match[3]) {\n            match[2] = match[4] || match[5] || '';\n\n            // Strip excess characters from unquoted arguments\n          } else if (unquoted && rpseudo.test(unquoted) && (\n          // Get excess from tokenize (recursively)\n          excess = tokenize(unquoted, true)) && (\n          // advance to the next closing parenthesis\n          excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)) {\n\n            // excess is a negative index\n            match[0] = match[0].slice(0, excess);\n            match[2] = unquoted.slice(0, excess);\n          }\n\n          // Return only captures needed by the pseudo filter method (type and argument)\n          return match.slice(0, 3);\n        }\n      },\n\n      filter: {\n\n        'TAG': function TAG(nodeNameSelector) {\n          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();\n          return nodeNameSelector === '*' ? function () {\n            return true;\n          } : function (elem) {\n            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n          };\n        },\n\n        'CLASS': function CLASS(className) {\n          var pattern = classCache[className + ' '];\n\n          return pattern || (pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) && classCache(className, function (elem) {\n            return pattern.test(typeof elem.className === 'string' && elem.className || typeof elem.getAttribute !== 'undefined' && elem.getAttribute('class') || '');\n          });\n        },\n\n        'ATTR': function ATTR(name, operator, check) {\n          return function (elem) {\n            var result = Sizzle.attr(elem, name);\n\n            if (result == null) {\n              return operator === '!=';\n            }\n            if (!operator) {\n              return true;\n            }\n\n            result += '';\n\n            return operator === '=' ? result === check : operator === '!=' ? result !== check : operator === '^=' ? check && result.indexOf(check) === 0 : operator === '*=' ? check && result.indexOf(check) > -1 : operator === '$=' ? check && result.slice(-check.length) === check : operator === '~=' ? (' ' + result.replace(rwhitespace, ' ') + ' ').indexOf(check) > -1 : operator === '|=' ? result === check || result.slice(0, check.length + 1) === check + '-' : false;\n          };\n        },\n\n        'CHILD': function CHILD(type, what, argument, first, last) {\n          var simple = type.slice(0, 3) !== 'nth',\n              forward = type.slice(-4) !== 'last',\n              ofType = what === 'of-type';\n\n          return first === 1 && last === 0 ?\n\n          // Shortcut for :nth-*(n)\n          function (elem) {\n            return !!elem.parentNode;\n          } : function (elem, context, xml) {\n            var cache,\n                uniqueCache,\n                outerCache,\n                node,\n                nodeIndex,\n                start,\n                dir = simple !== forward ? 'nextSibling' : 'previousSibling',\n                parent = elem.parentNode,\n                name = ofType && elem.nodeName.toLowerCase(),\n                useCache = !xml && !ofType,\n                diff = false;\n\n            if (parent) {\n\n              // :(first|last|only)-(child|of-type)\n              if (simple) {\n                while (dir) {\n                  node = elem;\n                  while (node = node[dir]) {\n                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {\n\n                      return false;\n                    }\n                  }\n                  // Reverse direction for :only-* (if we haven't yet done so)\n                  start = dir = type === 'only' && !start && 'nextSibling';\n                }\n                return true;\n              }\n\n              start = [forward ? parent.firstChild : parent.lastChild];\n\n              // non-xml :nth-child(...) stores cache data on `parent`\n              if (forward && useCache) {\n\n                // Seek `elem` from a previously-cached index\n\n                // ...in a gzip-friendly way\n                node = parent;\n                outerCache = node[expando] || (node[expando] = {});\n\n                // Support: IE <9 only\n                // Defend against cloned attroperties (jQuery gh-1709)\n                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n\n                cache = uniqueCache[type] || [];\n                nodeIndex = cache[0] === dirruns && cache[1];\n                diff = nodeIndex && cache[2];\n                node = nodeIndex && parent.childNodes[nodeIndex];\n\n                while (node = ++nodeIndex && node && node[dir] || (\n\n                // Fallback to seeking `elem` from the start\n                diff = nodeIndex = 0) || start.pop()) {\n\n                  // When found, cache indexes on `parent` and break\n                  if (node.nodeType === 1 && ++diff && node === elem) {\n                    uniqueCache[type] = [dirruns, nodeIndex, diff];\n                    break;\n                  }\n                }\n              } else {\n                // Use previously-cached element index if available\n                if (useCache) {\n                  // ...in a gzip-friendly way\n                  node = elem;\n                  outerCache = node[expando] || (node[expando] = {});\n\n                  // Support: IE <9 only\n                  // Defend against cloned attroperties (jQuery gh-1709)\n                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n\n                  cache = uniqueCache[type] || [];\n                  nodeIndex = cache[0] === dirruns && cache[1];\n                  diff = nodeIndex;\n                }\n\n                // xml :nth-child(...)\n                // or :nth-last-child(...) or :nth(-last)?-of-type(...)\n                if (diff === false) {\n                  // Use the same loop as above to seek `elem` from the start\n                  while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {\n\n                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {\n\n                      // Cache the index of each encountered element\n                      if (useCache) {\n                        outerCache = node[expando] || (node[expando] = {});\n\n                        // Support: IE <9 only\n                        // Defend against cloned attroperties (jQuery gh-1709)\n                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n\n                        uniqueCache[type] = [dirruns, diff];\n                      }\n\n                      if (node === elem) {\n                        break;\n                      }\n                    }\n                  }\n                }\n              }\n\n              // Incorporate the offset, then check against cycle size\n              diff -= last;\n              return diff === first || diff % first === 0 && diff / first >= 0;\n            }\n          };\n        },\n\n        'PSEUDO': function PSEUDO(pseudo, argument) {\n          // pseudo-class names are case-insensitive\n          // http://www.w3.org/TR/selectors/#pseudo-classes\n          // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n          // Remember that setFilters inherits from pseudos\n          var args,\n              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error('unsupported pseudo: ' + pseudo);\n\n          // The user may use createPseudo to indicate that\n          // arguments are needed to create the filter function\n          // just as Sizzle does\n          if (fn[expando]) {\n            return fn(argument);\n          }\n\n          // But maintain support for old signatures\n          if (fn.length > 1) {\n            args = [pseudo, pseudo, '', argument];\n            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {\n              var idx,\n                  matched = fn(seed, argument),\n                  i = matched.length;\n              while (i--) {\n                idx = indexOf(seed, matched[i]);\n                seed[idx] = !(matches[idx] = matched[i]);\n              }\n            }) : function (elem) {\n              return fn(elem, 0, args);\n            };\n          }\n\n          return fn;\n        }\n      },\n\n      pseudos: {\n        // Potentially complex pseudos\n        'not': markFunction(function (selector) {\n          // Trim the selector passed to compile\n          // to avoid treating leading and trailing\n          // spaces as combinators\n          var input = [],\n              results = [],\n              matcher = compile(selector.replace(rtrim, '$1'));\n\n          return matcher[expando] ? markFunction(function (seed, matches, context, xml) {\n            var elem,\n                unmatched = matcher(seed, null, xml, []),\n                i = seed.length;\n\n            // Match elements unmatched by `matcher`\n            while (i--) {\n              if (elem = unmatched[i]) {\n                seed[i] = !(matches[i] = elem);\n              }\n            }\n          }) : function (elem, context, xml) {\n            input[0] = elem;\n            matcher(input, null, xml, results);\n            // Don't keep the element (issue #299)\n            input[0] = null;\n            return !results.pop();\n          };\n        }),\n\n        'has': markFunction(function (selector) {\n          return function (elem) {\n            return Sizzle(selector, elem).length > 0;\n          };\n        }),\n\n        'contains': markFunction(function (text) {\n          text = text.replace(runescape, funescape);\n          return function (elem) {\n            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;\n          };\n        }),\n\n        // \"Whether an element is represented by a :lang() selector\n        // is based solely on the element's language value\n        // being equal to the identifier C,\n        // or beginning with the identifier C immediately followed by \"-\".\n        // The matching of C against the element's language value is performed case-insensitively.\n        // The identifier C does not have to be a valid language name.\"\n        // http://www.w3.org/TR/selectors/#lang-pseudo\n        'lang': markFunction(function (lang) {\n          // lang value must be a valid identifier\n          if (!ridentifier.test(lang || '')) {\n            Sizzle.error('unsupported lang: ' + lang);\n          }\n          lang = lang.replace(runescape, funescape).toLowerCase();\n          return function (elem) {\n            var elemLang;\n            do {\n              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang')) {\n\n                elemLang = elemLang.toLowerCase();\n                return elemLang === lang || elemLang.indexOf(lang + '-') === 0;\n              }\n            } while ((elem = elem.parentNode) && elem.nodeType === 1);\n            return false;\n          };\n        }),\n\n        // Miscellaneous\n        'target': function target(elem) {\n          var hash = window.location && window.location.hash;\n          return hash && hash.slice(1) === elem.id;\n        },\n\n        'root': function root(elem) {\n          return elem === docElem;\n        },\n\n        'focus': function focus(elem) {\n          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n        },\n\n        // Boolean properties\n        'enabled': createDisabledPseudo(false),\n        'disabled': createDisabledPseudo(true),\n\n        'checked': function checked(elem) {\n          // In CSS3, :checked should return both checked and selected elements\n          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n          var nodeName = elem.nodeName.toLowerCase();\n          return nodeName === 'input' && !!elem.checked || nodeName === 'option' && !!elem.selected;\n        },\n\n        'selected': function selected(elem) {\n          // Accessing this property makes selected-by-default\n          // options in Safari work properly\n          if (elem.parentNode) {\n            elem.parentNode.selectedIndex;\n          }\n\n          return elem.selected === true;\n        },\n\n        // Contents\n        'empty': function empty(elem) {\n          // http://www.w3.org/TR/selectors/#empty-pseudo\n          // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n          //   but not by others (comment: 8; processing instruction: 7; etc.)\n          // nodeType < 6 works because attributes (2) do not appear as children\n          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n            if (elem.nodeType < 6) {\n              return false;\n            }\n          }\n          return true;\n        },\n\n        'parent': function parent(elem) {\n          return !Expr.pseudos['empty'](elem);\n        },\n\n        // Element/input types\n        'header': function header(elem) {\n          return rheader.test(elem.nodeName);\n        },\n\n        'input': function input(elem) {\n          return rinputs.test(elem.nodeName);\n        },\n\n        'button': function button(elem) {\n          var name = elem.nodeName.toLowerCase();\n          return name === 'input' && elem.type === 'button' || name === 'button';\n        },\n\n        'text': function text(elem) {\n          var attr;\n          return elem.nodeName.toLowerCase() === 'input' && elem.type === 'text' && (\n\n          // Support: IE<8\n          // New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n          (attr = elem.getAttribute('type')) == null || attr.toLowerCase() === 'text');\n        },\n\n        // Position-in-collection\n        'first': createPositionalPseudo(function () {\n          return [0];\n        }),\n\n        'last': createPositionalPseudo(function (matchIndexes, length) {\n          return [length - 1];\n        }),\n\n        'eq': createPositionalPseudo(function (matchIndexes, length, argument) {\n          return [argument < 0 ? argument + length : argument];\n        }),\n\n        'even': createPositionalPseudo(function (matchIndexes, length) {\n          var i = 0;\n          for (; i < length; i += 2) {\n            matchIndexes.push(i);\n          }\n          return matchIndexes;\n        }),\n\n        'odd': createPositionalPseudo(function (matchIndexes, length) {\n          var i = 1;\n          for (; i < length; i += 2) {\n            matchIndexes.push(i);\n          }\n          return matchIndexes;\n        }),\n\n        'lt': createPositionalPseudo(function (matchIndexes, length, argument) {\n          var i = argument < 0 ? argument + length : argument;\n          for (; --i >= 0;) {\n            matchIndexes.push(i);\n          }\n          return matchIndexes;\n        }),\n\n        'gt': createPositionalPseudo(function (matchIndexes, length, argument) {\n          var i = argument < 0 ? argument + length : argument;\n          for (; ++i < length;) {\n            matchIndexes.push(i);\n          }\n          return matchIndexes;\n        })\n      }\n    };\n\n    Expr.pseudos['nth'] = Expr.pseudos['eq'];\n\n    // Add button/input type pseudos\n    for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {\n      Expr.pseudos[i] = createInputPseudo(i);\n    }\n    for (i in { submit: true, reset: true }) {\n      Expr.pseudos[i] = createButtonPseudo(i);\n    }\n\n    // Easy API for creating new setFilters\n    function setFilters() {}\n    setFilters.prototype = Expr.filters = Expr.pseudos;\n    Expr.setFilters = new setFilters();\n\n    tokenize = Sizzle.tokenize = function (selector, parseOnly) {\n      var matched,\n          match,\n          tokens,\n          type,\n          soFar,\n          groups,\n          preFilters,\n          cached = tokenCache[selector + ' '];\n\n      if (cached) {\n        return parseOnly ? 0 : cached.slice(0);\n      }\n\n      soFar = selector;\n      groups = [];\n      preFilters = Expr.preFilter;\n\n      while (soFar) {\n\n        // Comma and first run\n        if (!matched || (match = rcomma.exec(soFar))) {\n          if (match) {\n            // Don't consume trailing commas as valid\n            soFar = soFar.slice(match[0].length) || soFar;\n          }\n          groups.push(tokens = []);\n        }\n\n        matched = false;\n\n        // Combinators\n        if (match = rcombinators.exec(soFar)) {\n          matched = match.shift();\n          tokens.push({\n            value: matched,\n            // Cast descendant combinators to space\n            type: match[0].replace(rtrim, ' ')\n          });\n          soFar = soFar.slice(matched.length);\n        }\n\n        // Filters\n        for (type in Expr.filter) {\n          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {\n            matched = match.shift();\n            tokens.push({\n              value: matched,\n              type: type,\n              matches: match\n            });\n            soFar = soFar.slice(matched.length);\n          }\n        }\n\n        if (!matched) {\n          break;\n        }\n      }\n\n      // Return the length of the invalid excess\n      // if we're just parsing\n      // Otherwise, throw an error or return tokens\n      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) :\n      // Cache the tokens\n      tokenCache(selector, groups).slice(0);\n    };\n\n    function toSelector(tokens) {\n      var i = 0,\n          len = tokens.length,\n          selector = '';\n      for (; i < len; i++) {\n        selector += tokens[i].value;\n      }\n      return selector;\n    }\n\n    function addCombinator(matcher, combinator, base) {\n      var dir = combinator.dir,\n          skip = combinator.next,\n          key = skip || dir,\n          checkNonElements = base && key === 'parentNode',\n          doneName = done++;\n\n      return combinator.first ?\n      // Check against closest ancestor/preceding element\n      function (elem, context, xml) {\n        while (elem = elem[dir]) {\n          if (elem.nodeType === 1 || checkNonElements) {\n            return matcher(elem, context, xml);\n          }\n        }\n        return false;\n      } :\n\n      // Check against all ancestor/preceding elements\n      function (elem, context, xml) {\n        var oldCache,\n            uniqueCache,\n            outerCache,\n            newCache = [dirruns, doneName];\n\n        // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n        if (xml) {\n          while (elem = elem[dir]) {\n            if (elem.nodeType === 1 || checkNonElements) {\n              if (matcher(elem, context, xml)) {\n                return true;\n              }\n            }\n          }\n        } else {\n          while (elem = elem[dir]) {\n            if (elem.nodeType === 1 || checkNonElements) {\n              outerCache = elem[expando] || (elem[expando] = {});\n\n              // Support: IE <9 only\n              // Defend against cloned attroperties (jQuery gh-1709)\n              uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});\n\n              if (skip && skip === elem.nodeName.toLowerCase()) {\n                elem = elem[dir] || elem;\n              } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {\n\n                // Assign to newCache so results back-propagate to previous elements\n                return newCache[2] = oldCache[2];\n              } else {\n                // Reuse newcache so results back-propagate to previous elements\n                uniqueCache[key] = newCache;\n\n                // A match means we're done; a fail means we have to keep checking\n                if (newCache[2] = matcher(elem, context, xml)) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n        return false;\n      };\n    }\n\n    function elementMatcher(matchers) {\n      return matchers.length > 1 ? function (elem, context, xml) {\n        var i = matchers.length;\n        while (i--) {\n          if (!matchers[i](elem, context, xml)) {\n            return false;\n          }\n        }\n        return true;\n      } : matchers[0];\n    }\n\n    function multipleContexts(selector, contexts, results) {\n      var i = 0,\n          len = contexts.length;\n      for (; i < len; i++) {\n        Sizzle(selector, contexts[i], results);\n      }\n      return results;\n    }\n\n    function condense(unmatched, map, filter, context, xml) {\n      var elem,\n          newUnmatched = [],\n          i = 0,\n          len = unmatched.length,\n          mapped = map != null;\n\n      for (; i < len; i++) {\n        if (elem = unmatched[i]) {\n          if (!filter || filter(elem, context, xml)) {\n            newUnmatched.push(elem);\n            if (mapped) {\n              map.push(i);\n            }\n          }\n        }\n      }\n\n      return newUnmatched;\n    }\n\n    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {\n      if (postFilter && !postFilter[expando]) {\n        postFilter = setMatcher(postFilter);\n      }\n      if (postFinder && !postFinder[expando]) {\n        postFinder = setMatcher(postFinder, postSelector);\n      }\n      return markFunction(function (seed, results, context, xml) {\n        var temp,\n            i,\n            elem,\n            preMap = [],\n            postMap = [],\n            preexisting = results.length,\n\n\n        // Get initial elements from seed or context\n        elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []),\n\n\n        // Prefilter to get matcher input, preserving a map for seed-results synchronization\n        matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,\n            matcherOut = matcher ?\n        // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n        postFinder || (seed ? preFilter : preexisting || postFilter) ?\n\n        // ...intermediate processing is necessary\n        [] :\n\n        // ...otherwise use results directly\n        results : matcherIn;\n\n        // Find primary matches\n        if (matcher) {\n          matcher(matcherIn, matcherOut, context, xml);\n        }\n\n        // Apply postFilter\n        if (postFilter) {\n          temp = condense(matcherOut, postMap);\n          postFilter(temp, [], context, xml);\n\n          // Un-match failing elements by moving them back to matcherIn\n          i = temp.length;\n          while (i--) {\n            if (elem = temp[i]) {\n              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);\n            }\n          }\n        }\n\n        if (seed) {\n          if (postFinder || preFilter) {\n            if (postFinder) {\n              // Get the final matcherOut by condensing this intermediate into postFinder contexts\n              temp = [];\n              i = matcherOut.length;\n              while (i--) {\n                if (elem = matcherOut[i]) {\n                  // Restore matcherIn since elem is not yet a final match\n                  temp.push(matcherIn[i] = elem);\n                }\n              }\n              postFinder(null, matcherOut = [], temp, xml);\n            }\n\n            // Move matched elements from seed to results to keep them synchronized\n            i = matcherOut.length;\n            while (i--) {\n              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {\n\n                seed[temp] = !(results[temp] = elem);\n              }\n            }\n          }\n\n          // Add elements to results, through postFinder if defined\n        } else {\n          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);\n          if (postFinder) {\n            postFinder(null, results, matcherOut, xml);\n          } else {\n            push.apply(results, matcherOut);\n          }\n        }\n      });\n    }\n\n    function matcherFromTokens(tokens) {\n      var checkContext,\n          matcher,\n          j,\n          len = tokens.length,\n          leadingRelative = Expr.relative[tokens[0].type],\n          implicitRelative = leadingRelative || Expr.relative[' '],\n          i = leadingRelative ? 1 : 0,\n\n\n      // The foundational matcher ensures that elements are reachable from top-level context(s)\n      matchContext = addCombinator(function (elem) {\n        return elem === checkContext;\n      }, implicitRelative, true),\n          matchAnyContext = addCombinator(function (elem) {\n        return indexOf(checkContext, elem) > -1;\n      }, implicitRelative, true),\n          matchers = [function (elem, context, xml) {\n        var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));\n        // Avoid hanging onto element (issue #299)\n        checkContext = null;\n        return ret;\n      }];\n\n      for (; i < len; i++) {\n        if (matcher = Expr.relative[tokens[i].type]) {\n          matchers = [addCombinator(elementMatcher(matchers), matcher)];\n        } else {\n          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);\n\n          // Return special upon seeing a positional matcher\n          if (matcher[expando]) {\n            // Find the next relative operator (if any) for proper handling\n            j = ++i;\n            for (; j < len; j++) {\n              if (Expr.relative[tokens[j].type]) {\n                break;\n              }\n            }\n            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(\n            // If the preceding token was a descendant combinator, insert an implicit any-element `*`\n            tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })).replace(rtrim, '$1'), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));\n          }\n          matchers.push(matcher);\n        }\n      }\n\n      return elementMatcher(matchers);\n    }\n\n    function matcherFromGroupMatchers(elementMatchers, setMatchers) {\n      var bySet = setMatchers.length > 0,\n          byElement = elementMatchers.length > 0,\n          superMatcher = function superMatcher(seed, context, xml, results, outermost) {\n        var elem,\n            j,\n            matcher,\n            matchedCount = 0,\n            i = '0',\n            unmatched = seed && [],\n            setMatched = [],\n            contextBackup = outermostContext,\n\n        // We must always have either seed elements or outermost context\n        elems = seed || byElement && Expr.find['TAG']('*', outermost),\n\n        // Use integer dirruns iff this is the outermost matcher\n        dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,\n            len = elems.length;\n\n        if (outermost) {\n          outermostContext = context === document || context || outermost;\n        }\n\n        // Add elements passing elementMatchers directly to results\n        // Support: IE<9, Safari\n        // Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n        for (; i !== len && (elem = elems[i]) != null; i++) {\n          if (byElement && elem) {\n            j = 0;\n            if (!context && elem.ownerDocument !== document) {\n              setDocument(elem);\n              xml = !documentIsHTML;\n            }\n            while (matcher = elementMatchers[j++]) {\n              if (matcher(elem, context || document, xml)) {\n                results.push(elem);\n                break;\n              }\n            }\n            if (outermost) {\n              dirruns = dirrunsUnique;\n            }\n          }\n\n          // Track unmatched elements for set filters\n          if (bySet) {\n            // They will have gone through all possible matchers\n            if (elem = !matcher && elem) {\n              matchedCount--;\n            }\n\n            // Lengthen the array for every element, matched or not\n            if (seed) {\n              unmatched.push(elem);\n            }\n          }\n        }\n\n        // `i` is now the count of elements visited above, and adding it to `matchedCount`\n        // makes the latter nonnegative.\n        matchedCount += i;\n\n        // Apply set filters to unmatched elements\n        // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n        // equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n        // no element matchers and no seed.\n        // Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n        // case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n        // numerically zero.\n        if (bySet && i !== matchedCount) {\n          j = 0;\n          while (matcher = setMatchers[j++]) {\n            matcher(unmatched, setMatched, context, xml);\n          }\n\n          if (seed) {\n            // Reintegrate element matches to eliminate the need for sorting\n            if (matchedCount > 0) {\n              while (i--) {\n                if (!(unmatched[i] || setMatched[i])) {\n                  setMatched[i] = pop.call(results);\n                }\n              }\n            }\n\n            // Discard index placeholder values to get only actual matches\n            setMatched = condense(setMatched);\n          }\n\n          // Add matches to results\n          push.apply(results, setMatched);\n\n          // Seedless set matches succeeding multiple successful matchers stipulate sorting\n          if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {\n\n            Sizzle.uniqueSort(results);\n          }\n        }\n\n        // Override manipulation of globals by nested matchers\n        if (outermost) {\n          dirruns = dirrunsUnique;\n          outermostContext = contextBackup;\n        }\n\n        return unmatched;\n      };\n\n      return bySet ? markFunction(superMatcher) : superMatcher;\n    }\n\n    compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {\n      var i,\n          setMatchers = [],\n          elementMatchers = [],\n          cached = compilerCache[selector + ' '];\n\n      if (!cached) {\n        // Generate a function of recursive functions that can be used to check each element\n        if (!match) {\n          match = tokenize(selector);\n        }\n        i = match.length;\n        while (i--) {\n          cached = matcherFromTokens(match[i]);\n          if (cached[expando]) {\n            setMatchers.push(cached);\n          } else {\n            elementMatchers.push(cached);\n          }\n        }\n\n        // Cache the compiled function\n        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));\n\n        // Save selector and tokenization\n        cached.selector = selector;\n      }\n      return cached;\n    };\n\n    /**\n    * A low-level selection function that works with Sizzle's compiled\n    *  selector functions\n    * @param {String|Function} selector A selector or a pre-compiled\n    *  selector function built with Sizzle.compile\n    * @param {Element} context\n    * @param {Array} [results]\n    * @param {Array} [seed] A set of elements to match against\n    */\n    select = Sizzle.select = function (selector, context, results, seed) {\n      var i,\n          tokens,\n          token,\n          type,\n          find,\n          compiled = typeof selector === 'function' && selector,\n          match = !seed && tokenize(selector = compiled.selector || selector);\n\n      results = results || [];\n\n      // Try to minimize operations if there is only one selector in the list and no seed\n      // (the latter of which guarantees us context)\n      if (match.length === 1) {\n\n        // Reduce context if the leading compound selector is an ID\n        tokens = match[0] = match[0].slice(0);\n        if (tokens.length > 2 && (token = tokens[0]).type === 'ID' && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {\n\n          context = (Expr.find['ID'](token.matches[0].replace(runescape, funescape), context) || [])[0];\n          if (!context) {\n            return results;\n\n            // Precompiled matchers will still verify ancestry, so step up a level\n          } else if (compiled) {\n            context = context.parentNode;\n          }\n\n          selector = selector.slice(tokens.shift().value.length);\n        }\n\n        // Fetch a seed set for right-to-left matching\n        i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length;\n        while (i--) {\n          token = tokens[i];\n\n          // Abort if we hit a combinator\n          if (Expr.relative[type = token.type]) {\n            break;\n          }\n          if (find = Expr.find[type]) {\n            // Search, expanding context for leading sibling combinators\n            if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {\n\n              // If seed is empty or no tokens remain, we can return early\n              tokens.splice(i, 1);\n              selector = seed.length && toSelector(tokens);\n              if (!selector) {\n                push.apply(results, seed);\n                return results;\n              }\n\n              break;\n            }\n          }\n        }\n      }\n\n      // Compile and execute a filtering function if one is not provided\n      // Provide `match` to avoid retokenization if we modified the selector above\n      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);\n      return results;\n    };\n\n    // One-time assignments\n\n    // Sort stability\n    support.sortStable = expando.split('').sort(sortOrder).join('') === expando;\n\n    // Support: Chrome 14-35+\n    // Always assume duplicates if they aren't passed to the comparison function\n    support.detectDuplicates = !!hasDuplicate;\n\n    // Initialize against the default document\n    setDocument();\n\n    // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n    // Detached nodes confoundingly follow *each other*\n    support.sortDetached = assert(function (el) {\n      // Should return 1, but returns 4 (following)\n      return el.compareDocumentPosition(document.createElement('fieldset')) & 1;\n    });\n\n    // Support: IE<8\n    // Prevent attribute/property \"interpolation\"\n    // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n    if (!assert(function (el) {\n      el.innerHTML = \"<a href='#'></a>\";\n      return el.firstChild.getAttribute('href') === '#';\n    })) {\n      addHandle('type|href|height|width', function (elem, name, isXML) {\n        if (!isXML) {\n          return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2);\n        }\n      });\n    }\n\n    // Support: IE<9\n    // Use defaultValue in place of getAttribute(\"value\")\n    if (!support.attributes || !assert(function (el) {\n      el.innerHTML = '<input/>';\n      el.firstChild.setAttribute('value', '');\n      return el.firstChild.getAttribute('value') === '';\n    })) {\n      addHandle('value', function (elem, name, isXML) {\n        if (!isXML && elem.nodeName.toLowerCase() === 'input') {\n          return elem.defaultValue;\n        }\n      });\n    }\n\n    // Support: IE<9\n    // Use getAttributeNode to fetch booleans when getAttribute lies\n    if (!assert(function (el) {\n      return el.getAttribute('disabled') == null;\n    })) {\n      addHandle(booleans, function (elem, name, isXML) {\n        var val;\n        if (!isXML) {\n          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n        }\n      });\n    }\n\n    return Sizzle;\n  }(window);\n\n  jQuery.find = Sizzle;\n  jQuery.expr = Sizzle.selectors;\n\n  // Deprecated\n  jQuery.expr[':'] = jQuery.expr.pseudos;\n  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\n  jQuery.text = Sizzle.getText;\n  jQuery.isXMLDoc = Sizzle.isXML;\n  jQuery.contains = Sizzle.contains;\n  jQuery.escapeSelector = Sizzle.escape;\n\n  var dir = function dir(elem, _dir, until) {\n    var matched = [],\n        truncate = until !== undefined;\n\n    while ((elem = elem[_dir]) && elem.nodeType !== 9) {\n      if (elem.nodeType === 1) {\n        if (truncate && jQuery(elem).is(until)) {\n          break;\n        }\n        matched.push(elem);\n      }\n    }\n    return matched;\n  };\n\n  var _siblings = function _siblings(n, elem) {\n    var matched = [];\n\n    for (; n; n = n.nextSibling) {\n      if (n.nodeType === 1 && n !== elem) {\n        matched.push(n);\n      }\n    }\n\n    return matched;\n  };\n\n  var rneedsContext = jQuery.expr.match.needsContext;\n\n  function nodeName(elem, name) {\n\n    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n  };\n  var rsingleTag = /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i;\n\n  // Implement the identical functionality for filter and not\n  function winnow(elements, qualifier, not) {\n    if (isFunction(qualifier)) {\n      return jQuery.grep(elements, function (elem, i) {\n        return !!qualifier.call(elem, i, elem) !== not;\n      });\n    }\n\n    // Single element\n    if (qualifier.nodeType) {\n      return jQuery.grep(elements, function (elem) {\n        return elem === qualifier !== not;\n      });\n    }\n\n    // Arraylike of elements (jQuery, arguments, Array)\n    if (typeof qualifier !== 'string') {\n      return jQuery.grep(elements, function (elem) {\n        return indexOf.call(qualifier, elem) > -1 !== not;\n      });\n    }\n\n    // Filtered directly for both simple and complex selectors\n    return jQuery.filter(qualifier, elements, not);\n  }\n\n  jQuery.filter = function (expr, elems, not) {\n    var elem = elems[0];\n\n    if (not) {\n      expr = ':not(' + expr + ')';\n    }\n\n    if (elems.length === 1 && elem.nodeType === 1) {\n      return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];\n    }\n\n    return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {\n      return elem.nodeType === 1;\n    }));\n  };\n\n  jQuery.fn.extend({\n    find: function find(selector) {\n      var i,\n          ret,\n          len = this.length,\n          self = this;\n\n      if (typeof selector !== 'string') {\n        return this.pushStack(jQuery(selector).filter(function () {\n          for (i = 0; i < len; i++) {\n            if (jQuery.contains(self[i], this)) {\n              return true;\n            }\n          }\n        }));\n      }\n\n      ret = this.pushStack([]);\n\n      for (i = 0; i < len; i++) {\n        jQuery.find(selector, self[i], ret);\n      }\n\n      return len > 1 ? jQuery.uniqueSort(ret) : ret;\n    },\n    filter: function filter(selector) {\n      return this.pushStack(winnow(this, selector || [], false));\n    },\n    not: function not(selector) {\n      return this.pushStack(winnow(this, selector || [], true));\n    },\n    is: function is(selector) {\n      return !!winnow(this,\n\n      // If this is a positional/relative selector, check membership in the returned set\n      // so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n      typeof selector === 'string' && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;\n    }\n  });\n\n  // Initialize a jQuery object\n\n\n  // A central reference to the root jQuery(document)\n  var rootjQuery,\n\n\n  // A simple way to check for HTML strings\n  // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n  // Strict HTML recognition (#11290: must start with <)\n  // Shortcut simple #id case for speed\n  rquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n      init = jQuery.fn.init = function (selector, context, root) {\n    var match, elem;\n\n    // HANDLE: $(\"\"), $(null), $(undefined), $(false)\n    if (!selector) {\n      return this;\n    }\n\n    // Method init() accepts an alternate rootjQuery\n    // so migrate can support jQuery.sub (gh-2101)\n    root = root || rootjQuery;\n\n    // Handle HTML strings\n    if (typeof selector === 'string') {\n      if (selector[0] === '<' && selector[selector.length - 1] === '>' && selector.length >= 3) {\n\n        // Assume that strings that start and end with <> are HTML and skip the regex check\n        match = [null, selector, null];\n      } else {\n        match = rquickExpr.exec(selector);\n      }\n\n      // Match html or make sure no context is specified for #id\n      if (match && (match[1] || !context)) {\n\n        // HANDLE: $(html) -> $(array)\n        if (match[1]) {\n          context = context instanceof jQuery ? context[0] : context;\n\n          // Option to run scripts is true for back-compat\n          // Intentionally let the error be thrown if parseHTML is not present\n          jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));\n\n          // HANDLE: $(html, props)\n          if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {\n            for (match in context) {\n\n              // Properties of context are called as methods if possible\n              if (isFunction(this[match])) {\n                this[match](context[match]);\n\n                // ...and otherwise set as attributes\n              } else {\n                this.attr(match, context[match]);\n              }\n            }\n          }\n\n          return this;\n\n          // HANDLE: $(#id)\n        } else {\n          elem = document.getElementById(match[2]);\n\n          if (elem) {\n\n            // Inject the element directly into the jQuery object\n            this[0] = elem;\n            this.length = 1;\n          }\n          return this;\n        }\n\n        // HANDLE: $(expr, $(...))\n      } else if (!context || context.jquery) {\n        return (context || root).find(selector);\n\n        // HANDLE: $(expr, context)\n        // (which is just equivalent to: $(context).find(expr)\n      } else {\n        return this.constructor(context).find(selector);\n      }\n\n      // HANDLE: $(DOMElement)\n    } else if (selector.nodeType) {\n      this[0] = selector;\n      this.length = 1;\n      return this;\n\n      // HANDLE: $(function)\n      // Shortcut for document ready\n    } else if (isFunction(selector)) {\n      return root.ready !== undefined ? root.ready(selector) :\n\n      // Execute immediately if ready is not present\n      selector(jQuery);\n    }\n\n    return jQuery.makeArray(selector, this);\n  };\n\n  // Give the init function the jQuery prototype for later instantiation\n  init.prototype = jQuery.fn;\n\n  // Initialize central reference\n  rootjQuery = jQuery(document);\n\n  var rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\n  // Methods guaranteed to produce a unique set when starting from a unique set\n  guaranteedUnique = {\n    children: true,\n    contents: true,\n    next: true,\n    prev: true\n  };\n\n  jQuery.fn.extend({\n    has: function has(target) {\n      var targets = jQuery(target, this),\n          l = targets.length;\n\n      return this.filter(function () {\n        var i = 0;\n        for (; i < l; i++) {\n          if (jQuery.contains(this, targets[i])) {\n            return true;\n          }\n        }\n      });\n    },\n\n    closest: function closest(selectors, context) {\n      var cur,\n          i = 0,\n          l = this.length,\n          matched = [],\n          targets = typeof selectors !== 'string' && jQuery(selectors);\n\n      // Positional selectors never match, since there's no _selection_ context\n      if (!rneedsContext.test(selectors)) {\n        for (; i < l; i++) {\n          for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {\n\n            // Always skip document fragments\n            if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 :\n\n            // Don't pass non-elements to Sizzle\n            cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {\n\n              matched.push(cur);\n              break;\n            }\n          }\n        }\n      }\n\n      return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);\n    },\n\n    // Determine the position of an element within the set\n    index: function index(elem) {\n\n      // No argument, return index in parent\n      if (!elem) {\n        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;\n      }\n\n      // Index in selector\n      if (typeof elem === 'string') {\n        return indexOf.call(jQuery(elem), this[0]);\n      }\n\n      // Locate the position of the desired element\n      return indexOf.call(this,\n\n      // If it receives a jQuery object, the first element is used\n      elem.jquery ? elem[0] : elem);\n    },\n\n    add: function add(selector, context) {\n      return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));\n    },\n\n    addBack: function addBack(selector) {\n      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));\n    }\n  });\n\n  function sibling(cur, dir) {\n    while ((cur = cur[dir]) && cur.nodeType !== 1) {}\n    return cur;\n  }\n\n  jQuery.each({\n    parent: function parent(elem) {\n      var parent = elem.parentNode;\n      return parent && parent.nodeType !== 11 ? parent : null;\n    },\n    parents: function parents(elem) {\n      return dir(elem, 'parentNode');\n    },\n    parentsUntil: function parentsUntil(elem, i, until) {\n      return dir(elem, 'parentNode', until);\n    },\n    next: function next(elem) {\n      return sibling(elem, 'nextSibling');\n    },\n    prev: function prev(elem) {\n      return sibling(elem, 'previousSibling');\n    },\n    nextAll: function nextAll(elem) {\n      return dir(elem, 'nextSibling');\n    },\n    prevAll: function prevAll(elem) {\n      return dir(elem, 'previousSibling');\n    },\n    nextUntil: function nextUntil(elem, i, until) {\n      return dir(elem, 'nextSibling', until);\n    },\n    prevUntil: function prevUntil(elem, i, until) {\n      return dir(elem, 'previousSibling', until);\n    },\n    siblings: function siblings(elem) {\n      return _siblings((elem.parentNode || {}).firstChild, elem);\n    },\n    children: function children(elem) {\n      return _siblings(elem.firstChild);\n    },\n    contents: function contents(elem) {\n      if (nodeName(elem, 'iframe')) {\n        return elem.contentDocument;\n      }\n\n      // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n      // Treat the template element as a regular one in browsers that\n      // don't support it.\n      if (nodeName(elem, 'template')) {\n        elem = elem.content || elem;\n      }\n\n      return jQuery.merge([], elem.childNodes);\n    }\n  }, function (name, fn) {\n    jQuery.fn[name] = function (until, selector) {\n      var matched = jQuery.map(this, fn, until);\n\n      if (name.slice(-5) !== 'Until') {\n        selector = until;\n      }\n\n      if (selector && typeof selector === 'string') {\n        matched = jQuery.filter(selector, matched);\n      }\n\n      if (this.length > 1) {\n\n        // Remove duplicates\n        if (!guaranteedUnique[name]) {\n          jQuery.uniqueSort(matched);\n        }\n\n        // Reverse order for parents* and prev-derivatives\n        if (rparentsprev.test(name)) {\n          matched.reverse();\n        }\n      }\n\n      return this.pushStack(matched);\n    };\n  });\n  var rnothtmlwhite = /[^\\x20\\t\\r\\n\\f]+/g;\n\n  // Convert String-formatted options into Object-formatted ones\n  function createOptions(options) {\n    var object = {};\n    jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {\n      object[flag] = true;\n    });\n    return object;\n  }\n\n  /*\n  * Create a callback list using the following parameters:\n  *\n  *\toptions: an optional list of space-separated options that will change how\n  *\t\t\tthe callback list behaves or a more traditional option object\n  *\n  * By default a callback list will act like an event callback list and can be\n  * \"fired\" multiple times.\n  *\n  * Possible options:\n  *\n  *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n  *\n  *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n  *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n  *\t\t\t\t\tvalues (like a Deferred)\n  *\n  *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n  *\n  *\tstopOnFalse:\tinterrupt callings when a callback returns false\n  *\n  */\n  jQuery.Callbacks = function (options) {\n\n    // Convert options from String-formatted to Object-formatted if needed\n    // (we check in cache first)\n    options = typeof options === 'string' ? createOptions(options) : jQuery.extend({}, options);\n\n    var // Flag to know if list is currently firing\n    firing,\n\n\n    // Last fire value for non-forgettable lists\n    memory,\n\n\n    // Flag to know if list was already fired\n    _fired,\n\n\n    // Flag to prevent firing\n    _locked,\n\n\n    // Actual callback list\n    list = [],\n\n\n    // Queue of execution data for repeatable lists\n    queue = [],\n\n\n    // Index of currently firing callback (modified by add/remove as needed)\n    firingIndex = -1,\n\n\n    // Fire callbacks\n    fire = function fire() {\n\n      // Enforce single-firing\n      _locked = _locked || options.once;\n\n      // Execute callbacks for all pending executions,\n      // respecting firingIndex overrides and runtime changes\n      _fired = firing = true;\n      for (; queue.length; firingIndex = -1) {\n        memory = queue.shift();\n        while (++firingIndex < list.length) {\n\n          // Run callback and check for early termination\n          if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {\n\n            // Jump to end and forget the data so .add doesn't re-fire\n            firingIndex = list.length;\n            memory = false;\n          }\n        }\n      }\n\n      // Forget the data if we're done with it\n      if (!options.memory) {\n        memory = false;\n      }\n\n      firing = false;\n\n      // Clean up if we're done firing for good\n      if (_locked) {\n\n        // Keep an empty list if we have data for future add calls\n        if (memory) {\n          list = [];\n\n          // Otherwise, this object is spent\n        } else {\n          list = '';\n        }\n      }\n    },\n\n\n    // Actual Callbacks object\n    self = {\n\n      // Add a callback or a collection of callbacks to the list\n      add: function add() {\n        if (list) {\n\n          // If we have memory from a past run, we should fire after adding\n          if (memory && !firing) {\n            firingIndex = list.length - 1;\n            queue.push(memory);\n          }\n\n          (function add(args) {\n            jQuery.each(args, function (_, arg) {\n              if (isFunction(arg)) {\n                if (!options.unique || !self.has(arg)) {\n                  list.push(arg);\n                }\n              } else if (arg && arg.length && toType(arg) !== 'string') {\n\n                // Inspect recursively\n                add(arg);\n              }\n            });\n          })(arguments);\n\n          if (memory && !firing) {\n            fire();\n          }\n        }\n        return this;\n      },\n\n      // Remove a callback from the list\n      remove: function remove() {\n        jQuery.each(arguments, function (_, arg) {\n          var index;\n          while ((index = jQuery.inArray(arg, list, index)) > -1) {\n            list.splice(index, 1);\n\n            // Handle firing indexes\n            if (index <= firingIndex) {\n              firingIndex--;\n            }\n          }\n        });\n        return this;\n      },\n\n      // Check if a given callback is in the list.\n      // If no argument is given, return whether or not list has callbacks attached.\n      has: function has(fn) {\n        return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;\n      },\n\n      // Remove all callbacks from the list\n      empty: function empty() {\n        if (list) {\n          list = [];\n        }\n        return this;\n      },\n\n      // Disable .fire and .add\n      // Abort any current/pending executions\n      // Clear all callbacks and values\n      disable: function disable() {\n        _locked = queue = [];\n        list = memory = '';\n        return this;\n      },\n      disabled: function disabled() {\n        return !list;\n      },\n\n      // Disable .fire\n      // Also disable .add unless we have memory (since it would have no effect)\n      // Abort any pending executions\n      lock: function lock() {\n        _locked = queue = [];\n        if (!memory && !firing) {\n          list = memory = '';\n        }\n        return this;\n      },\n      locked: function locked() {\n        return !!_locked;\n      },\n\n      // Call all callbacks with the given context and arguments\n      fireWith: function fireWith(context, args) {\n        if (!_locked) {\n          args = args || [];\n          args = [context, args.slice ? args.slice() : args];\n          queue.push(args);\n          if (!firing) {\n            fire();\n          }\n        }\n        return this;\n      },\n\n      // Call all the callbacks with the given arguments\n      fire: function fire() {\n        self.fireWith(this, arguments);\n        return this;\n      },\n\n      // To know if the callbacks have already been called at least once\n      fired: function fired() {\n        return !!_fired;\n      }\n    };\n\n    return self;\n  };\n\n  function Identity(v) {\n    return v;\n  }\n  function Thrower(ex) {\n    throw ex;\n  }\n\n  function adoptValue(value, resolve, reject, noValue) {\n    var method;\n\n    try {\n\n      // Check for promise aspect first to privilege synchronous behavior\n      if (value && isFunction(method = value.promise)) {\n        method.call(value).done(resolve).fail(reject);\n\n        // Other thenables\n      } else if (value && isFunction(method = value.then)) {\n        method.call(value, resolve, reject);\n\n        // Other non-thenables\n      } else {\n\n        // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n        // * false: [ value ].slice( 0 ) => resolve( value )\n        // * true: [ value ].slice( 1 ) => resolve()\n        resolve.apply(undefined, [value].slice(noValue));\n      }\n\n      // For Promises/A+, convert exceptions into rejections\n      // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n      // Deferred#then to conditionally suppress rejection.\n    } catch (value) {\n\n      // Support: Android 4.0 only\n      // Strict mode functions invoked without .call/.apply get global-object context\n      reject.apply(undefined, [value]);\n    }\n  }\n\n  jQuery.extend({\n\n    Deferred: function Deferred(func) {\n      var tuples = [\n\n      // action, add listener, callbacks,\n      // ... .then handlers, argument index, [final state]\n      ['notify', 'progress', jQuery.Callbacks('memory'), jQuery.Callbacks('memory'), 2], ['resolve', 'done', jQuery.Callbacks('once memory'), jQuery.Callbacks('once memory'), 0, 'resolved'], ['reject', 'fail', jQuery.Callbacks('once memory'), jQuery.Callbacks('once memory'), 1, 'rejected']],\n          _state = 'pending',\n          _promise = {\n        state: function state() {\n          return _state;\n        },\n        always: function always() {\n          deferred.done(arguments).fail(arguments);\n          return this;\n        },\n        'catch': function _catch(fn) {\n          return _promise.then(null, fn);\n        },\n\n        // Keep pipe for back-compat\n        pipe: function pipe() /* fnDone, fnFail, fnProgress */{\n          var fns = arguments;\n\n          return jQuery.Deferred(function (newDefer) {\n            jQuery.each(tuples, function (i, tuple) {\n\n              // Map tuples (progress, done, fail) to arguments (done, fail, progress)\n              var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];\n\n              // deferred.progress(function() { bind to newDefer or newDefer.notify })\n              // deferred.done(function() { bind to newDefer or newDefer.resolve })\n              // deferred.fail(function() { bind to newDefer or newDefer.reject })\n              deferred[tuple[1]](function () {\n                var returned = fn && fn.apply(this, arguments);\n                if (returned && isFunction(returned.promise)) {\n                  returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);\n                } else {\n                  newDefer[tuple[0] + 'With'](this, fn ? [returned] : arguments);\n                }\n              });\n            });\n            fns = null;\n          }).promise();\n        },\n        then: function then(onFulfilled, onRejected, onProgress) {\n          var maxDepth = 0;\n          function resolve(depth, deferred, handler, special) {\n            return function () {\n              var that = this,\n                  args = arguments,\n                  mightThrow = function mightThrow() {\n                var returned, then;\n\n                // Support: Promises/A+ section 2.3.3.3.3\n                // https://promisesaplus.com/#point-59\n                // Ignore double-resolution attempts\n                if (depth < maxDepth) {\n                  return;\n                }\n\n                returned = handler.apply(that, args);\n\n                // Support: Promises/A+ section 2.3.1\n                // https://promisesaplus.com/#point-48\n                if (returned === deferred.promise()) {\n                  throw new TypeError('Thenable self-resolution');\n                }\n\n                // Support: Promises/A+ sections 2.3.3.1, 3.5\n                // https://promisesaplus.com/#point-54\n                // https://promisesaplus.com/#point-75\n                // Retrieve `then` only once\n                then = returned && (\n\n                // Support: Promises/A+ section 2.3.4\n                // https://promisesaplus.com/#point-64\n                // Only check objects and functions for thenability\n                (typeof returned === 'undefined' ? 'undefined' : _typeof(returned)) === 'object' || typeof returned === 'function') && returned.then;\n\n                // Handle a returned thenable\n                if (isFunction(then)) {\n\n                  // Special processors (notify) just wait for resolution\n                  if (special) {\n                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special));\n\n                    // Normal processors (resolve) also hook into progress\n                  } else {\n\n                    // ...and disregard older resolution values\n                    maxDepth++;\n\n                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));\n                  }\n\n                  // Handle all other returned values\n                } else {\n\n                  // Only substitute handlers pass on context\n                  // and multiple values (non-spec behavior)\n                  if (handler !== Identity) {\n                    that = undefined;\n                    args = [returned];\n                  }\n\n                  // Process the value(s)\n                  // Default process is resolve\n                  (special || deferred.resolveWith)(that, args);\n                }\n              },\n\n\n              // Only normal processors (resolve) catch and reject exceptions\n              process = special ? mightThrow : function () {\n                try {\n                  mightThrow();\n                } catch (e) {\n\n                  if (jQuery.Deferred.exceptionHook) {\n                    jQuery.Deferred.exceptionHook(e, process.stackTrace);\n                  }\n\n                  // Support: Promises/A+ section 2.3.3.3.4.1\n                  // https://promisesaplus.com/#point-61\n                  // Ignore post-resolution exceptions\n                  if (depth + 1 >= maxDepth) {\n\n                    // Only substitute handlers pass on context\n                    // and multiple values (non-spec behavior)\n                    if (handler !== Thrower) {\n                      that = undefined;\n                      args = [e];\n                    }\n\n                    deferred.rejectWith(that, args);\n                  }\n                }\n              };\n\n              // Support: Promises/A+ section 2.3.3.3.1\n              // https://promisesaplus.com/#point-57\n              // Re-resolve promises immediately to dodge false rejection from\n              // subsequent errors\n              if (depth) {\n                process();\n              } else {\n\n                // Call an optional hook to record the stack, in case of exception\n                // since it's otherwise lost when execution goes async\n                if (jQuery.Deferred.getStackHook) {\n                  process.stackTrace = jQuery.Deferred.getStackHook();\n                }\n                window.setTimeout(process);\n              }\n            };\n          }\n\n          return jQuery.Deferred(function (newDefer) {\n\n            // progress_handlers.add( ... )\n            tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));\n\n            // fulfilled_handlers.add( ... )\n            tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity));\n\n            // rejected_handlers.add( ... )\n            tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));\n          }).promise();\n        },\n\n        // Get a promise for this deferred\n        // If obj is provided, the promise aspect is added to the object\n        promise: function promise(obj) {\n          return obj != null ? jQuery.extend(obj, _promise) : _promise;\n        }\n      },\n          deferred = {};\n\n      // Add list-specific methods\n      jQuery.each(tuples, function (i, tuple) {\n        var list = tuple[2],\n            stateString = tuple[5];\n\n        // promise.progress = list.add\n        // promise.done = list.add\n        // promise.fail = list.add\n        _promise[tuple[1]] = list.add;\n\n        // Handle state\n        if (stateString) {\n          list.add(function () {\n\n            // state = \"resolved\" (i.e., fulfilled)\n            // state = \"rejected\"\n            _state = stateString;\n          },\n\n          // rejected_callbacks.disable\n          // fulfilled_callbacks.disable\n          tuples[3 - i][2].disable,\n\n          // rejected_handlers.disable\n          // fulfilled_handlers.disable\n          tuples[3 - i][3].disable,\n\n          // progress_callbacks.lock\n          tuples[0][2].lock,\n\n          // progress_handlers.lock\n          tuples[0][3].lock);\n        }\n\n        // progress_handlers.fire\n        // fulfilled_handlers.fire\n        // rejected_handlers.fire\n        list.add(tuple[3].fire);\n\n        // deferred.notify = function() { deferred.notifyWith(...) }\n        // deferred.resolve = function() { deferred.resolveWith(...) }\n        // deferred.reject = function() { deferred.rejectWith(...) }\n        deferred[tuple[0]] = function () {\n          deferred[tuple[0] + 'With'](this === deferred ? undefined : this, arguments);\n          return this;\n        };\n\n        // deferred.notifyWith = list.fireWith\n        // deferred.resolveWith = list.fireWith\n        // deferred.rejectWith = list.fireWith\n        deferred[tuple[0] + 'With'] = list.fireWith;\n      });\n\n      // Make the deferred a promise\n      _promise.promise(deferred);\n\n      // Call given func if any\n      if (func) {\n        func.call(deferred, deferred);\n      }\n\n      // All done!\n      return deferred;\n    },\n\n    // Deferred helper\n    when: function when(singleValue) {\n      var\n\n      // count of uncompleted subordinates\n      remaining = arguments.length,\n\n\n      // count of unprocessed arguments\n      i = remaining,\n\n\n      // subordinate fulfillment data\n      resolveContexts = Array(i),\n          resolveValues = _slice.call(arguments),\n\n\n      // the master Deferred\n      master = jQuery.Deferred(),\n\n\n      // subordinate callback factory\n      updateFunc = function updateFunc(i) {\n        return function (value) {\n          resolveContexts[i] = this;\n          resolveValues[i] = arguments.length > 1 ? _slice.call(arguments) : value;\n          if (! --remaining) {\n            master.resolveWith(resolveContexts, resolveValues);\n          }\n        };\n      };\n\n      // Single- and empty arguments are adopted like Promise.resolve\n      if (remaining <= 1) {\n        adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining);\n\n        // Use .then() to unwrap secondary thenables (cf. gh-3000)\n        if (master.state() === 'pending' || isFunction(resolveValues[i] && resolveValues[i].then)) {\n\n          return master.then();\n        }\n      }\n\n      // Multiple arguments are aggregated like Promise.all array elements\n      while (i--) {\n        adoptValue(resolveValues[i], updateFunc(i), master.reject);\n      }\n\n      return master.promise();\n    }\n  });\n\n  // These usually indicate a programmer mistake during development,\n  // warn about them ASAP rather than swallowing them by default.\n  var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\n  jQuery.Deferred.exceptionHook = function (error, stack) {\n\n    // Support: IE 8 - 9 only\n    // Console exists when dev tools are open, which can happen at any time\n    if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {\n      window.console.warn('jQuery.Deferred exception: ' + error.message, error.stack, stack);\n    }\n  };\n\n  jQuery.readyException = function (error) {\n    window.setTimeout(function () {\n      throw error;\n    });\n  };\n\n  // The deferred used on DOM ready\n  var readyList = jQuery.Deferred();\n\n  jQuery.fn.ready = function (fn) {\n\n    readyList.then(fn)\n\n    // Wrap jQuery.readyException in a function so that the lookup\n    // happens at the time of error handling instead of callback\n    // registration.\n    .catch(function (error) {\n      jQuery.readyException(error);\n    });\n\n    return this;\n  };\n\n  jQuery.extend({\n\n    // Is the DOM ready to be used? Set to true once it occurs.\n    isReady: false,\n\n    // A counter to track how many items to wait for before\n    // the ready event fires. See #6781\n    readyWait: 1,\n\n    // Handle when the DOM is ready\n    ready: function ready(wait) {\n\n      // Abort if there are pending holds or we're already ready\n      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {\n        return;\n      }\n\n      // Remember that the DOM is ready\n      jQuery.isReady = true;\n\n      // If a normal DOM Ready event fired, decrement, and wait if need be\n      if (wait !== true && --jQuery.readyWait > 0) {\n        return;\n      }\n\n      // If there are functions bound, to execute\n      readyList.resolveWith(document, [jQuery]);\n    }\n  });\n\n  jQuery.ready.then = readyList.then;\n\n  // The ready event handler and self cleanup method\n  function completed() {\n    document.removeEventListener('DOMContentLoaded', completed);\n    window.removeEventListener('load', completed);\n    jQuery.ready();\n  }\n\n  // Catch cases where $(document).ready() is called\n  // after the browser event has already occurred.\n  // Support: IE <=9 - 10 only\n  // Older IE sometimes signals \"interactive\" too soon\n  if (document.readyState === 'complete' || document.readyState !== 'loading' && !document.documentElement.doScroll) {\n\n    // Handle it asynchronously to allow scripts the opportunity to delay ready\n    window.setTimeout(jQuery.ready);\n  } else {\n\n    // Use the handy event callback\n    document.addEventListener('DOMContentLoaded', completed);\n\n    // A fallback to window.onload, that will always work\n    window.addEventListener('load', completed);\n  }\n\n  // Multifunctional method to get and set values of a collection\n  // The value/s can optionally be executed if it's a function\n  var access = function access(elems, fn, key, value, chainable, emptyGet, raw) {\n    var i = 0,\n        len = elems.length,\n        bulk = key == null;\n\n    // Sets many values\n    if (toType(key) === 'object') {\n      chainable = true;\n      for (i in key) {\n        access(elems, fn, i, key[i], true, emptyGet, raw);\n      }\n\n      // Sets one value\n    } else if (value !== undefined) {\n      chainable = true;\n\n      if (!isFunction(value)) {\n        raw = true;\n      }\n\n      if (bulk) {\n\n        // Bulk operations run against the entire set\n        if (raw) {\n          fn.call(elems, value);\n          fn = null;\n\n          // ...except when executing function values\n        } else {\n          bulk = fn;\n          fn = function fn(elem, key, value) {\n            return bulk.call(jQuery(elem), value);\n          };\n        }\n      }\n\n      if (fn) {\n        for (; i < len; i++) {\n          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));\n        }\n      }\n    }\n\n    if (chainable) {\n      return elems;\n    }\n\n    // Gets\n    if (bulk) {\n      return fn.call(elems);\n    }\n\n    return len ? fn(elems[0], key) : emptyGet;\n  };\n\n  // Matches dashed string for camelizing\n  var rmsPrefix = /^-ms-/,\n      rdashAlpha = /-([a-z])/g;\n\n  // Used by camelCase as callback to replace()\n  function fcamelCase(all, letter) {\n    return letter.toUpperCase();\n  }\n\n  // Convert dashed to camelCase; used by the css and data modules\n  // Support: IE <=9 - 11, Edge 12 - 15\n  // Microsoft forgot to hump their vendor prefix (#9572)\n  function camelCase(string) {\n    return string.replace(rmsPrefix, 'ms-').replace(rdashAlpha, fcamelCase);\n  }\n  var acceptData = function acceptData(owner) {\n\n    // Accepts only:\n    //  - Node\n    //    - Node.ELEMENT_NODE\n    //    - Node.DOCUMENT_NODE\n    //  - Object\n    //    - Any\n    return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;\n  };\n\n  function Data() {\n    this.expando = jQuery.expando + Data.uid++;\n  }\n\n  Data.uid = 1;\n\n  Data.prototype = {\n\n    cache: function cache(owner) {\n\n      // Check if the owner object already has a cache\n      var value = owner[this.expando];\n\n      // If not, create one\n      if (!value) {\n        value = {};\n\n        // We can accept data for non-element nodes in modern browsers,\n        // but we should not, see #8335.\n        // Always return an empty object.\n        if (acceptData(owner)) {\n\n          // If it is a node unlikely to be stringify-ed or looped over\n          // use plain assignment\n          if (owner.nodeType) {\n            owner[this.expando] = value;\n\n            // Otherwise secure it in a non-enumerable property\n            // configurable must be true to allow the property to be\n            // deleted when data is removed\n          } else {\n            Object.defineProperty(owner, this.expando, {\n              value: value,\n              configurable: true\n            });\n          }\n        }\n      }\n\n      return value;\n    },\n    set: function set(owner, data, value) {\n      var prop,\n          cache = this.cache(owner);\n\n      // Handle: [ owner, key, value ] args\n      // Always use camelCase key (gh-2257)\n      if (typeof data === 'string') {\n        cache[camelCase(data)] = value;\n\n        // Handle: [ owner, { properties } ] args\n      } else {\n\n        // Copy the properties one-by-one to the cache object\n        for (prop in data) {\n          cache[camelCase(prop)] = data[prop];\n        }\n      }\n      return cache;\n    },\n    get: function get(owner, key) {\n      return key === undefined ? this.cache(owner) :\n\n      // Always use camelCase key (gh-2257)\n      owner[this.expando] && owner[this.expando][camelCase(key)];\n    },\n    access: function access(owner, key, value) {\n\n      // In cases where either:\n      //\n      //   1. No key was specified\n      //   2. A string key was specified, but no value provided\n      //\n      // Take the \"read\" path and allow the get method to determine\n      // which value to return, respectively either:\n      //\n      //   1. The entire cache object\n      //   2. The data stored at the key\n      //\n      if (key === undefined || key && typeof key === 'string' && value === undefined) {\n\n        return this.get(owner, key);\n      }\n\n      // When the key is not a string, or both a key and value\n      // are specified, set or extend (existing objects) with either:\n      //\n      //   1. An object of properties\n      //   2. A key and value\n      //\n      this.set(owner, key, value);\n\n      // Since the \"set\" path can have two possible entry points\n      // return the expected data based on which path was taken[*]\n      return value !== undefined ? value : key;\n    },\n    remove: function remove(owner, key) {\n      var i,\n          cache = owner[this.expando];\n\n      if (cache === undefined) {\n        return;\n      }\n\n      if (key !== undefined) {\n\n        // Support array or space separated string of keys\n        if (Array.isArray(key)) {\n\n          // If key is an array of keys...\n          // We always set camelCase keys, so remove that.\n          key = key.map(camelCase);\n        } else {\n          key = camelCase(key);\n\n          // If a key with the spaces exists, use it.\n          // Otherwise, create an array by matching non-whitespace\n          key = key in cache ? [key] : key.match(rnothtmlwhite) || [];\n        }\n\n        i = key.length;\n\n        while (i--) {\n          delete cache[key[i]];\n        }\n      }\n\n      // Remove the expando if there's no more data\n      if (key === undefined || jQuery.isEmptyObject(cache)) {\n\n        // Support: Chrome <=35 - 45\n        // Webkit & Blink performance suffers when deleting properties\n        // from DOM nodes, so set to undefined instead\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n        if (owner.nodeType) {\n          owner[this.expando] = undefined;\n        } else {\n          delete owner[this.expando];\n        }\n      }\n    },\n    hasData: function hasData(owner) {\n      var cache = owner[this.expando];\n      return cache !== undefined && !jQuery.isEmptyObject(cache);\n    }\n  };\n  var dataPriv = new Data();\n\n  var dataUser = new Data();\n\n  //\tImplementation Summary\n  //\n  //\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n  //\t2. Improve the module's maintainability by reducing the storage\n  //\t\tpaths to a single mechanism.\n  //\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n  //\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n  //\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n  //\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\n  var rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n      rmultiDash = /[A-Z]/g;\n\n  function getData(data) {\n    if (data === 'true') {\n      return true;\n    }\n\n    if (data === 'false') {\n      return false;\n    }\n\n    if (data === 'null') {\n      return null;\n    }\n\n    // Only convert to a number if it doesn't change the string\n    if (data === +data + '') {\n      return +data;\n    }\n\n    if (rbrace.test(data)) {\n      return JSON.parse(data);\n    }\n\n    return data;\n  }\n\n  function dataAttr(elem, key, data) {\n    var name;\n\n    // If nothing was found internally, try to fetch any\n    // data from the HTML5 data-* attribute\n    if (data === undefined && elem.nodeType === 1) {\n      name = 'data-' + key.replace(rmultiDash, '-$&').toLowerCase();\n      data = elem.getAttribute(name);\n\n      if (typeof data === 'string') {\n        try {\n          data = getData(data);\n        } catch (e) {}\n\n        // Make sure we set the data so it isn't changed later\n        dataUser.set(elem, key, data);\n      } else {\n        data = undefined;\n      }\n    }\n    return data;\n  }\n\n  jQuery.extend({\n    hasData: function hasData(elem) {\n      return dataUser.hasData(elem) || dataPriv.hasData(elem);\n    },\n\n    data: function data(elem, name, _data) {\n      return dataUser.access(elem, name, _data);\n    },\n\n    removeData: function removeData(elem, name) {\n      dataUser.remove(elem, name);\n    },\n\n    // TODO: Now that all calls to _data and _removeData have been replaced\n    // with direct calls to dataPriv methods, these can be deprecated.\n    _data: function _data(elem, name, data) {\n      return dataPriv.access(elem, name, data);\n    },\n\n    _removeData: function _removeData(elem, name) {\n      dataPriv.remove(elem, name);\n    }\n  });\n\n  jQuery.fn.extend({\n    data: function data(key, value) {\n      var i,\n          name,\n          data,\n          elem = this[0],\n          attrs = elem && elem.attributes;\n\n      // Gets all values\n      if (key === undefined) {\n        if (this.length) {\n          data = dataUser.get(elem);\n\n          if (elem.nodeType === 1 && !dataPriv.get(elem, 'hasDataAttrs')) {\n            i = attrs.length;\n            while (i--) {\n\n              // Support: IE 11 only\n              // The attrs elements can be null (#14894)\n              if (attrs[i]) {\n                name = attrs[i].name;\n                if (name.indexOf('data-') === 0) {\n                  name = camelCase(name.slice(5));\n                  dataAttr(elem, name, data[name]);\n                }\n              }\n            }\n            dataPriv.set(elem, 'hasDataAttrs', true);\n          }\n        }\n\n        return data;\n      }\n\n      // Sets multiple values\n      if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {\n        return this.each(function () {\n          dataUser.set(this, key);\n        });\n      }\n\n      return access(this, function (value) {\n        var data;\n\n        // The calling jQuery object (element matches) is not empty\n        // (and therefore has an element appears at this[ 0 ]) and the\n        // `value` parameter was not undefined. An empty jQuery object\n        // will result in `undefined` for elem = this[ 0 ] which will\n        // throw an exception if an attempt to read a data cache is made.\n        if (elem && value === undefined) {\n\n          // Attempt to get data from the cache\n          // The key will always be camelCased in Data\n          data = dataUser.get(elem, key);\n          if (data !== undefined) {\n            return data;\n          }\n\n          // Attempt to \"discover\" the data in\n          // HTML5 custom data-* attrs\n          data = dataAttr(elem, key);\n          if (data !== undefined) {\n            return data;\n          }\n\n          // We tried really hard, but the data doesn't exist.\n          return;\n        }\n\n        // Set the data...\n        this.each(function () {\n\n          // We always store the camelCased key\n          dataUser.set(this, key, value);\n        });\n      }, null, value, arguments.length > 1, null, true);\n    },\n\n    removeData: function removeData(key) {\n      return this.each(function () {\n        dataUser.remove(this, key);\n      });\n    }\n  });\n\n  jQuery.extend({\n    queue: function queue(elem, type, data) {\n      var queue;\n\n      if (elem) {\n        type = (type || 'fx') + 'queue';\n        queue = dataPriv.get(elem, type);\n\n        // Speed up dequeue by getting out quickly if this is just a lookup\n        if (data) {\n          if (!queue || Array.isArray(data)) {\n            queue = dataPriv.access(elem, type, jQuery.makeArray(data));\n          } else {\n            queue.push(data);\n          }\n        }\n        return queue || [];\n      }\n    },\n\n    dequeue: function dequeue(elem, type) {\n      type = type || 'fx';\n\n      var queue = jQuery.queue(elem, type),\n          startLength = queue.length,\n          fn = queue.shift(),\n          hooks = jQuery._queueHooks(elem, type),\n          next = function next() {\n        jQuery.dequeue(elem, type);\n      };\n\n      // If the fx queue is dequeued, always remove the progress sentinel\n      if (fn === 'inprogress') {\n        fn = queue.shift();\n        startLength--;\n      }\n\n      if (fn) {\n\n        // Add a progress sentinel to prevent the fx queue from being\n        // automatically dequeued\n        if (type === 'fx') {\n          queue.unshift('inprogress');\n        }\n\n        // Clear up the last queue stop function\n        delete hooks.stop;\n        fn.call(elem, next, hooks);\n      }\n\n      if (!startLength && hooks) {\n        hooks.empty.fire();\n      }\n    },\n\n    // Not public - generate a queueHooks object, or return the current one\n    _queueHooks: function _queueHooks(elem, type) {\n      var key = type + 'queueHooks';\n      return dataPriv.get(elem, key) || dataPriv.access(elem, key, {\n        empty: jQuery.Callbacks('once memory').add(function () {\n          dataPriv.remove(elem, [type + 'queue', key]);\n        })\n      });\n    }\n  });\n\n  jQuery.fn.extend({\n    queue: function queue(type, data) {\n      var setter = 2;\n\n      if (typeof type !== 'string') {\n        data = type;\n        type = 'fx';\n        setter--;\n      }\n\n      if (arguments.length < setter) {\n        return jQuery.queue(this[0], type);\n      }\n\n      return data === undefined ? this : this.each(function () {\n        var queue = jQuery.queue(this, type, data);\n\n        // Ensure a hooks for this queue\n        jQuery._queueHooks(this, type);\n\n        if (type === 'fx' && queue[0] !== 'inprogress') {\n          jQuery.dequeue(this, type);\n        }\n      });\n    },\n    dequeue: function dequeue(type) {\n      return this.each(function () {\n        jQuery.dequeue(this, type);\n      });\n    },\n    clearQueue: function clearQueue(type) {\n      return this.queue(type || 'fx', []);\n    },\n\n    // Get a promise resolved when queues of a certain type\n    // are emptied (fx is the type by default)\n    promise: function promise(type, obj) {\n      var tmp,\n          count = 1,\n          defer = jQuery.Deferred(),\n          elements = this,\n          i = this.length,\n          resolve = function resolve() {\n        if (! --count) {\n          defer.resolveWith(elements, [elements]);\n        }\n      };\n\n      if (typeof type !== 'string') {\n        obj = type;\n        type = undefined;\n      }\n      type = type || 'fx';\n\n      while (i--) {\n        tmp = dataPriv.get(elements[i], type + 'queueHooks');\n        if (tmp && tmp.empty) {\n          count++;\n          tmp.empty.add(resolve);\n        }\n      }\n      resolve();\n      return defer.promise(obj);\n    }\n  });\n  var pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\n\n  var rcssNum = new RegExp('^(?:([+-])=|)(' + pnum + ')([a-z%]*)$', 'i');\n\n  var cssExpand = ['Top', 'Right', 'Bottom', 'Left'];\n\n  var isHiddenWithinTree = function isHiddenWithinTree(elem, el) {\n\n    // isHiddenWithinTree might be called from jQuery#filter function;\n    // in that case, element will be second argument\n    elem = el || elem;\n\n    // Inline style trumps all\n    return elem.style.display === 'none' || elem.style.display === '' &&\n\n    // Otherwise, check computed style\n    // Support: Firefox <=43 - 45\n    // Disconnected elements can have computed display: none, so first confirm that elem is\n    // in the document.\n    jQuery.contains(elem.ownerDocument, elem) && jQuery.css(elem, 'display') === 'none';\n  };\n\n  var swap = function swap(elem, options, callback, args) {\n    var ret,\n        name,\n        old = {};\n\n    // Remember the old values, and insert the new ones\n    for (name in options) {\n      old[name] = elem.style[name];\n      elem.style[name] = options[name];\n    }\n\n    ret = callback.apply(elem, args || []);\n\n    // Revert the old values\n    for (name in options) {\n      elem.style[name] = old[name];\n    }\n\n    return ret;\n  };\n\n  function adjustCSS(elem, prop, valueParts, tween) {\n    var adjusted,\n        scale,\n        maxIterations = 20,\n        currentValue = tween ? function () {\n      return tween.cur();\n    } : function () {\n      return jQuery.css(elem, prop, '');\n    },\n        initial = currentValue(),\n        unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? '' : 'px'),\n\n\n    // Starting value computation is required for potential unit mismatches\n    initialInUnit = (jQuery.cssNumber[prop] || unit !== 'px' && +initial) && rcssNum.exec(jQuery.css(elem, prop));\n\n    if (initialInUnit && initialInUnit[3] !== unit) {\n\n      // Support: Firefox <=54\n      // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\n      initial = initial / 2;\n\n      // Trust units reported by jQuery.css\n      unit = unit || initialInUnit[3];\n\n      // Iteratively approximate from a nonzero starting point\n      initialInUnit = +initial || 1;\n\n      while (maxIterations--) {\n\n        // Evaluate and update our best guess (doubling guesses that zero out).\n        // Finish if the scale equals or crosses 1 (making the old*new product non-positive).\n        jQuery.style(elem, prop, initialInUnit + unit);\n        if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {\n          maxIterations = 0;\n        }\n        initialInUnit = initialInUnit / scale;\n      }\n\n      initialInUnit = initialInUnit * 2;\n      jQuery.style(elem, prop, initialInUnit + unit);\n\n      // Make sure we update the tween properties later on\n      valueParts = valueParts || [];\n    }\n\n    if (valueParts) {\n      initialInUnit = +initialInUnit || +initial || 0;\n\n      // Apply relative offset (+=/-=) if specified\n      adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];\n      if (tween) {\n        tween.unit = unit;\n        tween.start = initialInUnit;\n        tween.end = adjusted;\n      }\n    }\n    return adjusted;\n  }\n\n  var defaultDisplayMap = {};\n\n  function getDefaultDisplay(elem) {\n    var temp,\n        doc = elem.ownerDocument,\n        nodeName = elem.nodeName,\n        display = defaultDisplayMap[nodeName];\n\n    if (display) {\n      return display;\n    }\n\n    temp = doc.body.appendChild(doc.createElement(nodeName));\n    display = jQuery.css(temp, 'display');\n\n    temp.parentNode.removeChild(temp);\n\n    if (display === 'none') {\n      display = 'block';\n    }\n    defaultDisplayMap[nodeName] = display;\n\n    return display;\n  }\n\n  function showHide(elements, show) {\n    var display,\n        elem,\n        values = [],\n        index = 0,\n        length = elements.length;\n\n    // Determine new display value for elements that need to change\n    for (; index < length; index++) {\n      elem = elements[index];\n      if (!elem.style) {\n        continue;\n      }\n\n      display = elem.style.display;\n      if (show) {\n\n        // Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n        // check is required in this first loop unless we have a nonempty display value (either\n        // inline or about-to-be-restored)\n        if (display === 'none') {\n          values[index] = dataPriv.get(elem, 'display') || null;\n          if (!values[index]) {\n            elem.style.display = '';\n          }\n        }\n        if (elem.style.display === '' && isHiddenWithinTree(elem)) {\n          values[index] = getDefaultDisplay(elem);\n        }\n      } else {\n        if (display !== 'none') {\n          values[index] = 'none';\n\n          // Remember what we're overwriting\n          dataPriv.set(elem, 'display', display);\n        }\n      }\n    }\n\n    // Set the display of the elements in a second loop to avoid constant reflow\n    for (index = 0; index < length; index++) {\n      if (values[index] != null) {\n        elements[index].style.display = values[index];\n      }\n    }\n\n    return elements;\n  }\n\n  jQuery.fn.extend({\n    show: function show() {\n      return showHide(this, true);\n    },\n    hide: function hide() {\n      return showHide(this);\n    },\n    toggle: function toggle(state) {\n      if (typeof state === 'boolean') {\n        return state ? this.show() : this.hide();\n      }\n\n      return this.each(function () {\n        if (isHiddenWithinTree(this)) {\n          jQuery(this).show();\n        } else {\n          jQuery(this).hide();\n        }\n      });\n    }\n  });\n  var rcheckableType = /^(?:checkbox|radio)$/i;\n\n  var rtagName = /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i;\n\n  var rscriptType = /^$|^module$|\\/(?:java|ecma)script/i;\n\n  // We have to close these tags to support XHTML (#13200)\n  var wrapMap = {\n\n    // Support: IE <=9 only\n    option: [1, \"<select multiple='multiple'>\", '</select>'],\n\n    // XHTML parsers do not magically insert elements in the\n    // same way that tag soup parsers do. So we cannot shorten\n    // this by omitting <tbody> or other required elements.\n    thead: [1, '<table>', '</table>'],\n    col: [2, '<table><colgroup>', '</colgroup></table>'],\n    tr: [2, '<table><tbody>', '</tbody></table>'],\n    td: [3, '<table><tbody><tr>', '</tr></tbody></table>'],\n\n    _default: [0, '', '']\n  };\n\n  // Support: IE <=9 only\n  wrapMap.optgroup = wrapMap.option;\n\n  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n  wrapMap.th = wrapMap.td;\n\n  function getAll(context, tag) {\n\n    // Support: IE <=9 - 11 only\n    // Use typeof to avoid zero-argument method invocation on host objects (#15151)\n    var ret;\n\n    if (typeof context.getElementsByTagName !== 'undefined') {\n      ret = context.getElementsByTagName(tag || '*');\n    } else if (typeof context.querySelectorAll !== 'undefined') {\n      ret = context.querySelectorAll(tag || '*');\n    } else {\n      ret = [];\n    }\n\n    if (tag === undefined || tag && nodeName(context, tag)) {\n      return jQuery.merge([context], ret);\n    }\n\n    return ret;\n  }\n\n  // Mark scripts as having already been evaluated\n  function setGlobalEval(elems, refElements) {\n    var i = 0,\n        l = elems.length;\n\n    for (; i < l; i++) {\n      dataPriv.set(elems[i], 'globalEval', !refElements || dataPriv.get(refElements[i], 'globalEval'));\n    }\n  }\n\n  var rhtml = /<|&#?\\w+;/;\n\n  function buildFragment(elems, context, scripts, selection, ignored) {\n    var elem,\n        tmp,\n        tag,\n        wrap,\n        contains,\n        j,\n        fragment = context.createDocumentFragment(),\n        nodes = [],\n        i = 0,\n        l = elems.length;\n\n    for (; i < l; i++) {\n      elem = elems[i];\n\n      if (elem || elem === 0) {\n\n        // Add nodes directly\n        if (toType(elem) === 'object') {\n\n          // Support: Android <=4.0 only, PhantomJS 1 only\n          // push.apply(_, arraylike) throws on ancient WebKit\n          jQuery.merge(nodes, elem.nodeType ? [elem] : elem);\n\n          // Convert non-html into a text node\n        } else if (!rhtml.test(elem)) {\n          nodes.push(context.createTextNode(elem));\n\n          // Convert html into DOM nodes\n        } else {\n          tmp = tmp || fragment.appendChild(context.createElement('div'));\n\n          // Deserialize a standard representation\n          tag = (rtagName.exec(elem) || ['', ''])[1].toLowerCase();\n          wrap = wrapMap[tag] || wrapMap._default;\n          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];\n\n          // Descend through wrappers to the right content\n          j = wrap[0];\n          while (j--) {\n            tmp = tmp.lastChild;\n          }\n\n          // Support: Android <=4.0 only, PhantomJS 1 only\n          // push.apply(_, arraylike) throws on ancient WebKit\n          jQuery.merge(nodes, tmp.childNodes);\n\n          // Remember the top-level container\n          tmp = fragment.firstChild;\n\n          // Ensure the created nodes are orphaned (#12392)\n          tmp.textContent = '';\n        }\n      }\n    }\n\n    // Remove wrapper from fragment\n    fragment.textContent = '';\n\n    i = 0;\n    while (elem = nodes[i++]) {\n\n      // Skip elements already in the context collection (trac-4087)\n      if (selection && jQuery.inArray(elem, selection) > -1) {\n        if (ignored) {\n          ignored.push(elem);\n        }\n        continue;\n      }\n\n      contains = jQuery.contains(elem.ownerDocument, elem);\n\n      // Append to fragment\n      tmp = getAll(fragment.appendChild(elem), 'script');\n\n      // Preserve script evaluation history\n      if (contains) {\n        setGlobalEval(tmp);\n      }\n\n      // Capture executables\n      if (scripts) {\n        j = 0;\n        while (elem = tmp[j++]) {\n          if (rscriptType.test(elem.type || '')) {\n            scripts.push(elem);\n          }\n        }\n      }\n    }\n\n    return fragment;\n  }\n\n  (function () {\n    var fragment = document.createDocumentFragment(),\n        div = fragment.appendChild(document.createElement('div')),\n        input = document.createElement('input');\n\n    // Support: Android 4.0 - 4.3 only\n    // Check state lost if the name is set (#11217)\n    // Support: Windows Web Apps (WWA)\n    // `name` and `type` must use .setAttribute for WWA (#14901)\n    input.setAttribute('type', 'radio');\n    input.setAttribute('checked', 'checked');\n    input.setAttribute('name', 't');\n\n    div.appendChild(input);\n\n    // Support: Android <=4.1 only\n    // Older WebKit doesn't clone checked state correctly in fragments\n    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;\n\n    // Support: IE <=11 only\n    // Make sure textarea (and checkbox) defaultValue is properly cloned\n    div.innerHTML = '<textarea>x</textarea>';\n    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;\n  })();\n  var documentElement = document.documentElement;\n\n  var rkeyEvent = /^key/,\n      rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n      rtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\n  function returnTrue() {\n    return true;\n  }\n\n  function returnFalse() {\n    return false;\n  }\n\n  // Support: IE <=9 only\n  // See #13393 for more info\n  function safeActiveElement() {\n    try {\n      return document.activeElement;\n    } catch (err) {}\n  }\n\n  function _on(elem, types, selector, data, fn, one) {\n    var origFn, type;\n\n    // Types can be a map of types/handlers\n    if ((typeof types === 'undefined' ? 'undefined' : _typeof(types)) === 'object') {\n\n      // ( types-Object, selector, data )\n      if (typeof selector !== 'string') {\n\n        // ( types-Object, data )\n        data = data || selector;\n        selector = undefined;\n      }\n      for (type in types) {\n        _on(elem, type, selector, data, types[type], one);\n      }\n      return elem;\n    }\n\n    if (data == null && fn == null) {\n\n      // ( types, fn )\n      fn = selector;\n      data = selector = undefined;\n    } else if (fn == null) {\n      if (typeof selector === 'string') {\n\n        // ( types, selector, fn )\n        fn = data;\n        data = undefined;\n      } else {\n\n        // ( types, data, fn )\n        fn = data;\n        data = selector;\n        selector = undefined;\n      }\n    }\n    if (fn === false) {\n      fn = returnFalse;\n    } else if (!fn) {\n      return elem;\n    }\n\n    if (one === 1) {\n      origFn = fn;\n      fn = function fn(event) {\n\n        // Can use an empty set, since event contains the info\n        jQuery().off(event);\n        return origFn.apply(this, arguments);\n      };\n\n      // Use same guid so caller can remove using origFn\n      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);\n    }\n    return elem.each(function () {\n      jQuery.event.add(this, types, fn, data, selector);\n    });\n  }\n\n  /*\n  * Helper functions for managing events -- not part of the public interface.\n  * Props to Dean Edwards' addEvent library for many of the ideas.\n  */\n  jQuery.event = {\n\n    global: {},\n\n    add: function add(elem, types, handler, data, selector) {\n\n      var handleObjIn,\n          eventHandle,\n          tmp,\n          events,\n          t,\n          handleObj,\n          special,\n          handlers,\n          type,\n          namespaces,\n          origType,\n          elemData = dataPriv.get(elem);\n\n      // Don't attach events to noData or text/comment nodes (but allow plain objects)\n      if (!elemData) {\n        return;\n      }\n\n      // Caller can pass in an object of custom data in lieu of the handler\n      if (handler.handler) {\n        handleObjIn = handler;\n        handler = handleObjIn.handler;\n        selector = handleObjIn.selector;\n      }\n\n      // Ensure that invalid selectors throw exceptions at attach time\n      // Evaluate against documentElement in case elem is a non-element node (e.g., document)\n      if (selector) {\n        jQuery.find.matchesSelector(documentElement, selector);\n      }\n\n      // Make sure that the handler has a unique ID, used to find/remove it later\n      if (!handler.guid) {\n        handler.guid = jQuery.guid++;\n      }\n\n      // Init the element's event structure and main handler, if this is the first\n      if (!(events = elemData.events)) {\n        events = elemData.events = {};\n      }\n      if (!(eventHandle = elemData.handle)) {\n        eventHandle = elemData.handle = function (e) {\n\n          // Discard the second event of a jQuery.event.trigger() and\n          // when an event is called after a page has unloaded\n          return typeof jQuery !== 'undefined' && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;\n        };\n      }\n\n      // Handle multiple events separated by a space\n      types = (types || '').match(rnothtmlwhite) || [''];\n      t = types.length;\n      while (t--) {\n        tmp = rtypenamespace.exec(types[t]) || [];\n        type = origType = tmp[1];\n        namespaces = (tmp[2] || '').split('.').sort();\n\n        // There *must* be a type, no attaching namespace-only handlers\n        if (!type) {\n          continue;\n        }\n\n        // If event changes its type, use the special event handlers for the changed type\n        special = jQuery.event.special[type] || {};\n\n        // If selector defined, determine special event api type, otherwise given type\n        type = (selector ? special.delegateType : special.bindType) || type;\n\n        // Update special based on newly reset type\n        special = jQuery.event.special[type] || {};\n\n        // handleObj is passed to all event handlers\n        handleObj = jQuery.extend({\n          type: type,\n          origType: origType,\n          data: data,\n          handler: handler,\n          guid: handler.guid,\n          selector: selector,\n          needsContext: selector && jQuery.expr.match.needsContext.test(selector),\n          namespace: namespaces.join('.')\n        }, handleObjIn);\n\n        // Init the event handler queue if we're the first\n        if (!(handlers = events[type])) {\n          handlers = events[type] = [];\n          handlers.delegateCount = 0;\n\n          // Only use addEventListener if the special events handler returns false\n          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {\n\n            if (elem.addEventListener) {\n              elem.addEventListener(type, eventHandle);\n            }\n          }\n        }\n\n        if (special.add) {\n          special.add.call(elem, handleObj);\n\n          if (!handleObj.handler.guid) {\n            handleObj.handler.guid = handler.guid;\n          }\n        }\n\n        // Add to the element's handler list, delegates in front\n        if (selector) {\n          handlers.splice(handlers.delegateCount++, 0, handleObj);\n        } else {\n          handlers.push(handleObj);\n        }\n\n        // Keep track of which events have ever been used, for event optimization\n        jQuery.event.global[type] = true;\n      }\n    },\n\n    // Detach an event or set of events from an element\n    remove: function remove(elem, types, handler, selector, mappedTypes) {\n\n      var j,\n          origCount,\n          tmp,\n          events,\n          t,\n          handleObj,\n          special,\n          handlers,\n          type,\n          namespaces,\n          origType,\n          elemData = dataPriv.hasData(elem) && dataPriv.get(elem);\n\n      if (!elemData || !(events = elemData.events)) {\n        return;\n      }\n\n      // Once for each type.namespace in types; type may be omitted\n      types = (types || '').match(rnothtmlwhite) || [''];\n      t = types.length;\n      while (t--) {\n        tmp = rtypenamespace.exec(types[t]) || [];\n        type = origType = tmp[1];\n        namespaces = (tmp[2] || '').split('.').sort();\n\n        // Unbind all events (on this namespace, if provided) for the element\n        if (!type) {\n          for (type in events) {\n            jQuery.event.remove(elem, type + types[t], handler, selector, true);\n          }\n          continue;\n        }\n\n        special = jQuery.event.special[type] || {};\n        type = (selector ? special.delegateType : special.bindType) || type;\n        handlers = events[type] || [];\n        tmp = tmp[2] && new RegExp('(^|\\\\.)' + namespaces.join('\\\\.(?:.*\\\\.|)') + '(\\\\.|$)');\n\n        // Remove matching events\n        origCount = j = handlers.length;\n        while (j--) {\n          handleObj = handlers[j];\n\n          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === '**' && handleObj.selector)) {\n            handlers.splice(j, 1);\n\n            if (handleObj.selector) {\n              handlers.delegateCount--;\n            }\n            if (special.remove) {\n              special.remove.call(elem, handleObj);\n            }\n          }\n        }\n\n        // Remove generic event handler if we removed something and no more handlers exist\n        // (avoids potential for endless recursion during removal of special event handlers)\n        if (origCount && !handlers.length) {\n          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {\n\n            jQuery.removeEvent(elem, type, elemData.handle);\n          }\n\n          delete events[type];\n        }\n      }\n\n      // Remove data and the expando if it's no longer used\n      if (jQuery.isEmptyObject(events)) {\n        dataPriv.remove(elem, 'handle events');\n      }\n    },\n\n    dispatch: function dispatch(nativeEvent) {\n\n      // Make a writable jQuery.Event from the native event object\n      var event = jQuery.event.fix(nativeEvent);\n\n      var i,\n          j,\n          ret,\n          matched,\n          handleObj,\n          handlerQueue,\n          args = new Array(arguments.length),\n          handlers = (dataPriv.get(this, 'events') || {})[event.type] || [],\n          special = jQuery.event.special[event.type] || {};\n\n      // Use the fix-ed jQuery.Event rather than the (read-only) native event\n      args[0] = event;\n\n      for (i = 1; i < arguments.length; i++) {\n        args[i] = arguments[i];\n      }\n\n      event.delegateTarget = this;\n\n      // Call the preDispatch hook for the mapped type, and let it bail if desired\n      if (special.preDispatch && special.preDispatch.call(this, event) === false) {\n        return;\n      }\n\n      // Determine handlers\n      handlerQueue = jQuery.event.handlers.call(this, event, handlers);\n\n      // Run delegates first; they may want to stop propagation beneath us\n      i = 0;\n      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {\n        event.currentTarget = matched.elem;\n\n        j = 0;\n        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {\n\n          // Triggered event must either 1) have no namespace, or 2) have namespace(s)\n          // a subset or equal to those in the bound event (both can have no namespace).\n          if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {\n\n            event.handleObj = handleObj;\n            event.data = handleObj.data;\n\n            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);\n\n            if (ret !== undefined) {\n              if ((event.result = ret) === false) {\n                event.preventDefault();\n                event.stopPropagation();\n              }\n            }\n          }\n        }\n      }\n\n      // Call the postDispatch hook for the mapped type\n      if (special.postDispatch) {\n        special.postDispatch.call(this, event);\n      }\n\n      return event.result;\n    },\n\n    handlers: function handlers(event, _handlers) {\n      var i,\n          handleObj,\n          sel,\n          matchedHandlers,\n          matchedSelectors,\n          handlerQueue = [],\n          delegateCount = _handlers.delegateCount,\n          cur = event.target;\n\n      // Find delegate handlers\n      if (delegateCount &&\n\n      // Support: IE <=9\n      // Black-hole SVG <use> instance trees (trac-13180)\n      cur.nodeType &&\n\n      // Support: Firefox <=42\n      // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n      // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n      // Support: IE 11 only\n      // ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n      !(event.type === 'click' && event.button >= 1)) {\n\n        for (; cur !== this; cur = cur.parentNode || this) {\n\n          // Don't check non-elements (#13208)\n          // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n          if (cur.nodeType === 1 && !(event.type === 'click' && cur.disabled === true)) {\n            matchedHandlers = [];\n            matchedSelectors = {};\n            for (i = 0; i < delegateCount; i++) {\n              handleObj = _handlers[i];\n\n              // Don't conflict with Object.prototype properties (#13203)\n              sel = handleObj.selector + ' ';\n\n              if (matchedSelectors[sel] === undefined) {\n                matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;\n              }\n              if (matchedSelectors[sel]) {\n                matchedHandlers.push(handleObj);\n              }\n            }\n            if (matchedHandlers.length) {\n              handlerQueue.push({ elem: cur, handlers: matchedHandlers });\n            }\n          }\n        }\n      }\n\n      // Add the remaining (directly-bound) handlers\n      cur = this;\n      if (delegateCount < _handlers.length) {\n        handlerQueue.push({ elem: cur, handlers: _handlers.slice(delegateCount) });\n      }\n\n      return handlerQueue;\n    },\n\n    addProp: function addProp(name, hook) {\n      Object.defineProperty(jQuery.Event.prototype, name, {\n        enumerable: true,\n        configurable: true,\n\n        get: isFunction(hook) ? function () {\n          if (this.originalEvent) {\n            return hook(this.originalEvent);\n          }\n        } : function () {\n          if (this.originalEvent) {\n            return this.originalEvent[name];\n          }\n        },\n\n        set: function set(value) {\n          Object.defineProperty(this, name, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: value\n          });\n        }\n      });\n    },\n\n    fix: function fix(originalEvent) {\n      return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);\n    },\n\n    special: {\n      load: {\n\n        // Prevent triggered image.load events from bubbling to window.load\n        noBubble: true\n      },\n      focus: {\n\n        // Fire native event if possible so blur/focus sequence is correct\n        trigger: function trigger() {\n          if (this !== safeActiveElement() && this.focus) {\n            this.focus();\n            return false;\n          }\n        },\n        delegateType: 'focusin'\n      },\n      blur: {\n        trigger: function trigger() {\n          if (this === safeActiveElement() && this.blur) {\n            this.blur();\n            return false;\n          }\n        },\n        delegateType: 'focusout'\n      },\n      click: {\n\n        // For checkbox, fire native event so checked state will be right\n        trigger: function trigger() {\n          if (this.type === 'checkbox' && this.click && nodeName(this, 'input')) {\n            this.click();\n            return false;\n          }\n        },\n\n        // For cross-browser consistency, don't fire native .click() on links\n        _default: function _default(event) {\n          return nodeName(event.target, 'a');\n        }\n      },\n\n      beforeunload: {\n        postDispatch: function postDispatch(event) {\n\n          // Support: Firefox 20+\n          // Firefox doesn't alert if the returnValue field is not set.\n          if (event.result !== undefined && event.originalEvent) {\n            event.originalEvent.returnValue = event.result;\n          }\n        }\n      }\n    }\n  };\n\n  jQuery.removeEvent = function (elem, type, handle) {\n\n    // This \"if\" is needed for plain objects\n    if (elem.removeEventListener) {\n      elem.removeEventListener(type, handle);\n    }\n  };\n\n  jQuery.Event = function (src, props) {\n\n    // Allow instantiation without the 'new' keyword\n    if (!(this instanceof jQuery.Event)) {\n      return new jQuery.Event(src, props);\n    }\n\n    // Event object\n    if (src && src.type) {\n      this.originalEvent = src;\n      this.type = src.type;\n\n      // Events bubbling up the document may have been marked as prevented\n      // by a handler lower down the tree; reflect the correct value.\n      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined &&\n\n      // Support: Android <=2.3 only\n      src.returnValue === false ? returnTrue : returnFalse;\n\n      // Create target properties\n      // Support: Safari <=6 - 7 only\n      // Target should not be a text node (#504, #13143)\n      this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;\n\n      this.currentTarget = src.currentTarget;\n      this.relatedTarget = src.relatedTarget;\n\n      // Event type\n    } else {\n      this.type = src;\n    }\n\n    // Put explicitly provided properties onto the event object\n    if (props) {\n      jQuery.extend(this, props);\n    }\n\n    // Create a timestamp if incoming event doesn't have one\n    this.timeStamp = src && src.timeStamp || Date.now();\n\n    // Mark it as fixed\n    this[jQuery.expando] = true;\n  };\n\n  // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n  // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n  jQuery.Event.prototype = {\n    constructor: jQuery.Event,\n    isDefaultPrevented: returnFalse,\n    isPropagationStopped: returnFalse,\n    isImmediatePropagationStopped: returnFalse,\n    isSimulated: false,\n\n    preventDefault: function preventDefault() {\n      var e = this.originalEvent;\n\n      this.isDefaultPrevented = returnTrue;\n\n      if (e && !this.isSimulated) {\n        e.preventDefault();\n      }\n    },\n    stopPropagation: function stopPropagation() {\n      var e = this.originalEvent;\n\n      this.isPropagationStopped = returnTrue;\n\n      if (e && !this.isSimulated) {\n        e.stopPropagation();\n      }\n    },\n    stopImmediatePropagation: function stopImmediatePropagation() {\n      var e = this.originalEvent;\n\n      this.isImmediatePropagationStopped = returnTrue;\n\n      if (e && !this.isSimulated) {\n        e.stopImmediatePropagation();\n      }\n\n      this.stopPropagation();\n    }\n  };\n\n  // Includes all common event props including KeyEvent and MouseEvent specific props\n  jQuery.each({\n    altKey: true,\n    bubbles: true,\n    cancelable: true,\n    changedTouches: true,\n    ctrlKey: true,\n    detail: true,\n    eventPhase: true,\n    metaKey: true,\n    pageX: true,\n    pageY: true,\n    shiftKey: true,\n    view: true,\n    'char': true,\n    charCode: true,\n    key: true,\n    keyCode: true,\n    button: true,\n    buttons: true,\n    clientX: true,\n    clientY: true,\n    offsetX: true,\n    offsetY: true,\n    pointerId: true,\n    pointerType: true,\n    screenX: true,\n    screenY: true,\n    targetTouches: true,\n    toElement: true,\n    touches: true,\n\n    which: function which(event) {\n      var button = event.button;\n\n      // Add which for key events\n      if (event.which == null && rkeyEvent.test(event.type)) {\n        return event.charCode != null ? event.charCode : event.keyCode;\n      }\n\n      // Add which for click: 1 === left; 2 === middle; 3 === right\n      if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {\n        if (button & 1) {\n          return 1;\n        }\n\n        if (button & 2) {\n          return 3;\n        }\n\n        if (button & 4) {\n          return 2;\n        }\n\n        return 0;\n      }\n\n      return event.which;\n    }\n  }, jQuery.event.addProp);\n\n  // Create mouseenter/leave events using mouseover/out and event-time checks\n  // so that event delegation works in jQuery.\n  // Do the same for pointerenter/pointerleave and pointerover/pointerout\n  //\n  // Support: Safari 7 only\n  // Safari sends mouseenter too often; see:\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n  // for the description of the bug (it existed in older Chrome versions as well).\n  jQuery.each({\n    mouseenter: 'mouseover',\n    mouseleave: 'mouseout',\n    pointerenter: 'pointerover',\n    pointerleave: 'pointerout'\n  }, function (orig, fix) {\n    jQuery.event.special[orig] = {\n      delegateType: fix,\n      bindType: fix,\n\n      handle: function handle(event) {\n        var ret,\n            target = this,\n            related = event.relatedTarget,\n            handleObj = event.handleObj;\n\n        // For mouseenter/leave call the handler if related is outside the target.\n        // NB: No relatedTarget if the mouse left/entered the browser window\n        if (!related || related !== target && !jQuery.contains(target, related)) {\n          event.type = handleObj.origType;\n          ret = handleObj.handler.apply(this, arguments);\n          event.type = fix;\n        }\n        return ret;\n      }\n    };\n  });\n\n  jQuery.fn.extend({\n\n    on: function on(types, selector, data, fn) {\n      return _on(this, types, selector, data, fn);\n    },\n    one: function one(types, selector, data, fn) {\n      return _on(this, types, selector, data, fn, 1);\n    },\n    off: function off(types, selector, fn) {\n      var handleObj, type;\n      if (types && types.preventDefault && types.handleObj) {\n\n        // ( event )  dispatched jQuery.Event\n        handleObj = types.handleObj;\n        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);\n        return this;\n      }\n      if ((typeof types === 'undefined' ? 'undefined' : _typeof(types)) === 'object') {\n\n        // ( types-object [, selector] )\n        for (type in types) {\n          this.off(type, selector, types[type]);\n        }\n        return this;\n      }\n      if (selector === false || typeof selector === 'function') {\n\n        // ( types [, fn] )\n        fn = selector;\n        selector = undefined;\n      }\n      if (fn === false) {\n        fn = returnFalse;\n      }\n      return this.each(function () {\n        jQuery.event.remove(this, types, fn, selector);\n      });\n    }\n  });\n\n  var\n\n  /* eslint-disable max-len */\n\n  // See https://github.com/eslint/eslint/issues/3229\n  rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n\n\n  /* eslint-enable */\n\n  // Support: IE <=10 - 11, Edge 12 - 13 only\n  // In IE/Edge using regex groups here causes severe slowdowns.\n  // See https://connect.microsoft.com/IE/feedback/details/1736512/\n  rnoInnerhtml = /<script|<style|<link/i,\n\n\n  // checked=\"checked\" or checked\n  rchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n      rcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\n  // Prefer a tbody over its parent table for containing new rows\n  function manipulationTarget(elem, content) {\n    if (nodeName(elem, 'table') && nodeName(content.nodeType !== 11 ? content : content.firstChild, 'tr')) {\n\n      return jQuery(elem).children('tbody')[0] || elem;\n    }\n\n    return elem;\n  }\n\n  // Replace/restore the type attribute of script elements for safe DOM manipulation\n  function disableScript(elem) {\n    elem.type = (elem.getAttribute('type') !== null) + '/' + elem.type;\n    return elem;\n  }\n  function restoreScript(elem) {\n    if ((elem.type || '').slice(0, 5) === 'true/') {\n      elem.type = elem.type.slice(5);\n    } else {\n      elem.removeAttribute('type');\n    }\n\n    return elem;\n  }\n\n  function cloneCopyEvent(src, dest) {\n    var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n    if (dest.nodeType !== 1) {\n      return;\n    }\n\n    // 1. Copy private data: events, handlers, etc.\n    if (dataPriv.hasData(src)) {\n      pdataOld = dataPriv.access(src);\n      pdataCur = dataPriv.set(dest, pdataOld);\n      events = pdataOld.events;\n\n      if (events) {\n        delete pdataCur.handle;\n        pdataCur.events = {};\n\n        for (type in events) {\n          for (i = 0, l = events[type].length; i < l; i++) {\n            jQuery.event.add(dest, type, events[type][i]);\n          }\n        }\n      }\n    }\n\n    // 2. Copy user data\n    if (dataUser.hasData(src)) {\n      udataOld = dataUser.access(src);\n      udataCur = jQuery.extend({}, udataOld);\n\n      dataUser.set(dest, udataCur);\n    }\n  }\n\n  // Fix IE bugs, see support tests\n  function fixInput(src, dest) {\n    var nodeName = dest.nodeName.toLowerCase();\n\n    // Fails to persist the checked state of a cloned checkbox or radio button.\n    if (nodeName === 'input' && rcheckableType.test(src.type)) {\n      dest.checked = src.checked;\n\n      // Fails to return the selected option to the default selected state when cloning options\n    } else if (nodeName === 'input' || nodeName === 'textarea') {\n      dest.defaultValue = src.defaultValue;\n    }\n  }\n\n  function domManip(collection, args, callback, ignored) {\n\n    // Flatten any nested arrays\n    args = concat.apply([], args);\n\n    var fragment,\n        first,\n        scripts,\n        hasScripts,\n        node,\n        doc,\n        i = 0,\n        l = collection.length,\n        iNoClone = l - 1,\n        value = args[0],\n        valueIsFunction = isFunction(value);\n\n    // We can't cloneNode fragments that contain checked, in WebKit\n    if (valueIsFunction || l > 1 && typeof value === 'string' && !support.checkClone && rchecked.test(value)) {\n      return collection.each(function (index) {\n        var self = collection.eq(index);\n        if (valueIsFunction) {\n          args[0] = value.call(this, index, self.html());\n        }\n        domManip(self, args, callback, ignored);\n      });\n    }\n\n    if (l) {\n      fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);\n      first = fragment.firstChild;\n\n      if (fragment.childNodes.length === 1) {\n        fragment = first;\n      }\n\n      // Require either new content or an interest in ignored elements to invoke the callback\n      if (first || ignored) {\n        scripts = jQuery.map(getAll(fragment, 'script'), disableScript);\n        hasScripts = scripts.length;\n\n        // Use the original fragment for the last item\n        // instead of the first because it can end up\n        // being emptied incorrectly in certain situations (#8070).\n        for (; i < l; i++) {\n          node = fragment;\n\n          if (i !== iNoClone) {\n            node = jQuery.clone(node, true, true);\n\n            // Keep references to cloned scripts for later restoration\n            if (hasScripts) {\n\n              // Support: Android <=4.0 only, PhantomJS 1 only\n              // push.apply(_, arraylike) throws on ancient WebKit\n              jQuery.merge(scripts, getAll(node, 'script'));\n            }\n          }\n\n          callback.call(collection[i], node, i);\n        }\n\n        if (hasScripts) {\n          doc = scripts[scripts.length - 1].ownerDocument;\n\n          // Reenable scripts\n          jQuery.map(scripts, restoreScript);\n\n          // Evaluate executable scripts on first document insertion\n          for (i = 0; i < hasScripts; i++) {\n            node = scripts[i];\n            if (rscriptType.test(node.type || '') && !dataPriv.access(node, 'globalEval') && jQuery.contains(doc, node)) {\n\n              if (node.src && (node.type || '').toLowerCase() !== 'module') {\n\n                // Optional AJAX dependency, but won't run scripts if not present\n                if (jQuery._evalUrl) {\n                  jQuery._evalUrl(node.src);\n                }\n              } else {\n                DOMEval(node.textContent.replace(rcleanScript, ''), doc, node);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return collection;\n  }\n\n  function _remove(elem, selector, keepData) {\n    var node,\n        nodes = selector ? jQuery.filter(selector, elem) : elem,\n        i = 0;\n\n    for (; (node = nodes[i]) != null; i++) {\n      if (!keepData && node.nodeType === 1) {\n        jQuery.cleanData(getAll(node));\n      }\n\n      if (node.parentNode) {\n        if (keepData && jQuery.contains(node.ownerDocument, node)) {\n          setGlobalEval(getAll(node, 'script'));\n        }\n        node.parentNode.removeChild(node);\n      }\n    }\n\n    return elem;\n  }\n\n  jQuery.extend({\n    htmlPrefilter: function htmlPrefilter(html) {\n      return html.replace(rxhtmlTag, '<$1></$2>');\n    },\n\n    clone: function clone(elem, dataAndEvents, deepDataAndEvents) {\n      var i,\n          l,\n          srcElements,\n          destElements,\n          clone = elem.cloneNode(true),\n          inPage = jQuery.contains(elem.ownerDocument, elem);\n\n      // Fix IE cloning issues\n      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {\n\n        // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n        destElements = getAll(clone);\n        srcElements = getAll(elem);\n\n        for (i = 0, l = srcElements.length; i < l; i++) {\n          fixInput(srcElements[i], destElements[i]);\n        }\n      }\n\n      // Copy the events from the original to the clone\n      if (dataAndEvents) {\n        if (deepDataAndEvents) {\n          srcElements = srcElements || getAll(elem);\n          destElements = destElements || getAll(clone);\n\n          for (i = 0, l = srcElements.length; i < l; i++) {\n            cloneCopyEvent(srcElements[i], destElements[i]);\n          }\n        } else {\n          cloneCopyEvent(elem, clone);\n        }\n      }\n\n      // Preserve script evaluation history\n      destElements = getAll(clone, 'script');\n      if (destElements.length > 0) {\n        setGlobalEval(destElements, !inPage && getAll(elem, 'script'));\n      }\n\n      // Return the cloned set\n      return clone;\n    },\n\n    cleanData: function cleanData(elems) {\n      var data,\n          elem,\n          type,\n          special = jQuery.event.special,\n          i = 0;\n\n      for (; (elem = elems[i]) !== undefined; i++) {\n        if (acceptData(elem)) {\n          if (data = elem[dataPriv.expando]) {\n            if (data.events) {\n              for (type in data.events) {\n                if (special[type]) {\n                  jQuery.event.remove(elem, type);\n\n                  // This is a shortcut to avoid jQuery.event.remove's overhead\n                } else {\n                  jQuery.removeEvent(elem, type, data.handle);\n                }\n              }\n            }\n\n            // Support: Chrome <=35 - 45+\n            // Assign undefined instead of using delete, see Data#remove\n            elem[dataPriv.expando] = undefined;\n          }\n          if (elem[dataUser.expando]) {\n\n            // Support: Chrome <=35 - 45+\n            // Assign undefined instead of using delete, see Data#remove\n            elem[dataUser.expando] = undefined;\n          }\n        }\n      }\n    }\n  });\n\n  jQuery.fn.extend({\n    detach: function detach(selector) {\n      return _remove(this, selector, true);\n    },\n\n    remove: function remove(selector) {\n      return _remove(this, selector);\n    },\n\n    text: function text(value) {\n      return access(this, function (value) {\n        return value === undefined ? jQuery.text(this) : this.empty().each(function () {\n          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n            this.textContent = value;\n          }\n        });\n      }, null, value, arguments.length);\n    },\n\n    append: function append() {\n      return domManip(this, arguments, function (elem) {\n        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n          var target = manipulationTarget(this, elem);\n          target.appendChild(elem);\n        }\n      });\n    },\n\n    prepend: function prepend() {\n      return domManip(this, arguments, function (elem) {\n        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n          var target = manipulationTarget(this, elem);\n          target.insertBefore(elem, target.firstChild);\n        }\n      });\n    },\n\n    before: function before() {\n      return domManip(this, arguments, function (elem) {\n        if (this.parentNode) {\n          this.parentNode.insertBefore(elem, this);\n        }\n      });\n    },\n\n    after: function after() {\n      return domManip(this, arguments, function (elem) {\n        if (this.parentNode) {\n          this.parentNode.insertBefore(elem, this.nextSibling);\n        }\n      });\n    },\n\n    empty: function empty() {\n      var elem,\n          i = 0;\n\n      for (; (elem = this[i]) != null; i++) {\n        if (elem.nodeType === 1) {\n\n          // Prevent memory leaks\n          jQuery.cleanData(getAll(elem, false));\n\n          // Remove any remaining nodes\n          elem.textContent = '';\n        }\n      }\n\n      return this;\n    },\n\n    clone: function clone(dataAndEvents, deepDataAndEvents) {\n      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n      return this.map(function () {\n        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);\n      });\n    },\n\n    html: function html(value) {\n      return access(this, function (value) {\n        var elem = this[0] || {},\n            i = 0,\n            l = this.length;\n\n        if (value === undefined && elem.nodeType === 1) {\n          return elem.innerHTML;\n        }\n\n        // See if we can take a shortcut and just use innerHTML\n        if (typeof value === 'string' && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ['', ''])[1].toLowerCase()]) {\n\n          value = jQuery.htmlPrefilter(value);\n\n          try {\n            for (; i < l; i++) {\n              elem = this[i] || {};\n\n              // Remove element nodes and prevent memory leaks\n              if (elem.nodeType === 1) {\n                jQuery.cleanData(getAll(elem, false));\n                elem.innerHTML = value;\n              }\n            }\n\n            elem = 0;\n\n            // If using innerHTML throws an exception, use the fallback method\n          } catch (e) {}\n        }\n\n        if (elem) {\n          this.empty().append(value);\n        }\n      }, null, value, arguments.length);\n    },\n\n    replaceWith: function replaceWith() {\n      var ignored = [];\n\n      // Make the changes, replacing each non-ignored context element with the new content\n      return domManip(this, arguments, function (elem) {\n        var parent = this.parentNode;\n\n        if (jQuery.inArray(this, ignored) < 0) {\n          jQuery.cleanData(getAll(this));\n          if (parent) {\n            parent.replaceChild(elem, this);\n          }\n        }\n\n        // Force callback invocation\n      }, ignored);\n    }\n  });\n\n  jQuery.each({\n    appendTo: 'append',\n    prependTo: 'prepend',\n    insertBefore: 'before',\n    insertAfter: 'after',\n    replaceAll: 'replaceWith'\n  }, function (name, original) {\n    jQuery.fn[name] = function (selector) {\n      var elems,\n          ret = [],\n          insert = jQuery(selector),\n          last = insert.length - 1,\n          i = 0;\n\n      for (; i <= last; i++) {\n        elems = i === last ? this : this.clone(true);\n        jQuery(insert[i])[original](elems);\n\n        // Support: Android <=4.0 only, PhantomJS 1 only\n        // .get() because push.apply(_, arraylike) throws on ancient WebKit\n        push.apply(ret, elems.get());\n      }\n\n      return this.pushStack(ret);\n    };\n  });\n  var rnumnonpx = new RegExp('^(' + pnum + ')(?!px)[a-z%]+$', 'i');\n\n  var getStyles = function getStyles(elem) {\n\n    // Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n    // IE throws on elements created in popups\n    // FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n    var view = elem.ownerDocument.defaultView;\n\n    if (!view || !view.opener) {\n      view = window;\n    }\n\n    return view.getComputedStyle(elem);\n  };\n\n  var rboxStyle = new RegExp(cssExpand.join('|'), 'i');\n\n  (function () {\n\n    // Executing both pixelPosition & boxSizingReliable tests require only one layout\n    // so they're executed at the same time to save the second computation.\n    function computeStyleTests() {\n\n      // This is a singleton, we need to execute it only once\n      if (!div) {\n        return;\n      }\n\n      container.style.cssText = 'position:absolute;left:-11111px;width:60px;' + 'margin-top:1px;padding:0;border:0';\n      div.style.cssText = 'position:relative;display:block;box-sizing:border-box;overflow:scroll;' + 'margin:auto;border:1px;padding:1px;' + 'width:60%;top:1%';\n      documentElement.appendChild(container).appendChild(div);\n\n      var divStyle = window.getComputedStyle(div);\n      pixelPositionVal = divStyle.top !== '1%';\n\n      // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n      reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;\n\n      // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\n      // Some styles come back with percentage values, even though they shouldn't\n      div.style.right = '60%';\n      pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;\n\n      // Support: IE 9 - 11 only\n      // Detect misreporting of content dimensions for box-sizing:border-box elements\n      boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;\n\n      // Support: IE 9 only\n      // Detect overflow:scroll screwiness (gh-3699)\n      div.style.position = 'absolute';\n      scrollboxSizeVal = div.offsetWidth === 36 || 'absolute';\n\n      documentElement.removeChild(container);\n\n      // Nullify the div so it wouldn't be stored in the memory and\n      // it will also be a sign that checks already performed\n      div = null;\n    }\n\n    function roundPixelMeasures(measure) {\n      return Math.round(parseFloat(measure));\n    }\n\n    var pixelPositionVal,\n        boxSizingReliableVal,\n        scrollboxSizeVal,\n        pixelBoxStylesVal,\n        reliableMarginLeftVal,\n        container = document.createElement('div'),\n        div = document.createElement('div');\n\n    // Finish early in limited (non-browser) environments\n    if (!div.style) {\n      return;\n    }\n\n    // Support: IE <=9 - 11 only\n    // Style of cloned element affects source element cloned (#8908)\n    div.style.backgroundClip = 'content-box';\n    div.cloneNode(true).style.backgroundClip = '';\n    support.clearCloneStyle = div.style.backgroundClip === 'content-box';\n\n    jQuery.extend(support, {\n      boxSizingReliable: function boxSizingReliable() {\n        computeStyleTests();\n        return boxSizingReliableVal;\n      },\n      pixelBoxStyles: function pixelBoxStyles() {\n        computeStyleTests();\n        return pixelBoxStylesVal;\n      },\n      pixelPosition: function pixelPosition() {\n        computeStyleTests();\n        return pixelPositionVal;\n      },\n      reliableMarginLeft: function reliableMarginLeft() {\n        computeStyleTests();\n        return reliableMarginLeftVal;\n      },\n      scrollboxSize: function scrollboxSize() {\n        computeStyleTests();\n        return scrollboxSizeVal;\n      }\n    });\n  })();\n\n  function curCSS(elem, name, computed) {\n    var width,\n        minWidth,\n        maxWidth,\n        ret,\n\n\n    // Support: Firefox 51+\n    // Retrieving style before computed somehow\n    // fixes an issue with getting wrong values\n    // on detached elements\n    style = elem.style;\n\n    computed = computed || getStyles(elem);\n\n    // getPropertyValue is needed for:\n    //   .css('filter') (IE 9 only, #12537)\n    //   .css('--customProperty) (#3144)\n    if (computed) {\n      ret = computed.getPropertyValue(name) || computed[name];\n\n      if (ret === '' && !jQuery.contains(elem.ownerDocument, elem)) {\n        ret = jQuery.style(elem, name);\n      }\n\n      // A tribute to the \"awesome hack by Dean Edwards\"\n      // Android Browser returns percentage for some values,\n      // but width seems to be reliably pixels.\n      // This is against the CSSOM draft spec:\n      // https://drafts.csswg.org/cssom/#resolved-values\n      if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {\n\n        // Remember the original values\n        width = style.width;\n        minWidth = style.minWidth;\n        maxWidth = style.maxWidth;\n\n        // Put in the new values to get a computed value out\n        style.minWidth = style.maxWidth = style.width = ret;\n        ret = computed.width;\n\n        // Revert the changed values\n        style.width = width;\n        style.minWidth = minWidth;\n        style.maxWidth = maxWidth;\n      }\n    }\n\n    return ret !== undefined ?\n\n    // Support: IE <=9 - 11 only\n    // IE returns zIndex value as an integer.\n    ret + '' : ret;\n  }\n\n  function addGetHookIf(conditionFn, hookFn) {\n\n    // Define the hook, we'll check on the first run if it's really needed.\n    return {\n      get: function get() {\n        if (conditionFn()) {\n\n          // Hook not needed (or it's not possible to use it due\n          // to missing dependency), remove it.\n          delete this.get;\n          return;\n        }\n\n        // Hook needed; redefine it so that the support test is not executed again.\n        return (this.get = hookFn).apply(this, arguments);\n      }\n    };\n  }\n\n  var\n\n  // Swappable if display is none or starts with table\n  // except \"table\", \"table-cell\", or \"table-caption\"\n  // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n  rdisplayswap = /^(none|table(?!-c[ea]).+)/,\n      rcustomProp = /^--/,\n      cssShow = { position: 'absolute', visibility: 'hidden', display: 'block' },\n      cssNormalTransform = {\n    letterSpacing: '0',\n    fontWeight: '400'\n  },\n      cssPrefixes = ['Webkit', 'Moz', 'ms'],\n      emptyStyle = document.createElement('div').style;\n\n  // Return a css property mapped to a potentially vendor prefixed property\n  function vendorPropName(name) {\n\n    // Shortcut for names that are not vendor prefixed\n    if (name in emptyStyle) {\n      return name;\n    }\n\n    // Check for vendor prefixed names\n    var capName = name[0].toUpperCase() + name.slice(1),\n        i = cssPrefixes.length;\n\n    while (i--) {\n      name = cssPrefixes[i] + capName;\n      if (name in emptyStyle) {\n        return name;\n      }\n    }\n  }\n\n  // Return a property mapped along what jQuery.cssProps suggests or to\n  // a vendor prefixed property.\n  function finalPropName(name) {\n    var ret = jQuery.cssProps[name];\n    if (!ret) {\n      ret = jQuery.cssProps[name] = vendorPropName(name) || name;\n    }\n    return ret;\n  }\n\n  function setPositiveNumber(elem, value, subtract) {\n\n    // Any relative (+/-) values have already been\n    // normalized at this point\n    var matches = rcssNum.exec(value);\n    return matches ?\n\n    // Guard against undefined \"subtract\", e.g., when used as in cssHooks\n    Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || 'px') : value;\n  }\n\n  function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {\n    var i = dimension === 'width' ? 1 : 0,\n        extra = 0,\n        delta = 0;\n\n    // Adjustment may not be necessary\n    if (box === (isBorderBox ? 'border' : 'content')) {\n      return 0;\n    }\n\n    for (; i < 4; i += 2) {\n\n      // Both box models exclude margin\n      if (box === 'margin') {\n        delta += jQuery.css(elem, box + cssExpand[i], true, styles);\n      }\n\n      // If we get here with a content-box, we're seeking \"padding\" or \"border\" or \"margin\"\n      if (!isBorderBox) {\n\n        // Add padding\n        delta += jQuery.css(elem, 'padding' + cssExpand[i], true, styles);\n\n        // For \"border\" or \"margin\", add border\n        if (box !== 'padding') {\n          delta += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);\n\n          // But still keep track of it otherwise\n        } else {\n          extra += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);\n        }\n\n        // If we get here with a border-box (content + padding + border), we're seeking \"content\" or\n        // \"padding\" or \"margin\"\n      } else {\n\n        // For \"content\", subtract padding\n        if (box === 'content') {\n          delta -= jQuery.css(elem, 'padding' + cssExpand[i], true, styles);\n        }\n\n        // For \"content\" or \"padding\", subtract border\n        if (box !== 'margin') {\n          delta -= jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);\n        }\n      }\n    }\n\n    // Account for positive content-box scroll gutter when requested by providing computedVal\n    if (!isBorderBox && computedVal >= 0) {\n\n      // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\n      // Assuming integer scroll gutter, subtract the rest and round down\n      delta += Math.max(0, Math.ceil(elem['offset' + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5));\n    }\n\n    return delta;\n  }\n\n  function getWidthOrHeight(elem, dimension, extra) {\n\n    // Start with computed style\n    var styles = getStyles(elem),\n        val = curCSS(elem, dimension, styles),\n        isBorderBox = jQuery.css(elem, 'boxSizing', false, styles) === 'border-box',\n        valueIsBorderBox = isBorderBox;\n\n    // Support: Firefox <=54\n    // Return a confounding non-pixel value or feign ignorance, as appropriate.\n    if (rnumnonpx.test(val)) {\n      if (!extra) {\n        return val;\n      }\n      val = 'auto';\n    }\n\n    // Check for style in case a browser which returns unreliable values\n    // for getComputedStyle silently falls back to the reliable elem.style\n    valueIsBorderBox = valueIsBorderBox && (support.boxSizingReliable() || val === elem.style[dimension]);\n\n    // Fall back to offsetWidth/offsetHeight when value is \"auto\"\n    // This happens for inline elements with no explicit setting (gh-3571)\n    // Support: Android <=4.1 - 4.3 only\n    // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\n    if (val === 'auto' || !parseFloat(val) && jQuery.css(elem, 'display', false, styles) === 'inline') {\n\n      val = elem['offset' + dimension[0].toUpperCase() + dimension.slice(1)];\n\n      // offsetWidth/offsetHeight provide border-box values\n      valueIsBorderBox = true;\n    }\n\n    // Normalize \"\" and auto\n    val = parseFloat(val) || 0;\n\n    // Adjust for the element's box model\n    return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? 'border' : 'content'), valueIsBorderBox, styles,\n\n    // Provide the current computed size to request scroll gutter calculation (gh-3589)\n    val) + 'px';\n  }\n\n  jQuery.extend({\n\n    // Add in style property hooks for overriding the default\n    // behavior of getting and setting a style property\n    cssHooks: {\n      opacity: {\n        get: function get(elem, computed) {\n          if (computed) {\n\n            // We should always get a number back from opacity\n            var ret = curCSS(elem, 'opacity');\n            return ret === '' ? '1' : ret;\n          }\n        }\n      }\n    },\n\n    // Don't automatically add \"px\" to these possibly-unitless properties\n    cssNumber: {\n      'animationIterationCount': true,\n      'columnCount': true,\n      'fillOpacity': true,\n      'flexGrow': true,\n      'flexShrink': true,\n      'fontWeight': true,\n      'lineHeight': true,\n      'opacity': true,\n      'order': true,\n      'orphans': true,\n      'widows': true,\n      'zIndex': true,\n      'zoom': true\n    },\n\n    // Add in properties whose names you wish to fix before\n    // setting or getting the value\n    cssProps: {},\n\n    // Get and set the style property on a DOM Node\n    style: function style(elem, name, value, extra) {\n\n      // Don't set styles on text and comment nodes\n      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {\n        return;\n      }\n\n      // Make sure that we're working with the right name\n      var ret,\n          type,\n          hooks,\n          origName = camelCase(name),\n          isCustomProp = rcustomProp.test(name),\n          style = elem.style;\n\n      // Make sure that we're working with the right name. We don't\n      // want to query the value if it is a CSS custom property\n      // since they are user-defined.\n      if (!isCustomProp) {\n        name = finalPropName(origName);\n      }\n\n      // Gets hook for the prefixed version, then unprefixed version\n      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];\n\n      // Check if we're setting a value\n      if (value !== undefined) {\n        type = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n\n        // Convert \"+=\" or \"-=\" to relative numbers (#7345)\n        if (type === 'string' && (ret = rcssNum.exec(value)) && ret[1]) {\n          value = adjustCSS(elem, name, ret);\n\n          // Fixes bug #9237\n          type = 'number';\n        }\n\n        // Make sure that null and NaN values aren't set (#7116)\n        if (value == null || value !== value) {\n          return;\n        }\n\n        // If a number was passed in, add the unit (except for certain CSS properties)\n        if (type === 'number') {\n          value += ret && ret[3] || (jQuery.cssNumber[origName] ? '' : 'px');\n        }\n\n        // background-* props affect original clone's values\n        if (!support.clearCloneStyle && value === '' && name.indexOf('background') === 0) {\n          style[name] = 'inherit';\n        }\n\n        // If a hook was provided, use that value, otherwise just set the specified value\n        if (!hooks || !('set' in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {\n\n          if (isCustomProp) {\n            style.setProperty(name, value);\n          } else {\n            style[name] = value;\n          }\n        }\n      } else {\n\n        // If a hook was provided get the non-computed value from there\n        if (hooks && 'get' in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {\n\n          return ret;\n        }\n\n        // Otherwise just get the value from the style object\n        return style[name];\n      }\n    },\n\n    css: function css(elem, name, extra, styles) {\n      var val,\n          num,\n          hooks,\n          origName = camelCase(name),\n          isCustomProp = rcustomProp.test(name);\n\n      // Make sure that we're working with the right name. We don't\n      // want to modify the value if it is a CSS custom property\n      // since they are user-defined.\n      if (!isCustomProp) {\n        name = finalPropName(origName);\n      }\n\n      // Try prefixed name followed by the unprefixed name\n      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];\n\n      // If a hook was provided get the computed value from there\n      if (hooks && 'get' in hooks) {\n        val = hooks.get(elem, true, extra);\n      }\n\n      // Otherwise, if a way to get the computed value exists, use that\n      if (val === undefined) {\n        val = curCSS(elem, name, styles);\n      }\n\n      // Convert \"normal\" to computed value\n      if (val === 'normal' && name in cssNormalTransform) {\n        val = cssNormalTransform[name];\n      }\n\n      // Make numeric if forced or a qualifier was provided and val looks numeric\n      if (extra === '' || extra) {\n        num = parseFloat(val);\n        return extra === true || isFinite(num) ? num || 0 : val;\n      }\n\n      return val;\n    }\n  });\n\n  jQuery.each(['height', 'width'], function (i, dimension) {\n    jQuery.cssHooks[dimension] = {\n      get: function get(elem, computed, extra) {\n        if (computed) {\n\n          // Certain elements can have dimension info if we invisibly show them\n          // but it must have a current display style that would benefit\n          return rdisplayswap.test(jQuery.css(elem, 'display')) && (\n\n          // Support: Safari 8+\n          // Table columns in Safari have non-zero offsetWidth & zero\n          // getBoundingClientRect().width unless display is changed.\n          // Support: IE <=11 only\n          // Running getBoundingClientRect on a disconnected node\n          // in IE throws an error.\n          !elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {\n            return getWidthOrHeight(elem, dimension, extra);\n          }) : getWidthOrHeight(elem, dimension, extra);\n        }\n      },\n\n      set: function set(elem, value, extra) {\n        var matches,\n            styles = getStyles(elem),\n            isBorderBox = jQuery.css(elem, 'boxSizing', false, styles) === 'border-box',\n            subtract = extra && boxModelAdjustment(elem, dimension, extra, isBorderBox, styles);\n\n        // Account for unreliable border-box dimensions by comparing offset* to computed and\n        // faking a content-box to get border and padding (gh-3699)\n        if (isBorderBox && support.scrollboxSize() === styles.position) {\n          subtract -= Math.ceil(elem['offset' + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, 'border', false, styles) - 0.5);\n        }\n\n        // Convert to pixels if value adjustment is needed\n        if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || 'px') !== 'px') {\n\n          elem.style[dimension] = value;\n          value = jQuery.css(elem, dimension);\n        }\n\n        return setPositiveNumber(elem, value, subtract);\n      }\n    };\n  });\n\n  jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {\n    if (computed) {\n      return (parseFloat(curCSS(elem, 'marginLeft')) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function () {\n        return elem.getBoundingClientRect().left;\n      })) + 'px';\n    }\n  });\n\n  // These hooks are used by animate to expand properties\n  jQuery.each({\n    margin: '',\n    padding: '',\n    border: 'Width'\n  }, function (prefix, suffix) {\n    jQuery.cssHooks[prefix + suffix] = {\n      expand: function expand(value) {\n        var i = 0,\n            expanded = {},\n\n\n        // Assumes a single number if not a string\n        parts = typeof value === 'string' ? value.split(' ') : [value];\n\n        for (; i < 4; i++) {\n          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];\n        }\n\n        return expanded;\n      }\n    };\n\n    if (prefix !== 'margin') {\n      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;\n    }\n  });\n\n  jQuery.fn.extend({\n    css: function css(name, value) {\n      return access(this, function (elem, name, value) {\n        var styles,\n            len,\n            map = {},\n            i = 0;\n\n        if (Array.isArray(name)) {\n          styles = getStyles(elem);\n          len = name.length;\n\n          for (; i < len; i++) {\n            map[name[i]] = jQuery.css(elem, name[i], false, styles);\n          }\n\n          return map;\n        }\n\n        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);\n      }, name, value, arguments.length > 1);\n    }\n  });\n\n  function Tween(elem, options, prop, end, easing) {\n    return new Tween.prototype.init(elem, options, prop, end, easing);\n  }\n  jQuery.Tween = Tween;\n\n  Tween.prototype = {\n    constructor: Tween,\n    init: function init(elem, options, prop, end, easing, unit) {\n      this.elem = elem;\n      this.prop = prop;\n      this.easing = easing || jQuery.easing._default;\n      this.options = options;\n      this.start = this.now = this.cur();\n      this.end = end;\n      this.unit = unit || (jQuery.cssNumber[prop] ? '' : 'px');\n    },\n    cur: function cur() {\n      var hooks = Tween.propHooks[this.prop];\n\n      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);\n    },\n    run: function run(percent) {\n      var eased,\n          hooks = Tween.propHooks[this.prop];\n\n      if (this.options.duration) {\n        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);\n      } else {\n        this.pos = eased = percent;\n      }\n      this.now = (this.end - this.start) * eased + this.start;\n\n      if (this.options.step) {\n        this.options.step.call(this.elem, this.now, this);\n      }\n\n      if (hooks && hooks.set) {\n        hooks.set(this);\n      } else {\n        Tween.propHooks._default.set(this);\n      }\n      return this;\n    }\n  };\n\n  Tween.prototype.init.prototype = Tween.prototype;\n\n  Tween.propHooks = {\n    _default: {\n      get: function get(tween) {\n        var result;\n\n        // Use a property on the element directly when it is not a DOM element,\n        // or when there is no matching style property that exists.\n        if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {\n          return tween.elem[tween.prop];\n        }\n\n        // Passing an empty string as a 3rd parameter to .css will automatically\n        // attempt a parseFloat and fallback to a string if the parse fails.\n        // Simple values such as \"10px\" are parsed to Float;\n        // complex values such as \"rotate(1rad)\" are returned as-is.\n        result = jQuery.css(tween.elem, tween.prop, '');\n\n        // Empty strings, null, undefined and \"auto\" are converted to 0.\n        return !result || result === 'auto' ? 0 : result;\n      },\n      set: function set(tween) {\n\n        // Use step hook for back compat.\n        // Use cssHook if its there.\n        // Use .style if available and use plain properties where available.\n        if (jQuery.fx.step[tween.prop]) {\n          jQuery.fx.step[tween.prop](tween);\n        } else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {\n          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);\n        } else {\n          tween.elem[tween.prop] = tween.now;\n        }\n      }\n    }\n  };\n\n  // Support: IE <=9 only\n  // Panic based approach to setting things on disconnected nodes\n  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n    set: function set(tween) {\n      if (tween.elem.nodeType && tween.elem.parentNode) {\n        tween.elem[tween.prop] = tween.now;\n      }\n    }\n  };\n\n  jQuery.easing = {\n    linear: function linear(p) {\n      return p;\n    },\n    swing: function swing(p) {\n      return 0.5 - Math.cos(p * Math.PI) / 2;\n    },\n    _default: 'swing'\n  };\n\n  jQuery.fx = Tween.prototype.init;\n\n  // Back compat <1.8 extension point\n  jQuery.fx.step = {};\n\n  var fxNow,\n      inProgress,\n      rfxtypes = /^(?:toggle|show|hide)$/,\n      rrun = /queueHooks$/;\n\n  function schedule() {\n    if (inProgress) {\n      if (document.hidden === false && window.requestAnimationFrame) {\n        window.requestAnimationFrame(schedule);\n      } else {\n        window.setTimeout(schedule, jQuery.fx.interval);\n      }\n\n      jQuery.fx.tick();\n    }\n  }\n\n  // Animations created synchronously will run synchronously\n  function createFxNow() {\n    window.setTimeout(function () {\n      fxNow = undefined;\n    });\n    return fxNow = Date.now();\n  }\n\n  // Generate parameters to create a standard animation\n  function genFx(type, includeWidth) {\n    var which,\n        i = 0,\n        attrs = { height: type };\n\n    // If we include width, step value is 1 to do all cssExpand values,\n    // otherwise step value is 2 to skip over Left and Right\n    includeWidth = includeWidth ? 1 : 0;\n    for (; i < 4; i += 2 - includeWidth) {\n      which = cssExpand[i];\n      attrs['margin' + which] = attrs['padding' + which] = type;\n    }\n\n    if (includeWidth) {\n      attrs.opacity = attrs.width = type;\n    }\n\n    return attrs;\n  }\n\n  function createTween(value, prop, animation) {\n    var tween,\n        collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners['*']),\n        index = 0,\n        length = collection.length;\n    for (; index < length; index++) {\n      if (tween = collection[index].call(animation, prop, value)) {\n\n        // We're done with this property\n        return tween;\n      }\n    }\n  }\n\n  function defaultPrefilter(elem, props, opts) {\n    var prop,\n        value,\n        toggle,\n        hooks,\n        oldfire,\n        propTween,\n        restoreDisplay,\n        display,\n        isBox = 'width' in props || 'height' in props,\n        anim = this,\n        orig = {},\n        style = elem.style,\n        hidden = elem.nodeType && isHiddenWithinTree(elem),\n        dataShow = dataPriv.get(elem, 'fxshow');\n\n    // Queue-skipping animations hijack the fx hooks\n    if (!opts.queue) {\n      hooks = jQuery._queueHooks(elem, 'fx');\n      if (hooks.unqueued == null) {\n        hooks.unqueued = 0;\n        oldfire = hooks.empty.fire;\n        hooks.empty.fire = function () {\n          if (!hooks.unqueued) {\n            oldfire();\n          }\n        };\n      }\n      hooks.unqueued++;\n\n      anim.always(function () {\n\n        // Ensure the complete handler is called before this completes\n        anim.always(function () {\n          hooks.unqueued--;\n          if (!jQuery.queue(elem, 'fx').length) {\n            hooks.empty.fire();\n          }\n        });\n      });\n    }\n\n    // Detect show/hide animations\n    for (prop in props) {\n      value = props[prop];\n      if (rfxtypes.test(value)) {\n        delete props[prop];\n        toggle = toggle || value === 'toggle';\n        if (value === (hidden ? 'hide' : 'show')) {\n\n          // Pretend to be hidden if this is a \"show\" and\n          // there is still data from a stopped show/hide\n          if (value === 'show' && dataShow && dataShow[prop] !== undefined) {\n            hidden = true;\n\n            // Ignore all other no-op show/hide data\n          } else {\n            continue;\n          }\n        }\n        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);\n      }\n    }\n\n    // Bail out if this is a no-op like .hide().hide()\n    propTween = !jQuery.isEmptyObject(props);\n    if (!propTween && jQuery.isEmptyObject(orig)) {\n      return;\n    }\n\n    // Restrict \"overflow\" and \"display\" styles during box animations\n    if (isBox && elem.nodeType === 1) {\n\n      // Support: IE <=9 - 11, Edge 12 - 15\n      // Record all 3 overflow attributes because IE does not infer the shorthand\n      // from identically-valued overflowX and overflowY and Edge just mirrors\n      // the overflowX value there.\n      opts.overflow = [style.overflow, style.overflowX, style.overflowY];\n\n      // Identify a display type, preferring old show/hide data over the CSS cascade\n      restoreDisplay = dataShow && dataShow.display;\n      if (restoreDisplay == null) {\n        restoreDisplay = dataPriv.get(elem, 'display');\n      }\n      display = jQuery.css(elem, 'display');\n      if (display === 'none') {\n        if (restoreDisplay) {\n          display = restoreDisplay;\n        } else {\n\n          // Get nonempty value(s) by temporarily forcing visibility\n          showHide([elem], true);\n          restoreDisplay = elem.style.display || restoreDisplay;\n          display = jQuery.css(elem, 'display');\n          showHide([elem]);\n        }\n      }\n\n      // Animate inline elements as inline-block\n      if (display === 'inline' || display === 'inline-block' && restoreDisplay != null) {\n        if (jQuery.css(elem, 'float') === 'none') {\n\n          // Restore the original display value at the end of pure show/hide animations\n          if (!propTween) {\n            anim.done(function () {\n              style.display = restoreDisplay;\n            });\n            if (restoreDisplay == null) {\n              display = style.display;\n              restoreDisplay = display === 'none' ? '' : display;\n            }\n          }\n          style.display = 'inline-block';\n        }\n      }\n    }\n\n    if (opts.overflow) {\n      style.overflow = 'hidden';\n      anim.always(function () {\n        style.overflow = opts.overflow[0];\n        style.overflowX = opts.overflow[1];\n        style.overflowY = opts.overflow[2];\n      });\n    }\n\n    // Implement show/hide animations\n    propTween = false;\n    for (prop in orig) {\n\n      // General show/hide setup for this element animation\n      if (!propTween) {\n        if (dataShow) {\n          if ('hidden' in dataShow) {\n            hidden = dataShow.hidden;\n          }\n        } else {\n          dataShow = dataPriv.access(elem, 'fxshow', { display: restoreDisplay });\n        }\n\n        // Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n        if (toggle) {\n          dataShow.hidden = !hidden;\n        }\n\n        // Show elements before animating them\n        if (hidden) {\n          showHide([elem], true);\n        }\n\n        /* eslint-disable no-loop-func */\n\n        anim.done(function () {\n\n          /* eslint-enable no-loop-func */\n\n          // The final step of a \"hide\" animation is actually hiding the element\n          if (!hidden) {\n            showHide([elem]);\n          }\n          dataPriv.remove(elem, 'fxshow');\n          for (prop in orig) {\n            jQuery.style(elem, prop, orig[prop]);\n          }\n        });\n      }\n\n      // Per-property setup\n      propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);\n      if (!(prop in dataShow)) {\n        dataShow[prop] = propTween.start;\n        if (hidden) {\n          propTween.end = propTween.start;\n          propTween.start = 0;\n        }\n      }\n    }\n  }\n\n  function propFilter(props, specialEasing) {\n    var index, name, easing, value, hooks;\n\n    // camelCase, specialEasing and expand cssHook pass\n    for (index in props) {\n      name = camelCase(index);\n      easing = specialEasing[name];\n      value = props[index];\n      if (Array.isArray(value)) {\n        easing = value[1];\n        value = props[index] = value[0];\n      }\n\n      if (index !== name) {\n        props[name] = value;\n        delete props[index];\n      }\n\n      hooks = jQuery.cssHooks[name];\n      if (hooks && 'expand' in hooks) {\n        value = hooks.expand(value);\n        delete props[name];\n\n        // Not quite $.extend, this won't overwrite existing keys.\n        // Reusing 'index' because we have the correct \"name\"\n        for (index in value) {\n          if (!(index in props)) {\n            props[index] = value[index];\n            specialEasing[index] = easing;\n          }\n        }\n      } else {\n        specialEasing[name] = easing;\n      }\n    }\n  }\n\n  function Animation(elem, properties, options) {\n    var result,\n        stopped,\n        index = 0,\n        length = Animation.prefilters.length,\n        deferred = jQuery.Deferred().always(function () {\n\n      // Don't match elem in the :animated selector\n      delete tick.elem;\n    }),\n        tick = function tick() {\n      if (stopped) {\n        return false;\n      }\n      var currentTime = fxNow || createFxNow(),\n          remaining = Math.max(0, animation.startTime + animation.duration - currentTime),\n\n\n      // Support: Android 2.3 only\n      // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n      temp = remaining / animation.duration || 0,\n          percent = 1 - temp,\n          index = 0,\n          length = animation.tweens.length;\n\n      for (; index < length; index++) {\n        animation.tweens[index].run(percent);\n      }\n\n      deferred.notifyWith(elem, [animation, percent, remaining]);\n\n      // If there's more to do, yield\n      if (percent < 1 && length) {\n        return remaining;\n      }\n\n      // If this was an empty animation, synthesize a final progress notification\n      if (!length) {\n        deferred.notifyWith(elem, [animation, 1, 0]);\n      }\n\n      // Resolve the animation and report its conclusion\n      deferred.resolveWith(elem, [animation]);\n      return false;\n    },\n        animation = deferred.promise({\n      elem: elem,\n      props: jQuery.extend({}, properties),\n      opts: jQuery.extend(true, {\n        specialEasing: {},\n        easing: jQuery.easing._default\n      }, options),\n      originalProperties: properties,\n      originalOptions: options,\n      startTime: fxNow || createFxNow(),\n      duration: options.duration,\n      tweens: [],\n      createTween: function createTween(prop, end) {\n        var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);\n        animation.tweens.push(tween);\n        return tween;\n      },\n      stop: function stop(gotoEnd) {\n        var index = 0,\n\n\n        // If we are going to the end, we want to run all the tweens\n        // otherwise we skip this part\n        length = gotoEnd ? animation.tweens.length : 0;\n        if (stopped) {\n          return this;\n        }\n        stopped = true;\n        for (; index < length; index++) {\n          animation.tweens[index].run(1);\n        }\n\n        // Resolve when we played the last frame; otherwise, reject\n        if (gotoEnd) {\n          deferred.notifyWith(elem, [animation, 1, 0]);\n          deferred.resolveWith(elem, [animation, gotoEnd]);\n        } else {\n          deferred.rejectWith(elem, [animation, gotoEnd]);\n        }\n        return this;\n      }\n    }),\n        props = animation.props;\n\n    propFilter(props, animation.opts.specialEasing);\n\n    for (; index < length; index++) {\n      result = Animation.prefilters[index].call(animation, elem, props, animation.opts);\n      if (result) {\n        if (isFunction(result.stop)) {\n          jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);\n        }\n        return result;\n      }\n    }\n\n    jQuery.map(props, createTween, animation);\n\n    if (isFunction(animation.opts.start)) {\n      animation.opts.start.call(elem, animation);\n    }\n\n    // Attach callbacks from options\n    animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);\n\n    jQuery.fx.timer(jQuery.extend(tick, {\n      elem: elem,\n      anim: animation,\n      queue: animation.opts.queue\n    }));\n\n    return animation;\n  }\n\n  jQuery.Animation = jQuery.extend(Animation, {\n\n    tweeners: {\n      '*': [function (prop, value) {\n        var tween = this.createTween(prop, value);\n        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);\n        return tween;\n      }]\n    },\n\n    tweener: function tweener(props, callback) {\n      if (isFunction(props)) {\n        callback = props;\n        props = ['*'];\n      } else {\n        props = props.match(rnothtmlwhite);\n      }\n\n      var prop,\n          index = 0,\n          length = props.length;\n\n      for (; index < length; index++) {\n        prop = props[index];\n        Animation.tweeners[prop] = Animation.tweeners[prop] || [];\n        Animation.tweeners[prop].unshift(callback);\n      }\n    },\n\n    prefilters: [defaultPrefilter],\n\n    prefilter: function prefilter(callback, prepend) {\n      if (prepend) {\n        Animation.prefilters.unshift(callback);\n      } else {\n        Animation.prefilters.push(callback);\n      }\n    }\n  });\n\n  jQuery.speed = function (speed, easing, fn) {\n    var opt = speed && (typeof speed === 'undefined' ? 'undefined' : _typeof(speed)) === 'object' ? jQuery.extend({}, speed) : {\n      complete: fn || !fn && easing || isFunction(speed) && speed,\n      duration: speed,\n      easing: fn && easing || easing && !isFunction(easing) && easing\n    };\n\n    // Go to the end state if fx are off\n    if (jQuery.fx.off) {\n      opt.duration = 0;\n    } else {\n      if (typeof opt.duration !== 'number') {\n        if (opt.duration in jQuery.fx.speeds) {\n          opt.duration = jQuery.fx.speeds[opt.duration];\n        } else {\n          opt.duration = jQuery.fx.speeds._default;\n        }\n      }\n    }\n\n    // Normalize opt.queue - true/undefined/null -> \"fx\"\n    if (opt.queue == null || opt.queue === true) {\n      opt.queue = 'fx';\n    }\n\n    // Queueing\n    opt.old = opt.complete;\n\n    opt.complete = function () {\n      if (isFunction(opt.old)) {\n        opt.old.call(this);\n      }\n\n      if (opt.queue) {\n        jQuery.dequeue(this, opt.queue);\n      }\n    };\n\n    return opt;\n  };\n\n  jQuery.fn.extend({\n    fadeTo: function fadeTo(speed, to, easing, callback) {\n\n      // Show any hidden elements after setting opacity to 0\n      return this.filter(isHiddenWithinTree).css('opacity', 0).show()\n\n      // Animate to the value specified\n      .end().animate({ opacity: to }, speed, easing, callback);\n    },\n    animate: function animate(prop, speed, easing, callback) {\n      var empty = jQuery.isEmptyObject(prop),\n          optall = jQuery.speed(speed, easing, callback),\n          doAnimation = function doAnimation() {\n\n        // Operate on a copy of prop so per-property easing won't be lost\n        var anim = Animation(this, jQuery.extend({}, prop), optall);\n\n        // Empty animations, or finishing resolves immediately\n        if (empty || dataPriv.get(this, 'finish')) {\n          anim.stop(true);\n        }\n      };\n      doAnimation.finish = doAnimation;\n\n      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);\n    },\n    stop: function stop(type, clearQueue, gotoEnd) {\n      var stopQueue = function stopQueue(hooks) {\n        var stop = hooks.stop;\n        delete hooks.stop;\n        stop(gotoEnd);\n      };\n\n      if (typeof type !== 'string') {\n        gotoEnd = clearQueue;\n        clearQueue = type;\n        type = undefined;\n      }\n      if (clearQueue && type !== false) {\n        this.queue(type || 'fx', []);\n      }\n\n      return this.each(function () {\n        var dequeue = true,\n            index = type != null && type + 'queueHooks',\n            timers = jQuery.timers,\n            data = dataPriv.get(this);\n\n        if (index) {\n          if (data[index] && data[index].stop) {\n            stopQueue(data[index]);\n          }\n        } else {\n          for (index in data) {\n            if (data[index] && data[index].stop && rrun.test(index)) {\n              stopQueue(data[index]);\n            }\n          }\n        }\n\n        for (index = timers.length; index--;) {\n          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {\n\n            timers[index].anim.stop(gotoEnd);\n            dequeue = false;\n            timers.splice(index, 1);\n          }\n        }\n\n        // Start the next in the queue if the last step wasn't forced.\n        // Timers currently will call their complete callbacks, which\n        // will dequeue but only if they were gotoEnd.\n        if (dequeue || !gotoEnd) {\n          jQuery.dequeue(this, type);\n        }\n      });\n    },\n    finish: function finish(type) {\n      if (type !== false) {\n        type = type || 'fx';\n      }\n      return this.each(function () {\n        var index,\n            data = dataPriv.get(this),\n            queue = data[type + 'queue'],\n            hooks = data[type + 'queueHooks'],\n            timers = jQuery.timers,\n            length = queue ? queue.length : 0;\n\n        // Enable finishing flag on private data\n        data.finish = true;\n\n        // Empty the queue first\n        jQuery.queue(this, type, []);\n\n        if (hooks && hooks.stop) {\n          hooks.stop.call(this, true);\n        }\n\n        // Look for any active animations, and finish them\n        for (index = timers.length; index--;) {\n          if (timers[index].elem === this && timers[index].queue === type) {\n            timers[index].anim.stop(true);\n            timers.splice(index, 1);\n          }\n        }\n\n        // Look for any animations in the old queue and finish them\n        for (index = 0; index < length; index++) {\n          if (queue[index] && queue[index].finish) {\n            queue[index].finish.call(this);\n          }\n        }\n\n        // Turn off finishing flag\n        delete data.finish;\n      });\n    }\n  });\n\n  jQuery.each(['toggle', 'show', 'hide'], function (i, name) {\n    var cssFn = jQuery.fn[name];\n    jQuery.fn[name] = function (speed, easing, callback) {\n      return speed == null || typeof speed === 'boolean' ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);\n    };\n  });\n\n  // Generate shortcuts for custom animations\n  jQuery.each({\n    slideDown: genFx('show'),\n    slideUp: genFx('hide'),\n    slideToggle: genFx('toggle'),\n    fadeIn: { opacity: 'show' },\n    fadeOut: { opacity: 'hide' },\n    fadeToggle: { opacity: 'toggle' }\n  }, function (name, props) {\n    jQuery.fn[name] = function (speed, easing, callback) {\n      return this.animate(props, speed, easing, callback);\n    };\n  });\n\n  jQuery.timers = [];\n  jQuery.fx.tick = function () {\n    var timer,\n        i = 0,\n        timers = jQuery.timers;\n\n    fxNow = Date.now();\n\n    for (; i < timers.length; i++) {\n      timer = timers[i];\n\n      // Run the timer and safely remove it when done (allowing for external removal)\n      if (!timer() && timers[i] === timer) {\n        timers.splice(i--, 1);\n      }\n    }\n\n    if (!timers.length) {\n      jQuery.fx.stop();\n    }\n    fxNow = undefined;\n  };\n\n  jQuery.fx.timer = function (timer) {\n    jQuery.timers.push(timer);\n    jQuery.fx.start();\n  };\n\n  jQuery.fx.interval = 13;\n  jQuery.fx.start = function () {\n    if (inProgress) {\n      return;\n    }\n\n    inProgress = true;\n    schedule();\n  };\n\n  jQuery.fx.stop = function () {\n    inProgress = null;\n  };\n\n  jQuery.fx.speeds = {\n    slow: 600,\n    fast: 200,\n\n    // Default speed\n    _default: 400\n  };\n\n  // Based off of the plugin by Clint Helfers, with permission.\n  // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\n  jQuery.fn.delay = function (time, type) {\n    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;\n    type = type || 'fx';\n\n    return this.queue(type, function (next, hooks) {\n      var timeout = window.setTimeout(next, time);\n      hooks.stop = function () {\n        window.clearTimeout(timeout);\n      };\n    });\n  };\n\n  (function () {\n    var input = document.createElement('input'),\n        select = document.createElement('select'),\n        opt = select.appendChild(document.createElement('option'));\n\n    input.type = 'checkbox';\n\n    // Support: Android <=4.3 only\n    // Default value for a checkbox should be \"on\"\n    support.checkOn = input.value !== '';\n\n    // Support: IE <=11 only\n    // Must access selectedIndex to make default options select\n    support.optSelected = opt.selected;\n\n    // Support: IE <=11 only\n    // An input loses its value after becoming a radio\n    input = document.createElement('input');\n    input.value = 't';\n    input.type = 'radio';\n    support.radioValue = input.value === 't';\n  })();\n\n  var boolHook,\n      attrHandle = jQuery.expr.attrHandle;\n\n  jQuery.fn.extend({\n    attr: function attr(name, value) {\n      return access(this, jQuery.attr, name, value, arguments.length > 1);\n    },\n\n    removeAttr: function removeAttr(name) {\n      return this.each(function () {\n        jQuery.removeAttr(this, name);\n      });\n    }\n  });\n\n  jQuery.extend({\n    attr: function attr(elem, name, value) {\n      var ret,\n          hooks,\n          nType = elem.nodeType;\n\n      // Don't get/set attributes on text, comment and attribute nodes\n      if (nType === 3 || nType === 8 || nType === 2) {\n        return;\n      }\n\n      // Fallback to prop when attributes are not supported\n      if (typeof elem.getAttribute === 'undefined') {\n        return jQuery.prop(elem, name, value);\n      }\n\n      // Attribute hooks are determined by the lowercase version\n      // Grab necessary hook if one is defined\n      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n        hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);\n      }\n\n      if (value !== undefined) {\n        if (value === null) {\n          jQuery.removeAttr(elem, name);\n          return;\n        }\n\n        if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n          return ret;\n        }\n\n        elem.setAttribute(name, value + '');\n        return value;\n      }\n\n      if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {\n        return ret;\n      }\n\n      ret = jQuery.find.attr(elem, name);\n\n      // Non-existent attributes return null, we normalize to undefined\n      return ret == null ? undefined : ret;\n    },\n\n    attrHooks: {\n      type: {\n        set: function set(elem, value) {\n          if (!support.radioValue && value === 'radio' && nodeName(elem, 'input')) {\n            var val = elem.value;\n            elem.setAttribute('type', value);\n            if (val) {\n              elem.value = val;\n            }\n            return value;\n          }\n        }\n      }\n    },\n\n    removeAttr: function removeAttr(elem, value) {\n      var name,\n          i = 0,\n\n\n      // Attribute names can contain non-HTML whitespace characters\n      // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n      attrNames = value && value.match(rnothtmlwhite);\n\n      if (attrNames && elem.nodeType === 1) {\n        while (name = attrNames[i++]) {\n          elem.removeAttribute(name);\n        }\n      }\n    }\n  });\n\n  // Hooks for boolean attributes\n  boolHook = {\n    set: function set(elem, value, name) {\n      if (value === false) {\n\n        // Remove boolean attributes when set to false\n        jQuery.removeAttr(elem, name);\n      } else {\n        elem.setAttribute(name, name);\n      }\n      return name;\n    }\n  };\n\n  jQuery.each(jQuery.expr.match.bool.source.match(/\\w+/g), function (i, name) {\n    var getter = attrHandle[name] || jQuery.find.attr;\n\n    attrHandle[name] = function (elem, name, isXML) {\n      var ret,\n          handle,\n          lowercaseName = name.toLowerCase();\n\n      if (!isXML) {\n\n        // Avoid an infinite loop by temporarily removing this function from the getter\n        handle = attrHandle[lowercaseName];\n        attrHandle[lowercaseName] = ret;\n        ret = getter(elem, name, isXML) != null ? lowercaseName : null;\n        attrHandle[lowercaseName] = handle;\n      }\n      return ret;\n    };\n  });\n\n  var rfocusable = /^(?:input|select|textarea|button)$/i,\n      rclickable = /^(?:a|area)$/i;\n\n  jQuery.fn.extend({\n    prop: function prop(name, value) {\n      return access(this, jQuery.prop, name, value, arguments.length > 1);\n    },\n\n    removeProp: function removeProp(name) {\n      return this.each(function () {\n        delete this[jQuery.propFix[name] || name];\n      });\n    }\n  });\n\n  jQuery.extend({\n    prop: function prop(elem, name, value) {\n      var ret,\n          hooks,\n          nType = elem.nodeType;\n\n      // Don't get/set properties on text, comment and attribute nodes\n      if (nType === 3 || nType === 8 || nType === 2) {\n        return;\n      }\n\n      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n\n        // Fix name and attach hooks\n        name = jQuery.propFix[name] || name;\n        hooks = jQuery.propHooks[name];\n      }\n\n      if (value !== undefined) {\n        if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n          return ret;\n        }\n\n        return elem[name] = value;\n      }\n\n      if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {\n        return ret;\n      }\n\n      return elem[name];\n    },\n\n    propHooks: {\n      tabIndex: {\n        get: function get(elem) {\n\n          // Support: IE <=9 - 11 only\n          // elem.tabIndex doesn't always return the\n          // correct value when it hasn't been explicitly set\n          // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n          // Use proper attribute retrieval(#12072)\n          var tabindex = jQuery.find.attr(elem, 'tabindex');\n\n          if (tabindex) {\n            return parseInt(tabindex, 10);\n          }\n\n          if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {\n            return 0;\n          }\n\n          return -1;\n        }\n      }\n    },\n\n    propFix: {\n      'for': 'htmlFor',\n      'class': 'className'\n    }\n  });\n\n  // Support: IE <=11 only\n  // Accessing the selectedIndex property\n  // forces the browser to respect setting selected\n  // on the option\n  // The getter ensures a default option is selected\n  // when in an optgroup\n  // eslint rule \"no-unused-expressions\" is disabled for this code\n  // since it considers such accessions noop\n  if (!support.optSelected) {\n    jQuery.propHooks.selected = {\n      get: function get(elem) {\n\n        /* eslint no-unused-expressions: \"off\" */\n\n        var parent = elem.parentNode;\n        if (parent && parent.parentNode) {\n          parent.parentNode.selectedIndex;\n        }\n        return null;\n      },\n      set: function set(elem) {\n\n        /* eslint no-unused-expressions: \"off\" */\n\n        var parent = elem.parentNode;\n        if (parent) {\n          parent.selectedIndex;\n\n          if (parent.parentNode) {\n            parent.parentNode.selectedIndex;\n          }\n        }\n      }\n    };\n  }\n\n  jQuery.each(['tabIndex', 'readOnly', 'maxLength', 'cellSpacing', 'cellPadding', 'rowSpan', 'colSpan', 'useMap', 'frameBorder', 'contentEditable'], function () {\n    jQuery.propFix[this.toLowerCase()] = this;\n  });\n\n  // Strip and collapse whitespace according to HTML spec\n  // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\n  function stripAndCollapse(value) {\n    var tokens = value.match(rnothtmlwhite) || [];\n    return tokens.join(' ');\n  }\n\n  function getClass(elem) {\n    return elem.getAttribute && elem.getAttribute('class') || '';\n  }\n\n  function classesToArray(value) {\n    if (Array.isArray(value)) {\n      return value;\n    }\n    if (typeof value === 'string') {\n      return value.match(rnothtmlwhite) || [];\n    }\n    return [];\n  }\n\n  jQuery.fn.extend({\n    addClass: function addClass(value) {\n      var classes,\n          elem,\n          cur,\n          curValue,\n          clazz,\n          j,\n          finalValue,\n          i = 0;\n\n      if (isFunction(value)) {\n        return this.each(function (j) {\n          jQuery(this).addClass(value.call(this, j, getClass(this)));\n        });\n      }\n\n      classes = classesToArray(value);\n\n      if (classes.length) {\n        while (elem = this[i++]) {\n          curValue = getClass(elem);\n          cur = elem.nodeType === 1 && ' ' + stripAndCollapse(curValue) + ' ';\n\n          if (cur) {\n            j = 0;\n            while (clazz = classes[j++]) {\n              if (cur.indexOf(' ' + clazz + ' ') < 0) {\n                cur += clazz + ' ';\n              }\n            }\n\n            // Only assign if different to avoid unneeded rendering.\n            finalValue = stripAndCollapse(cur);\n            if (curValue !== finalValue) {\n              elem.setAttribute('class', finalValue);\n            }\n          }\n        }\n      }\n\n      return this;\n    },\n\n    removeClass: function removeClass(value) {\n      var classes,\n          elem,\n          cur,\n          curValue,\n          clazz,\n          j,\n          finalValue,\n          i = 0;\n\n      if (isFunction(value)) {\n        return this.each(function (j) {\n          jQuery(this).removeClass(value.call(this, j, getClass(this)));\n        });\n      }\n\n      if (!arguments.length) {\n        return this.attr('class', '');\n      }\n\n      classes = classesToArray(value);\n\n      if (classes.length) {\n        while (elem = this[i++]) {\n          curValue = getClass(elem);\n\n          // This expression is here for better compressibility (see addClass)\n          cur = elem.nodeType === 1 && ' ' + stripAndCollapse(curValue) + ' ';\n\n          if (cur) {\n            j = 0;\n            while (clazz = classes[j++]) {\n\n              // Remove *all* instances\n              while (cur.indexOf(' ' + clazz + ' ') > -1) {\n                cur = cur.replace(' ' + clazz + ' ', ' ');\n              }\n            }\n\n            // Only assign if different to avoid unneeded rendering.\n            finalValue = stripAndCollapse(cur);\n            if (curValue !== finalValue) {\n              elem.setAttribute('class', finalValue);\n            }\n          }\n        }\n      }\n\n      return this;\n    },\n\n    toggleClass: function toggleClass(value, stateVal) {\n      var type = typeof value === 'undefined' ? 'undefined' : _typeof(value),\n          isValidValue = type === 'string' || Array.isArray(value);\n\n      if (typeof stateVal === 'boolean' && isValidValue) {\n        return stateVal ? this.addClass(value) : this.removeClass(value);\n      }\n\n      if (isFunction(value)) {\n        return this.each(function (i) {\n          jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);\n        });\n      }\n\n      return this.each(function () {\n        var className, i, self, classNames;\n\n        if (isValidValue) {\n\n          // Toggle individual class names\n          i = 0;\n          self = jQuery(this);\n          classNames = classesToArray(value);\n\n          while (className = classNames[i++]) {\n\n            // Check each className given, space separated list\n            if (self.hasClass(className)) {\n              self.removeClass(className);\n            } else {\n              self.addClass(className);\n            }\n          }\n\n          // Toggle whole class name\n        } else if (value === undefined || type === 'boolean') {\n          className = getClass(this);\n          if (className) {\n\n            // Store className if set\n            dataPriv.set(this, '__className__', className);\n          }\n\n          // If the element has a class name or if we're passed `false`,\n          // then remove the whole classname (if there was one, the above saved it).\n          // Otherwise bring back whatever was previously saved (if anything),\n          // falling back to the empty string if nothing was stored.\n          if (this.setAttribute) {\n            this.setAttribute('class', className || value === false ? '' : dataPriv.get(this, '__className__') || '');\n          }\n        }\n      });\n    },\n\n    hasClass: function hasClass(selector) {\n      var className,\n          elem,\n          i = 0;\n\n      className = ' ' + selector + ' ';\n      while (elem = this[i++]) {\n        if (elem.nodeType === 1 && (' ' + stripAndCollapse(getClass(elem)) + ' ').indexOf(className) > -1) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  });\n\n  var rreturn = /\\r/g;\n\n  jQuery.fn.extend({\n    val: function val(value) {\n      var hooks,\n          ret,\n          valueIsFunction,\n          elem = this[0];\n\n      if (!arguments.length) {\n        if (elem) {\n          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];\n\n          if (hooks && 'get' in hooks && (ret = hooks.get(elem, 'value')) !== undefined) {\n            return ret;\n          }\n\n          ret = elem.value;\n\n          // Handle most common string cases\n          if (typeof ret === 'string') {\n            return ret.replace(rreturn, '');\n          }\n\n          // Handle cases where value is null/undef or number\n          return ret == null ? '' : ret;\n        }\n\n        return;\n      }\n\n      valueIsFunction = isFunction(value);\n\n      return this.each(function (i) {\n        var val;\n\n        if (this.nodeType !== 1) {\n          return;\n        }\n\n        if (valueIsFunction) {\n          val = value.call(this, i, jQuery(this).val());\n        } else {\n          val = value;\n        }\n\n        // Treat null/undefined as \"\"; convert numbers to string\n        if (val == null) {\n          val = '';\n        } else if (typeof val === 'number') {\n          val += '';\n        } else if (Array.isArray(val)) {\n          val = jQuery.map(val, function (value) {\n            return value == null ? '' : value + '';\n          });\n        }\n\n        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];\n\n        // If set returns undefined, fall back to normal setting\n        if (!hooks || !('set' in hooks) || hooks.set(this, val, 'value') === undefined) {\n          this.value = val;\n        }\n      });\n    }\n  });\n\n  jQuery.extend({\n    valHooks: {\n      option: {\n        get: function get(elem) {\n\n          var val = jQuery.find.attr(elem, 'value');\n          return val != null ? val :\n\n          // Support: IE <=10 - 11 only\n          // option.text throws exceptions (#14686, #14858)\n          // Strip and collapse whitespace\n          // https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n          stripAndCollapse(jQuery.text(elem));\n        }\n      },\n      select: {\n        get: function get(elem) {\n          var value,\n              option,\n              i,\n              options = elem.options,\n              index = elem.selectedIndex,\n              one = elem.type === 'select-one',\n              values = one ? null : [],\n              max = one ? index + 1 : options.length;\n\n          if (index < 0) {\n            i = max;\n          } else {\n            i = one ? index : 0;\n          }\n\n          // Loop through all the selected options\n          for (; i < max; i++) {\n            option = options[i];\n\n            // Support: IE <=9 only\n            // IE8-9 doesn't update selected after form reset (#2551)\n            if ((option.selected || i === index) &&\n\n            // Don't return options that are disabled or in a disabled optgroup\n            !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, 'optgroup'))) {\n\n              // Get the specific value for the option\n              value = jQuery(option).val();\n\n              // We don't need an array for one selects\n              if (one) {\n                return value;\n              }\n\n              // Multi-Selects return an array\n              values.push(value);\n            }\n          }\n\n          return values;\n        },\n\n        set: function set(elem, value) {\n          var optionSet,\n              option,\n              options = elem.options,\n              values = jQuery.makeArray(value),\n              i = options.length;\n\n          while (i--) {\n            option = options[i];\n\n            /* eslint-disable no-cond-assign */\n\n            if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {\n              optionSet = true;\n            }\n\n            /* eslint-enable no-cond-assign */\n          }\n\n          // Force browsers to behave consistently when non-matching value is set\n          if (!optionSet) {\n            elem.selectedIndex = -1;\n          }\n          return values;\n        }\n      }\n    }\n  });\n\n  // Radios and checkboxes getter/setter\n  jQuery.each(['radio', 'checkbox'], function () {\n    jQuery.valHooks[this] = {\n      set: function set(elem, value) {\n        if (Array.isArray(value)) {\n          return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;\n        }\n      }\n    };\n    if (!support.checkOn) {\n      jQuery.valHooks[this].get = function (elem) {\n        return elem.getAttribute('value') === null ? 'on' : elem.value;\n      };\n    }\n  });\n\n  // Return jQuery for attributes-only inclusion\n\n\n  support.focusin = 'onfocusin' in window;\n\n  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n      stopPropagationCallback = function stopPropagationCallback(e) {\n    e.stopPropagation();\n  };\n\n  jQuery.extend(jQuery.event, {\n\n    trigger: function trigger(event, data, elem, onlyHandlers) {\n\n      var i,\n          cur,\n          tmp,\n          bubbleType,\n          ontype,\n          handle,\n          special,\n          lastElement,\n          eventPath = [elem || document],\n          type = hasOwn.call(event, 'type') ? event.type : event,\n          namespaces = hasOwn.call(event, 'namespace') ? event.namespace.split('.') : [];\n\n      cur = lastElement = tmp = elem = elem || document;\n\n      // Don't do events on text and comment nodes\n      if (elem.nodeType === 3 || elem.nodeType === 8) {\n        return;\n      }\n\n      // focus/blur morphs to focusin/out; ensure we're not firing them right now\n      if (rfocusMorph.test(type + jQuery.event.triggered)) {\n        return;\n      }\n\n      if (type.indexOf('.') > -1) {\n\n        // Namespaced trigger; create a regexp to match event type in handle()\n        namespaces = type.split('.');\n        type = namespaces.shift();\n        namespaces.sort();\n      }\n      ontype = type.indexOf(':') < 0 && 'on' + type;\n\n      // Caller can pass in a jQuery.Event object, Object, or just an event type string\n      event = event[jQuery.expando] ? event : new jQuery.Event(type, (typeof event === 'undefined' ? 'undefined' : _typeof(event)) === 'object' && event);\n\n      // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n      event.isTrigger = onlyHandlers ? 2 : 3;\n      event.namespace = namespaces.join('.');\n      event.rnamespace = event.namespace ? new RegExp('(^|\\\\.)' + namespaces.join('\\\\.(?:.*\\\\.|)') + '(\\\\.|$)') : null;\n\n      // Clean up the event in case it is being reused\n      event.result = undefined;\n      if (!event.target) {\n        event.target = elem;\n      }\n\n      // Clone any incoming data and prepend the event, creating the handler arg list\n      data = data == null ? [event] : jQuery.makeArray(data, [event]);\n\n      // Allow special events to draw outside the lines\n      special = jQuery.event.special[type] || {};\n      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {\n        return;\n      }\n\n      // Determine event propagation path in advance, per W3C events spec (#9951)\n      // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n      if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {\n\n        bubbleType = special.delegateType || type;\n        if (!rfocusMorph.test(bubbleType + type)) {\n          cur = cur.parentNode;\n        }\n        for (; cur; cur = cur.parentNode) {\n          eventPath.push(cur);\n          tmp = cur;\n        }\n\n        // Only add window if we got to document (e.g., not plain obj or detached DOM)\n        if (tmp === (elem.ownerDocument || document)) {\n          eventPath.push(tmp.defaultView || tmp.parentWindow || window);\n        }\n      }\n\n      // Fire handlers on the event path\n      i = 0;\n      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {\n        lastElement = cur;\n        event.type = i > 1 ? bubbleType : special.bindType || type;\n\n        // jQuery handler\n        handle = (dataPriv.get(cur, 'events') || {})[event.type] && dataPriv.get(cur, 'handle');\n        if (handle) {\n          handle.apply(cur, data);\n        }\n\n        // Native handler\n        handle = ontype && cur[ontype];\n        if (handle && handle.apply && acceptData(cur)) {\n          event.result = handle.apply(cur, data);\n          if (event.result === false) {\n            event.preventDefault();\n          }\n        }\n      }\n      event.type = type;\n\n      // If nobody prevented the default action, do it now\n      if (!onlyHandlers && !event.isDefaultPrevented()) {\n\n        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {\n\n          // Call a native DOM method on the target with the same name as the event.\n          // Don't do default actions on window, that's where global variables be (#6170)\n          if (ontype && isFunction(elem[type]) && !isWindow(elem)) {\n\n            // Don't re-trigger an onFOO event when we call its FOO() method\n            tmp = elem[ontype];\n\n            if (tmp) {\n              elem[ontype] = null;\n            }\n\n            // Prevent re-triggering of the same event, since we already bubbled it above\n            jQuery.event.triggered = type;\n\n            if (event.isPropagationStopped()) {\n              lastElement.addEventListener(type, stopPropagationCallback);\n            }\n\n            elem[type]();\n\n            if (event.isPropagationStopped()) {\n              lastElement.removeEventListener(type, stopPropagationCallback);\n            }\n\n            jQuery.event.triggered = undefined;\n\n            if (tmp) {\n              elem[ontype] = tmp;\n            }\n          }\n        }\n      }\n\n      return event.result;\n    },\n\n    // Piggyback on a donor event to simulate a different one\n    // Used only for `focus(in | out)` events\n    simulate: function simulate(type, elem, event) {\n      var e = jQuery.extend(new jQuery.Event(), event, {\n        type: type,\n        isSimulated: true\n      });\n\n      jQuery.event.trigger(e, null, elem);\n    }\n\n  });\n\n  jQuery.fn.extend({\n\n    trigger: function trigger(type, data) {\n      return this.each(function () {\n        jQuery.event.trigger(type, data, this);\n      });\n    },\n    triggerHandler: function triggerHandler(type, data) {\n      var elem = this[0];\n      if (elem) {\n        return jQuery.event.trigger(type, data, elem, true);\n      }\n    }\n  });\n\n  // Support: Firefox <=44\n  // Firefox doesn't have focus(in | out) events\n  // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n  //\n  // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n  // focus(in | out) events fire after focus & blur events,\n  // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n  // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\n  if (!support.focusin) {\n    jQuery.each({ focus: 'focusin', blur: 'focusout' }, function (orig, fix) {\n\n      // Attach a single capturing handler on the document while someone wants focusin/focusout\n      var handler = function handler(event) {\n        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));\n      };\n\n      jQuery.event.special[fix] = {\n        setup: function setup() {\n          var doc = this.ownerDocument || this,\n              attaches = dataPriv.access(doc, fix);\n\n          if (!attaches) {\n            doc.addEventListener(orig, handler, true);\n          }\n          dataPriv.access(doc, fix, (attaches || 0) + 1);\n        },\n        teardown: function teardown() {\n          var doc = this.ownerDocument || this,\n              attaches = dataPriv.access(doc, fix) - 1;\n\n          if (!attaches) {\n            doc.removeEventListener(orig, handler, true);\n            dataPriv.remove(doc, fix);\n          } else {\n            dataPriv.access(doc, fix, attaches);\n          }\n        }\n      };\n    });\n  }\n  var location = window.location;\n\n  var nonce = Date.now();\n\n  var rquery = /\\?/;\n\n  // Cross-browser xml parsing\n  jQuery.parseXML = function (data) {\n    var xml;\n    if (!data || typeof data !== 'string') {\n      return null;\n    }\n\n    // Support: IE 9 - 11 only\n    // IE throws on parseFromString with invalid input.\n    try {\n      xml = new window.DOMParser().parseFromString(data, 'text/xml');\n    } catch (e) {\n      xml = undefined;\n    }\n\n    if (!xml || xml.getElementsByTagName('parsererror').length) {\n      jQuery.error('Invalid XML: ' + data);\n    }\n    return xml;\n  };\n\n  var rbracket = /\\[\\]$/,\n      rCRLF = /\\r?\\n/g,\n      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n      rsubmittable = /^(?:input|select|textarea|keygen)/i;\n\n  function buildParams(prefix, obj, traditional, add) {\n    var name;\n\n    if (Array.isArray(obj)) {\n\n      // Serialize array item.\n      jQuery.each(obj, function (i, v) {\n        if (traditional || rbracket.test(prefix)) {\n\n          // Treat each array item as a scalar.\n          add(prefix, v);\n        } else {\n\n          // Item is non-scalar (array or object), encode its numeric index.\n          buildParams(prefix + '[' + ((typeof v === 'undefined' ? 'undefined' : _typeof(v)) === 'object' && v != null ? i : '') + ']', v, traditional, add);\n        }\n      });\n    } else if (!traditional && toType(obj) === 'object') {\n\n      // Serialize object item.\n      for (name in obj) {\n        buildParams(prefix + '[' + name + ']', obj[name], traditional, add);\n      }\n    } else {\n\n      // Serialize scalar item.\n      add(prefix, obj);\n    }\n  }\n\n  // Serialize an array of form elements or a set of\n  // key/values into a query string\n  jQuery.param = function (a, traditional) {\n    var prefix,\n        s = [],\n        add = function add(key, valueOrFunction) {\n\n      // If value is a function, invoke it and use its return value\n      var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;\n\n      s[s.length] = encodeURIComponent(key) + '=' + encodeURIComponent(value == null ? '' : value);\n    };\n\n    // If an array was passed in, assume that it is an array of form elements.\n    if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {\n\n      // Serialize the form elements\n      jQuery.each(a, function () {\n        add(this.name, this.value);\n      });\n    } else {\n\n      // If traditional, encode the \"old\" way (the way 1.3.2 or older\n      // did it), otherwise encode params recursively.\n      for (prefix in a) {\n        buildParams(prefix, a[prefix], traditional, add);\n      }\n    }\n\n    // Return the resulting serialization\n    return s.join('&');\n  };\n\n  jQuery.fn.extend({\n    serialize: function serialize() {\n      return jQuery.param(this.serializeArray());\n    },\n    serializeArray: function serializeArray() {\n      return this.map(function () {\n\n        // Can add propHook for \"elements\" to filter or add form elements\n        var elements = jQuery.prop(this, 'elements');\n        return elements ? jQuery.makeArray(elements) : this;\n      }).filter(function () {\n        var type = this.type;\n\n        // Use .is( \":disabled\" ) so that fieldset[disabled] works\n        return this.name && !jQuery(this).is(':disabled') && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));\n      }).map(function (i, elem) {\n        var val = jQuery(this).val();\n\n        if (val == null) {\n          return null;\n        }\n\n        if (Array.isArray(val)) {\n          return jQuery.map(val, function (val) {\n            return { name: elem.name, value: val.replace(rCRLF, '\\r\\n') };\n          });\n        }\n\n        return { name: elem.name, value: val.replace(rCRLF, '\\r\\n') };\n      }).get();\n    }\n  });\n\n  var r20 = /%20/g,\n      rhash = /#.*$/,\n      rantiCache = /([?&])_=[^&]*/,\n      rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\n  // #7653, #8125, #8152: local protocol detection\n  rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n      rnoContent = /^(?:GET|HEAD)$/,\n      rprotocol = /^\\/\\//,\n\n\n  /* Prefilters\n  * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n  * 2) These are called:\n  *    - BEFORE asking for a transport\n  *    - AFTER param serialization (s.data is a string if s.processData is true)\n  * 3) key is the dataType\n  * 4) the catchall symbol \"*\" can be used\n  * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n  */\n  prefilters = {},\n\n\n  /* Transports bindings\n  * 1) key is the dataType\n  * 2) the catchall symbol \"*\" can be used\n  * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n  */\n  transports = {},\n\n\n  // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n  allTypes = '*/'.concat('*'),\n\n\n  // Anchor tag for parsing the document origin\n  originAnchor = document.createElement('a');\n  originAnchor.href = location.href;\n\n  // Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n  function addToPrefiltersOrTransports(structure) {\n\n    // dataTypeExpression is optional and defaults to \"*\"\n    return function (dataTypeExpression, func) {\n\n      if (typeof dataTypeExpression !== 'string') {\n        func = dataTypeExpression;\n        dataTypeExpression = '*';\n      }\n\n      var dataType,\n          i = 0,\n          dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];\n\n      if (isFunction(func)) {\n\n        // For each dataType in the dataTypeExpression\n        while (dataType = dataTypes[i++]) {\n\n          // Prepend if requested\n          if (dataType[0] === '+') {\n            dataType = dataType.slice(1) || '*';\n            (structure[dataType] = structure[dataType] || []).unshift(func);\n\n            // Otherwise append\n          } else {\n            (structure[dataType] = structure[dataType] || []).push(func);\n          }\n        }\n      }\n    };\n  }\n\n  // Base inspection function for prefilters and transports\n  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {\n\n    var inspected = {},\n        seekingTransport = structure === transports;\n\n    function inspect(dataType) {\n      var selected;\n      inspected[dataType] = true;\n      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {\n        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);\n        if (typeof dataTypeOrTransport === 'string' && !seekingTransport && !inspected[dataTypeOrTransport]) {\n\n          options.dataTypes.unshift(dataTypeOrTransport);\n          inspect(dataTypeOrTransport);\n          return false;\n        } else if (seekingTransport) {\n          return !(selected = dataTypeOrTransport);\n        }\n      });\n      return selected;\n    }\n\n    return inspect(options.dataTypes[0]) || !inspected['*'] && inspect('*');\n  }\n\n  // A special extend for ajax options\n  // that takes \"flat\" options (not to be deep extended)\n  // Fixes #9887\n  function ajaxExtend(target, src) {\n    var key,\n        deep,\n        flatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n    for (key in src) {\n      if (src[key] !== undefined) {\n        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];\n      }\n    }\n    if (deep) {\n      jQuery.extend(true, target, deep);\n    }\n\n    return target;\n  }\n\n  /* Handles responses to an ajax request:\n  * - finds the right dataType (mediates between content-type and expected dataType)\n  * - returns the corresponding response\n  */\n  function ajaxHandleResponses(s, jqXHR, responses) {\n\n    var ct,\n        type,\n        finalDataType,\n        firstDataType,\n        contents = s.contents,\n        dataTypes = s.dataTypes;\n\n    // Remove auto dataType and get content-type in the process\n    while (dataTypes[0] === '*') {\n      dataTypes.shift();\n      if (ct === undefined) {\n        ct = s.mimeType || jqXHR.getResponseHeader('Content-Type');\n      }\n    }\n\n    // Check if we're dealing with a known content-type\n    if (ct) {\n      for (type in contents) {\n        if (contents[type] && contents[type].test(ct)) {\n          dataTypes.unshift(type);\n          break;\n        }\n      }\n    }\n\n    // Check to see if we have a response for the expected dataType\n    if (dataTypes[0] in responses) {\n      finalDataType = dataTypes[0];\n    } else {\n\n      // Try convertible dataTypes\n      for (type in responses) {\n        if (!dataTypes[0] || s.converters[type + ' ' + dataTypes[0]]) {\n          finalDataType = type;\n          break;\n        }\n        if (!firstDataType) {\n          firstDataType = type;\n        }\n      }\n\n      // Or just use first one\n      finalDataType = finalDataType || firstDataType;\n    }\n\n    // If we found a dataType\n    // We add the dataType to the list if needed\n    // and return the corresponding response\n    if (finalDataType) {\n      if (finalDataType !== dataTypes[0]) {\n        dataTypes.unshift(finalDataType);\n      }\n      return responses[finalDataType];\n    }\n  }\n\n  /* Chain conversions given the request and the original response\n  * Also sets the responseXXX fields on the jqXHR instance\n  */\n  function ajaxConvert(s, response, jqXHR, isSuccess) {\n    var conv2,\n        current,\n        conv,\n        tmp,\n        prev,\n        converters = {},\n\n\n    // Work with a copy of dataTypes in case we need to modify it for conversion\n    dataTypes = s.dataTypes.slice();\n\n    // Create converters map with lowercased keys\n    if (dataTypes[1]) {\n      for (conv in s.converters) {\n        converters[conv.toLowerCase()] = s.converters[conv];\n      }\n    }\n\n    current = dataTypes.shift();\n\n    // Convert to each sequential dataType\n    while (current) {\n\n      if (s.responseFields[current]) {\n        jqXHR[s.responseFields[current]] = response;\n      }\n\n      // Apply the dataFilter if provided\n      if (!prev && isSuccess && s.dataFilter) {\n        response = s.dataFilter(response, s.dataType);\n      }\n\n      prev = current;\n      current = dataTypes.shift();\n\n      if (current) {\n\n        // There's only work to do if current dataType is non-auto\n        if (current === '*') {\n\n          current = prev;\n\n          // Convert response if prev dataType is non-auto and differs from current\n        } else if (prev !== '*' && prev !== current) {\n\n          // Seek a direct converter\n          conv = converters[prev + ' ' + current] || converters['* ' + current];\n\n          // If none found, seek a pair\n          if (!conv) {\n            for (conv2 in converters) {\n\n              // If conv2 outputs current\n              tmp = conv2.split(' ');\n              if (tmp[1] === current) {\n\n                // If prev can be converted to accepted input\n                conv = converters[prev + ' ' + tmp[0]] || converters['* ' + tmp[0]];\n                if (conv) {\n\n                  // Condense equivalence converters\n                  if (conv === true) {\n                    conv = converters[conv2];\n\n                    // Otherwise, insert the intermediate dataType\n                  } else if (converters[conv2] !== true) {\n                    current = tmp[0];\n                    dataTypes.unshift(tmp[1]);\n                  }\n                  break;\n                }\n              }\n            }\n          }\n\n          // Apply converter (if not an equivalence)\n          if (conv !== true) {\n\n            // Unless errors are allowed to bubble, catch and return them\n            if (conv && s.throws) {\n              response = conv(response);\n            } else {\n              try {\n                response = conv(response);\n              } catch (e) {\n                return {\n                  state: 'parsererror',\n                  error: conv ? e : 'No conversion from ' + prev + ' to ' + current\n                };\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return { state: 'success', data: response };\n  }\n\n  jQuery.extend({\n\n    // Counter for holding the number of active queries\n    active: 0,\n\n    // Last-Modified header cache for next request\n    lastModified: {},\n    etag: {},\n\n    ajaxSettings: {\n      url: location.href,\n      type: 'GET',\n      isLocal: rlocalProtocol.test(location.protocol),\n      global: true,\n      processData: true,\n      async: true,\n      contentType: 'application/x-www-form-urlencoded; charset=UTF-8',\n\n      /*\n      timeout: 0,\n      data: null,\n      dataType: null,\n      username: null,\n      password: null,\n      cache: null,\n      throws: false,\n      traditional: false,\n      headers: {},\n      */\n\n      accepts: {\n        '*': allTypes,\n        text: 'text/plain',\n        html: 'text/html',\n        xml: 'application/xml, text/xml',\n        json: 'application/json, text/javascript'\n      },\n\n      contents: {\n        xml: /\\bxml\\b/,\n        html: /\\bhtml/,\n        json: /\\bjson\\b/\n      },\n\n      responseFields: {\n        xml: 'responseXML',\n        text: 'responseText',\n        json: 'responseJSON'\n      },\n\n      // Data converters\n      // Keys separate source (or catchall \"*\") and destination types with a single space\n      converters: {\n\n        // Convert anything to text\n        '* text': String,\n\n        // Text to html (true = no transformation)\n        'text html': true,\n\n        // Evaluate text as a json expression\n        'text json': JSON.parse,\n\n        // Parse text as xml\n        'text xml': jQuery.parseXML\n      },\n\n      // For options that shouldn't be deep extended:\n      // you can add your own custom options here if\n      // and when you create one that shouldn't be\n      // deep extended (see ajaxExtend)\n      flatOptions: {\n        url: true,\n        context: true\n      }\n    },\n\n    // Creates a full fledged settings object into target\n    // with both ajaxSettings and settings fields.\n    // If target is omitted, writes into ajaxSettings.\n    ajaxSetup: function ajaxSetup(target, settings) {\n      return settings ?\n\n      // Building a settings object\n      ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :\n\n      // Extending ajaxSettings\n      ajaxExtend(jQuery.ajaxSettings, target);\n    },\n\n    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),\n    ajaxTransport: addToPrefiltersOrTransports(transports),\n\n    // Main method\n    ajax: function ajax(url, options) {\n\n      // If url is an object, simulate pre-1.5 signature\n      if ((typeof url === 'undefined' ? 'undefined' : _typeof(url)) === 'object') {\n        options = url;\n        url = undefined;\n      }\n\n      // Force options to be an object\n      options = options || {};\n\n      var transport,\n\n\n      // URL without anti-cache param\n      cacheURL,\n\n\n      // Response headers\n      responseHeadersString,\n          responseHeaders,\n\n\n      // timeout handle\n      timeoutTimer,\n\n\n      // Url cleanup var\n      urlAnchor,\n\n\n      // Request state (becomes false upon send and true upon completion)\n      completed,\n\n\n      // To know if global events are to be dispatched\n      fireGlobals,\n\n\n      // Loop variable\n      i,\n\n\n      // uncached part of the url\n      uncached,\n\n\n      // Create the final options object\n      s = jQuery.ajaxSetup({}, options),\n\n\n      // Callbacks context\n      callbackContext = s.context || s,\n\n\n      // Context for global events is callbackContext if it is a DOM node or jQuery collection\n      globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,\n\n\n      // Deferreds\n      deferred = jQuery.Deferred(),\n          completeDeferred = jQuery.Callbacks('once memory'),\n\n\n      // Status-dependent callbacks\n      _statusCode = s.statusCode || {},\n\n\n      // Headers (they are sent all at once)\n      requestHeaders = {},\n          requestHeadersNames = {},\n\n\n      // Default abort message\n      strAbort = 'canceled',\n\n\n      // Fake xhr\n      jqXHR = {\n        readyState: 0,\n\n        // Builds headers hashtable if needed\n        getResponseHeader: function getResponseHeader(key) {\n          var match;\n          if (completed) {\n            if (!responseHeaders) {\n              responseHeaders = {};\n              while (match = rheaders.exec(responseHeadersString)) {\n                responseHeaders[match[1].toLowerCase()] = match[2];\n              }\n            }\n            match = responseHeaders[key.toLowerCase()];\n          }\n          return match == null ? null : match;\n        },\n\n        // Raw string\n        getAllResponseHeaders: function getAllResponseHeaders() {\n          return completed ? responseHeadersString : null;\n        },\n\n        // Caches the header\n        setRequestHeader: function setRequestHeader(name, value) {\n          if (completed == null) {\n            name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;\n            requestHeaders[name] = value;\n          }\n          return this;\n        },\n\n        // Overrides response content-type header\n        overrideMimeType: function overrideMimeType(type) {\n          if (completed == null) {\n            s.mimeType = type;\n          }\n          return this;\n        },\n\n        // Status-dependent callbacks\n        statusCode: function statusCode(map) {\n          var code;\n          if (map) {\n            if (completed) {\n\n              // Execute the appropriate callbacks\n              jqXHR.always(map[jqXHR.status]);\n            } else {\n\n              // Lazy-add the new callbacks in a way that preserves old ones\n              for (code in map) {\n                _statusCode[code] = [_statusCode[code], map[code]];\n              }\n            }\n          }\n          return this;\n        },\n\n        // Cancel the request\n        abort: function abort(statusText) {\n          var finalText = statusText || strAbort;\n          if (transport) {\n            transport.abort(finalText);\n          }\n          done(0, finalText);\n          return this;\n        }\n      };\n\n      // Attach deferreds\n      deferred.promise(jqXHR);\n\n      // Add protocol if not provided (prefilters might expect it)\n      // Handle falsy url in the settings object (#10093: consistency with old signature)\n      // We also use the url parameter if available\n      s.url = ((url || s.url || location.href) + '').replace(rprotocol, location.protocol + '//');\n\n      // Alias method option to type as per ticket #12004\n      s.type = options.method || options.type || s.method || s.type;\n\n      // Extract dataTypes list\n      s.dataTypes = (s.dataType || '*').toLowerCase().match(rnothtmlwhite) || [''];\n\n      // A cross-domain request is in order when the origin doesn't match the current origin.\n      if (s.crossDomain == null) {\n        urlAnchor = document.createElement('a');\n\n        // Support: IE <=8 - 11, Edge 12 - 15\n        // IE throws exception on accessing the href property if url is malformed,\n        // e.g. http://example.com:80x/\n        try {\n          urlAnchor.href = s.url;\n\n          // Support: IE <=8 - 11 only\n          // Anchor's host property isn't correctly set when s.url is relative\n          urlAnchor.href = urlAnchor.href;\n          s.crossDomain = originAnchor.protocol + '//' + originAnchor.host !== urlAnchor.protocol + '//' + urlAnchor.host;\n        } catch (e) {\n\n          // If there is an error parsing the URL, assume it is crossDomain,\n          // it can be rejected by the transport if it is invalid\n          s.crossDomain = true;\n        }\n      }\n\n      // Convert data if not already a string\n      if (s.data && s.processData && typeof s.data !== 'string') {\n        s.data = jQuery.param(s.data, s.traditional);\n      }\n\n      // Apply prefilters\n      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);\n\n      // If request was aborted inside a prefilter, stop there\n      if (completed) {\n        return jqXHR;\n      }\n\n      // We can fire global events as of now if asked to\n      // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n      fireGlobals = jQuery.event && s.global;\n\n      // Watch for a new set of requests\n      if (fireGlobals && jQuery.active++ === 0) {\n        jQuery.event.trigger('ajaxStart');\n      }\n\n      // Uppercase the type\n      s.type = s.type.toUpperCase();\n\n      // Determine if request has content\n      s.hasContent = !rnoContent.test(s.type);\n\n      // Save the URL in case we're toying with the If-Modified-Since\n      // and/or If-None-Match header later on\n      // Remove hash to simplify url manipulation\n      cacheURL = s.url.replace(rhash, '');\n\n      // More options handling for requests with no content\n      if (!s.hasContent) {\n\n        // Remember the hash so we can put it back\n        uncached = s.url.slice(cacheURL.length);\n\n        // If data is available and should be processed, append data to url\n        if (s.data && (s.processData || typeof s.data === 'string')) {\n          cacheURL += (rquery.test(cacheURL) ? '&' : '?') + s.data;\n\n          // #9682: remove data so that it's not used in an eventual retry\n          delete s.data;\n        }\n\n        // Add or update anti-cache param if needed\n        if (s.cache === false) {\n          cacheURL = cacheURL.replace(rantiCache, '$1');\n          uncached = (rquery.test(cacheURL) ? '&' : '?') + '_=' + nonce++ + uncached;\n        }\n\n        // Put hash and anti-cache on the URL that will be requested (gh-1732)\n        s.url = cacheURL + uncached;\n\n        // Change '%20' to '+' if this is encoded form body content (gh-2658)\n      } else if (s.data && s.processData && (s.contentType || '').indexOf('application/x-www-form-urlencoded') === 0) {\n        s.data = s.data.replace(r20, '+');\n      }\n\n      // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n      if (s.ifModified) {\n        if (jQuery.lastModified[cacheURL]) {\n          jqXHR.setRequestHeader('If-Modified-Since', jQuery.lastModified[cacheURL]);\n        }\n        if (jQuery.etag[cacheURL]) {\n          jqXHR.setRequestHeader('If-None-Match', jQuery.etag[cacheURL]);\n        }\n      }\n\n      // Set the correct header, if data is being sent\n      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {\n        jqXHR.setRequestHeader('Content-Type', s.contentType);\n      }\n\n      // Set the Accepts header for the server, depending on the dataType\n      jqXHR.setRequestHeader('Accept', s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== '*' ? ', ' + allTypes + '; q=0.01' : '') : s.accepts['*']);\n\n      // Check for headers option\n      for (i in s.headers) {\n        jqXHR.setRequestHeader(i, s.headers[i]);\n      }\n\n      // Allow custom headers/mimetypes and early abort\n      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {\n\n        // Abort if not done already and return\n        return jqXHR.abort();\n      }\n\n      // Aborting is no longer a cancellation\n      strAbort = 'abort';\n\n      // Install callbacks on deferreds\n      completeDeferred.add(s.complete);\n      jqXHR.done(s.success);\n      jqXHR.fail(s.error);\n\n      // Get transport\n      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);\n\n      // If no transport, we auto-abort\n      if (!transport) {\n        done(-1, 'No Transport');\n      } else {\n        jqXHR.readyState = 1;\n\n        // Send global event\n        if (fireGlobals) {\n          globalEventContext.trigger('ajaxSend', [jqXHR, s]);\n        }\n\n        // If request was aborted inside ajaxSend, stop there\n        if (completed) {\n          return jqXHR;\n        }\n\n        // Timeout\n        if (s.async && s.timeout > 0) {\n          timeoutTimer = window.setTimeout(function () {\n            jqXHR.abort('timeout');\n          }, s.timeout);\n        }\n\n        try {\n          completed = false;\n          transport.send(requestHeaders, done);\n        } catch (e) {\n\n          // Rethrow post-completion exceptions\n          if (completed) {\n            throw e;\n          }\n\n          // Propagate others as results\n          done(-1, e);\n        }\n      }\n\n      // Callback for when everything is done\n      function done(status, nativeStatusText, responses, headers) {\n        var isSuccess,\n            success,\n            error,\n            response,\n            modified,\n            statusText = nativeStatusText;\n\n        // Ignore repeat invocations\n        if (completed) {\n          return;\n        }\n\n        completed = true;\n\n        // Clear timeout if it exists\n        if (timeoutTimer) {\n          window.clearTimeout(timeoutTimer);\n        }\n\n        // Dereference transport for early garbage collection\n        // (no matter how long the jqXHR object will be used)\n        transport = undefined;\n\n        // Cache response headers\n        responseHeadersString = headers || '';\n\n        // Set readyState\n        jqXHR.readyState = status > 0 ? 4 : 0;\n\n        // Determine if successful\n        isSuccess = status >= 200 && status < 300 || status === 304;\n\n        // Get response data\n        if (responses) {\n          response = ajaxHandleResponses(s, jqXHR, responses);\n        }\n\n        // Convert no matter what (that way responseXXX fields are always set)\n        response = ajaxConvert(s, response, jqXHR, isSuccess);\n\n        // If successful, handle type chaining\n        if (isSuccess) {\n\n          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n          if (s.ifModified) {\n            modified = jqXHR.getResponseHeader('Last-Modified');\n            if (modified) {\n              jQuery.lastModified[cacheURL] = modified;\n            }\n            modified = jqXHR.getResponseHeader('etag');\n            if (modified) {\n              jQuery.etag[cacheURL] = modified;\n            }\n          }\n\n          // if no content\n          if (status === 204 || s.type === 'HEAD') {\n            statusText = 'nocontent';\n\n            // if not modified\n          } else if (status === 304) {\n            statusText = 'notmodified';\n\n            // If we have data, let's convert it\n          } else {\n            statusText = response.state;\n            success = response.data;\n            error = response.error;\n            isSuccess = !error;\n          }\n        } else {\n\n          // Extract error from statusText and normalize for non-aborts\n          error = statusText;\n          if (status || !statusText) {\n            statusText = 'error';\n            if (status < 0) {\n              status = 0;\n            }\n          }\n        }\n\n        // Set data for the fake xhr object\n        jqXHR.status = status;\n        jqXHR.statusText = (nativeStatusText || statusText) + '';\n\n        // Success/Error\n        if (isSuccess) {\n          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);\n        } else {\n          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);\n        }\n\n        // Status-dependent callbacks\n        jqXHR.statusCode(_statusCode);\n        _statusCode = undefined;\n\n        if (fireGlobals) {\n          globalEventContext.trigger(isSuccess ? 'ajaxSuccess' : 'ajaxError', [jqXHR, s, isSuccess ? success : error]);\n        }\n\n        // Complete\n        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);\n\n        if (fireGlobals) {\n          globalEventContext.trigger('ajaxComplete', [jqXHR, s]);\n\n          // Handle the global AJAX counter\n          if (! --jQuery.active) {\n            jQuery.event.trigger('ajaxStop');\n          }\n        }\n      }\n\n      return jqXHR;\n    },\n\n    getJSON: function getJSON(url, data, callback) {\n      return jQuery.get(url, data, callback, 'json');\n    },\n\n    getScript: function getScript(url, callback) {\n      return jQuery.get(url, undefined, callback, 'script');\n    }\n  });\n\n  jQuery.each(['get', 'post'], function (i, method) {\n    jQuery[method] = function (url, data, callback, type) {\n\n      // Shift arguments if data argument was omitted\n      if (isFunction(data)) {\n        type = type || callback;\n        callback = data;\n        data = undefined;\n      }\n\n      // The url can be an options object (which then must have .url)\n      return jQuery.ajax(jQuery.extend({\n        url: url,\n        type: method,\n        dataType: type,\n        data: data,\n        success: callback\n      }, jQuery.isPlainObject(url) && url));\n    };\n  });\n\n  jQuery._evalUrl = function (url) {\n    return jQuery.ajax({\n      url: url,\n\n      // Make this explicit, since user can override this through ajaxSetup (#11264)\n      type: 'GET',\n      dataType: 'script',\n      cache: true,\n      async: false,\n      global: false,\n      'throws': true\n    });\n  };\n\n  jQuery.fn.extend({\n    wrapAll: function wrapAll(html) {\n      var wrap;\n\n      if (this[0]) {\n        if (isFunction(html)) {\n          html = html.call(this[0]);\n        }\n\n        // The elements to wrap the target around\n        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);\n\n        if (this[0].parentNode) {\n          wrap.insertBefore(this[0]);\n        }\n\n        wrap.map(function () {\n          var elem = this;\n\n          while (elem.firstElementChild) {\n            elem = elem.firstElementChild;\n          }\n\n          return elem;\n        }).append(this);\n      }\n\n      return this;\n    },\n\n    wrapInner: function wrapInner(html) {\n      if (isFunction(html)) {\n        return this.each(function (i) {\n          jQuery(this).wrapInner(html.call(this, i));\n        });\n      }\n\n      return this.each(function () {\n        var self = jQuery(this),\n            contents = self.contents();\n\n        if (contents.length) {\n          contents.wrapAll(html);\n        } else {\n          self.append(html);\n        }\n      });\n    },\n\n    wrap: function wrap(html) {\n      var htmlIsFunction = isFunction(html);\n\n      return this.each(function (i) {\n        jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);\n      });\n    },\n\n    unwrap: function unwrap(selector) {\n      this.parent(selector).not('body').each(function () {\n        jQuery(this).replaceWith(this.childNodes);\n      });\n      return this;\n    }\n  });\n\n  jQuery.expr.pseudos.hidden = function (elem) {\n    return !jQuery.expr.pseudos.visible(elem);\n  };\n  jQuery.expr.pseudos.visible = function (elem) {\n    return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);\n  };\n\n  jQuery.ajaxSettings.xhr = function () {\n    try {\n      return new window.XMLHttpRequest();\n    } catch (e) {}\n  };\n\n  var xhrSuccessStatus = {\n\n    // File protocol always yields status code 0, assume 200\n    0: 200,\n\n    // Support: IE <=9 only\n    // #1450: sometimes IE returns 1223 when it should be 204\n    1223: 204\n  },\n      xhrSupported = jQuery.ajaxSettings.xhr();\n\n  support.cors = !!xhrSupported && 'withCredentials' in xhrSupported;\n  support.ajax = xhrSupported = !!xhrSupported;\n\n  jQuery.ajaxTransport(function (options) {\n    var _callback, errorCallback;\n\n    // Cross domain only allowed if supported through XMLHttpRequest\n    if (support.cors || xhrSupported && !options.crossDomain) {\n      return {\n        send: function send(headers, complete) {\n          var i,\n              xhr = options.xhr();\n\n          xhr.open(options.type, options.url, options.async, options.username, options.password);\n\n          // Apply custom fields if provided\n          if (options.xhrFields) {\n            for (i in options.xhrFields) {\n              xhr[i] = options.xhrFields[i];\n            }\n          }\n\n          // Override mime type if needed\n          if (options.mimeType && xhr.overrideMimeType) {\n            xhr.overrideMimeType(options.mimeType);\n          }\n\n          // X-Requested-With header\n          // For cross-domain requests, seeing as conditions for a preflight are\n          // akin to a jigsaw puzzle, we simply never set it to be sure.\n          // (it can always be set on a per-request basis or even using ajaxSetup)\n          // For same-domain requests, won't change header if already provided.\n          if (!options.crossDomain && !headers['X-Requested-With']) {\n            headers['X-Requested-With'] = 'XMLHttpRequest';\n          }\n\n          // Set headers\n          for (i in headers) {\n            xhr.setRequestHeader(i, headers[i]);\n          }\n\n          // Callback\n          _callback = function callback(type) {\n            return function () {\n              if (_callback) {\n                _callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;\n\n                if (type === 'abort') {\n                  xhr.abort();\n                } else if (type === 'error') {\n\n                  // Support: IE <=9 only\n                  // On a manual native abort, IE9 throws\n                  // errors on any property access that is not readyState\n                  if (typeof xhr.status !== 'number') {\n                    complete(0, 'error');\n                  } else {\n                    complete(\n\n                    // File: protocol always yields status 0; see #8605, #14207\n                    xhr.status, xhr.statusText);\n                  }\n                } else {\n                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText,\n\n                  // Support: IE <=9 only\n                  // IE9 has no XHR2 but throws on binary (trac-11426)\n                  // For XHR2 non-text, let the caller handle it (gh-2498)\n                  (xhr.responseType || 'text') !== 'text' || typeof xhr.responseText !== 'string' ? { binary: xhr.response } : { text: xhr.responseText }, xhr.getAllResponseHeaders());\n                }\n              }\n            };\n          };\n\n          // Listen to events\n          xhr.onload = _callback();\n          errorCallback = xhr.onerror = xhr.ontimeout = _callback('error');\n\n          // Support: IE 9 only\n          // Use onreadystatechange to replace onabort\n          // to handle uncaught aborts\n          if (xhr.onabort !== undefined) {\n            xhr.onabort = errorCallback;\n          } else {\n            xhr.onreadystatechange = function () {\n\n              // Check readyState before timeout as it changes\n              if (xhr.readyState === 4) {\n\n                // Allow onerror to be called first,\n                // but that will not handle a native abort\n                // Also, save errorCallback to a variable\n                // as xhr.onerror cannot be accessed\n                window.setTimeout(function () {\n                  if (_callback) {\n                    errorCallback();\n                  }\n                });\n              }\n            };\n          }\n\n          // Create the abort callback\n          _callback = _callback('abort');\n\n          try {\n\n            // Do send the request (this may raise an exception)\n            xhr.send(options.hasContent && options.data || null);\n          } catch (e) {\n\n            // #14683: Only rethrow if this hasn't been notified as an error yet\n            if (_callback) {\n              throw e;\n            }\n          }\n        },\n\n        abort: function abort() {\n          if (_callback) {\n            _callback();\n          }\n        }\n      };\n    }\n  });\n\n  // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\n  jQuery.ajaxPrefilter(function (s) {\n    if (s.crossDomain) {\n      s.contents.script = false;\n    }\n  });\n\n  // Install script dataType\n  jQuery.ajaxSetup({\n    accepts: {\n      script: 'text/javascript, application/javascript, ' + 'application/ecmascript, application/x-ecmascript'\n    },\n    contents: {\n      script: /\\b(?:java|ecma)script\\b/\n    },\n    converters: {\n      'text script': function textScript(text) {\n        jQuery.globalEval(text);\n        return text;\n      }\n    }\n  });\n\n  // Handle cache's special case and crossDomain\n  jQuery.ajaxPrefilter('script', function (s) {\n    if (s.cache === undefined) {\n      s.cache = false;\n    }\n    if (s.crossDomain) {\n      s.type = 'GET';\n    }\n  });\n\n  // Bind script tag hack transport\n  jQuery.ajaxTransport('script', function (s) {\n\n    // This transport only deals with cross domain requests\n    if (s.crossDomain) {\n      var script, _callback2;\n      return {\n        send: function send(_, complete) {\n          script = jQuery('<script>').prop({\n            charset: s.scriptCharset,\n            src: s.url\n          }).on('load error', _callback2 = function callback(evt) {\n            script.remove();\n            _callback2 = null;\n            if (evt) {\n              complete(evt.type === 'error' ? 404 : 200, evt.type);\n            }\n          });\n\n          // Use native DOM manipulation to avoid our domManip AJAX trickery\n          document.head.appendChild(script[0]);\n        },\n        abort: function abort() {\n          if (_callback2) {\n            _callback2();\n          }\n        }\n      };\n    }\n  });\n\n  var oldCallbacks = [],\n      rjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n  // Default jsonp settings\n  jQuery.ajaxSetup({\n    jsonp: 'callback',\n    jsonpCallback: function jsonpCallback() {\n      var callback = oldCallbacks.pop() || jQuery.expando + '_' + nonce++;\n      this[callback] = true;\n      return callback;\n    }\n  });\n\n  // Detect, normalize options and install callbacks for jsonp requests\n  jQuery.ajaxPrefilter('json jsonp', function (s, originalSettings, jqXHR) {\n\n    var callbackName,\n        overwritten,\n        responseContainer,\n        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? 'url' : typeof s.data === 'string' && (s.contentType || '').indexOf('application/x-www-form-urlencoded') === 0 && rjsonp.test(s.data) && 'data');\n\n    // Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n    if (jsonProp || s.dataTypes[0] === 'jsonp') {\n\n      // Get callback name, remembering preexisting value associated with it\n      callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;\n\n      // Insert callback into url or form data\n      if (jsonProp) {\n        s[jsonProp] = s[jsonProp].replace(rjsonp, '$1' + callbackName);\n      } else if (s.jsonp !== false) {\n        s.url += (rquery.test(s.url) ? '&' : '?') + s.jsonp + '=' + callbackName;\n      }\n\n      // Use data converter to retrieve json after script execution\n      s.converters['script json'] = function () {\n        if (!responseContainer) {\n          jQuery.error(callbackName + ' was not called');\n        }\n        return responseContainer[0];\n      };\n\n      // Force json dataType\n      s.dataTypes[0] = 'json';\n\n      // Install callback\n      overwritten = window[callbackName];\n      window[callbackName] = function () {\n        responseContainer = arguments;\n      };\n\n      // Clean-up function (fires after converters)\n      jqXHR.always(function () {\n\n        // If previous value didn't exist - remove it\n        if (overwritten === undefined) {\n          jQuery(window).removeProp(callbackName);\n\n          // Otherwise restore preexisting value\n        } else {\n          window[callbackName] = overwritten;\n        }\n\n        // Save back as free\n        if (s[callbackName]) {\n\n          // Make sure that re-using the options doesn't screw things around\n          s.jsonpCallback = originalSettings.jsonpCallback;\n\n          // Save the callback name for future use\n          oldCallbacks.push(callbackName);\n        }\n\n        // Call if it was a function and we have a response\n        if (responseContainer && isFunction(overwritten)) {\n          overwritten(responseContainer[0]);\n        }\n\n        responseContainer = overwritten = undefined;\n      });\n\n      // Delegate to script\n      return 'script';\n    }\n  });\n\n  // Support: Safari 8 only\n  // In Safari 8 documents created via document.implementation.createHTMLDocument\n  // collapse sibling forms: the second one becomes a child of the first one.\n  // Because of that, this security measure has to be disabled in Safari 8.\n  // https://bugs.webkit.org/show_bug.cgi?id=137337\n  support.createHTMLDocument = function () {\n    var body = document.implementation.createHTMLDocument('').body;\n    body.innerHTML = '<form></form><form></form>';\n    return body.childNodes.length === 2;\n  }();\n\n  // Argument \"data\" should be string of html\n  // context (optional): If specified, the fragment will be created in this context,\n  // defaults to document\n  // keepScripts (optional): If true, will include scripts passed in the html string\n  jQuery.parseHTML = function (data, context, keepScripts) {\n    if (typeof data !== 'string') {\n      return [];\n    }\n    if (typeof context === 'boolean') {\n      keepScripts = context;\n      context = false;\n    }\n\n    var base, parsed, scripts;\n\n    if (!context) {\n\n      // Stop scripts or inline event handlers from being executed immediately\n      // by using document.implementation\n      if (support.createHTMLDocument) {\n        context = document.implementation.createHTMLDocument('');\n\n        // Set the base href for the created document\n        // so any parsed elements with URLs\n        // are based on the document's URL (gh-2965)\n        base = context.createElement('base');\n        base.href = document.location.href;\n        context.head.appendChild(base);\n      } else {\n        context = document;\n      }\n    }\n\n    parsed = rsingleTag.exec(data);\n    scripts = !keepScripts && [];\n\n    // Single tag\n    if (parsed) {\n      return [context.createElement(parsed[1])];\n    }\n\n    parsed = buildFragment([data], context, scripts);\n\n    if (scripts && scripts.length) {\n      jQuery(scripts).remove();\n    }\n\n    return jQuery.merge([], parsed.childNodes);\n  };\n\n  /**\n  * Load a url into a page\n  */\n  jQuery.fn.load = function (url, params, callback) {\n    var selector,\n        type,\n        response,\n        self = this,\n        off = url.indexOf(' ');\n\n    if (off > -1) {\n      selector = stripAndCollapse(url.slice(off));\n      url = url.slice(0, off);\n    }\n\n    // If it's a function\n    if (isFunction(params)) {\n\n      // We assume that it's the callback\n      callback = params;\n      params = undefined;\n\n      // Otherwise, build a param string\n    } else if (params && (typeof params === 'undefined' ? 'undefined' : _typeof(params)) === 'object') {\n      type = 'POST';\n    }\n\n    // If we have elements to modify, make the request\n    if (self.length > 0) {\n      jQuery.ajax({\n        url: url,\n\n        // If \"type\" variable is undefined, then \"GET\" method will be used.\n        // Make value of this field explicit since\n        // user can override it through ajaxSetup method\n        type: type || 'GET',\n        dataType: 'html',\n        data: params\n      }).done(function (responseText) {\n\n        // Save response for use in complete callback\n        response = arguments;\n\n        self.html(selector ?\n\n        // If a selector was specified, locate the right elements in a dummy div\n        // Exclude scripts to avoid IE 'Permission Denied' errors\n        jQuery('<div>').append(jQuery.parseHTML(responseText)).find(selector) :\n\n        // Otherwise use the full result\n        responseText);\n\n        // If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n        // but they are ignored because response was set above.\n        // If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n      }).always(callback && function (jqXHR, status) {\n        self.each(function () {\n          callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);\n        });\n      });\n    }\n\n    return this;\n  };\n\n  // Attach a bunch of functions for handling common AJAX events\n  jQuery.each(['ajaxStart', 'ajaxStop', 'ajaxComplete', 'ajaxError', 'ajaxSuccess', 'ajaxSend'], function (i, type) {\n    jQuery.fn[type] = function (fn) {\n      return this.on(type, fn);\n    };\n  });\n\n  jQuery.expr.pseudos.animated = function (elem) {\n    return jQuery.grep(jQuery.timers, function (fn) {\n      return elem === fn.elem;\n    }).length;\n  };\n\n  jQuery.offset = {\n    setOffset: function setOffset(elem, options, i) {\n      var curPosition,\n          curLeft,\n          curCSSTop,\n          curTop,\n          curOffset,\n          curCSSLeft,\n          calculatePosition,\n          position = jQuery.css(elem, 'position'),\n          curElem = jQuery(elem),\n          props = {};\n\n      // Set position first, in-case top/left are set even on static elem\n      if (position === 'static') {\n        elem.style.position = 'relative';\n      }\n\n      curOffset = curElem.offset();\n      curCSSTop = jQuery.css(elem, 'top');\n      curCSSLeft = jQuery.css(elem, 'left');\n      calculatePosition = (position === 'absolute' || position === 'fixed') && (curCSSTop + curCSSLeft).indexOf('auto') > -1;\n\n      // Need to be able to calculate position if either\n      // top or left is auto and position is either absolute or fixed\n      if (calculatePosition) {\n        curPosition = curElem.position();\n        curTop = curPosition.top;\n        curLeft = curPosition.left;\n      } else {\n        curTop = parseFloat(curCSSTop) || 0;\n        curLeft = parseFloat(curCSSLeft) || 0;\n      }\n\n      if (isFunction(options)) {\n\n        // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n        options = options.call(elem, i, jQuery.extend({}, curOffset));\n      }\n\n      if (options.top != null) {\n        props.top = options.top - curOffset.top + curTop;\n      }\n      if (options.left != null) {\n        props.left = options.left - curOffset.left + curLeft;\n      }\n\n      if ('using' in options) {\n        options.using.call(elem, props);\n      } else {\n        curElem.css(props);\n      }\n    }\n  };\n\n  jQuery.fn.extend({\n\n    // offset() relates an element's border box to the document origin\n    offset: function offset(options) {\n\n      // Preserve chaining for setter\n      if (arguments.length) {\n        return options === undefined ? this : this.each(function (i) {\n          jQuery.offset.setOffset(this, options, i);\n        });\n      }\n\n      var rect,\n          win,\n          elem = this[0];\n\n      if (!elem) {\n        return;\n      }\n\n      // Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n      // Support: IE <=11 only\n      // Running getBoundingClientRect on a\n      // disconnected node in IE throws an error\n      if (!elem.getClientRects().length) {\n        return { top: 0, left: 0 };\n      }\n\n      // Get document-relative position by adding viewport scroll to viewport-relative gBCR\n      rect = elem.getBoundingClientRect();\n      win = elem.ownerDocument.defaultView;\n      return {\n        top: rect.top + win.pageYOffset,\n        left: rect.left + win.pageXOffset\n      };\n    },\n\n    // position() relates an element's margin box to its offset parent's padding box\n    // This corresponds to the behavior of CSS absolute positioning\n    position: function position() {\n      if (!this[0]) {\n        return;\n      }\n\n      var offsetParent,\n          offset,\n          doc,\n          elem = this[0],\n          parentOffset = { top: 0, left: 0 };\n\n      // position:fixed elements are offset from the viewport, which itself always has zero offset\n      if (jQuery.css(elem, 'position') === 'fixed') {\n\n        // Assume position:fixed implies availability of getBoundingClientRect\n        offset = elem.getBoundingClientRect();\n      } else {\n        offset = this.offset();\n\n        // Account for the *real* offset parent, which can be the document or its root element\n        // when a statically positioned element is identified\n        doc = elem.ownerDocument;\n        offsetParent = elem.offsetParent || doc.documentElement;\n        while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, 'position') === 'static') {\n\n          offsetParent = offsetParent.parentNode;\n        }\n        if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {\n\n          // Incorporate borders into its offset, since they are outside its content origin\n          parentOffset = jQuery(offsetParent).offset();\n          parentOffset.top += jQuery.css(offsetParent, 'borderTopWidth', true);\n          parentOffset.left += jQuery.css(offsetParent, 'borderLeftWidth', true);\n        }\n      }\n\n      // Subtract parent offsets and element margins\n      return {\n        top: offset.top - parentOffset.top - jQuery.css(elem, 'marginTop', true),\n        left: offset.left - parentOffset.left - jQuery.css(elem, 'marginLeft', true)\n      };\n    },\n\n    // This method will return documentElement in the following cases:\n    // 1) For the element inside the iframe without offsetParent, this method will return\n    //    documentElement of the parent window\n    // 2) For the hidden or detached element\n    // 3) For body or html element, i.e. in case of the html node - it will return itself\n    //\n    // but those exceptions were never presented as a real life use-cases\n    // and might be considered as more preferable results.\n    //\n    // This logic, however, is not guaranteed and can change at any point in the future\n    offsetParent: function offsetParent() {\n      return this.map(function () {\n        var offsetParent = this.offsetParent;\n\n        while (offsetParent && jQuery.css(offsetParent, 'position') === 'static') {\n          offsetParent = offsetParent.offsetParent;\n        }\n\n        return offsetParent || documentElement;\n      });\n    }\n  });\n\n  // Create scrollLeft and scrollTop methods\n  jQuery.each({ scrollLeft: 'pageXOffset', scrollTop: 'pageYOffset' }, function (method, prop) {\n    var top = 'pageYOffset' === prop;\n\n    jQuery.fn[method] = function (val) {\n      return access(this, function (elem, method, val) {\n\n        // Coalesce documents and windows\n        var win;\n        if (isWindow(elem)) {\n          win = elem;\n        } else if (elem.nodeType === 9) {\n          win = elem.defaultView;\n        }\n\n        if (val === undefined) {\n          return win ? win[prop] : elem[method];\n        }\n\n        if (win) {\n          win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);\n        } else {\n          elem[method] = val;\n        }\n      }, method, val, arguments.length);\n    };\n  });\n\n  // Support: Safari <=7 - 9.1, Chrome <=37 - 49\n  // Add the top/left cssHooks using jQuery.fn.position\n  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n  // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n  // getComputedStyle returns percent when specified for top/left/bottom/right;\n  // rather than make the css module depend on the offset module, just check for it here\n  jQuery.each(['top', 'left'], function (i, prop) {\n    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {\n      if (computed) {\n        computed = curCSS(elem, prop);\n\n        // If curCSS returns percentage, fallback to offset\n        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + 'px' : computed;\n      }\n    });\n  });\n\n  // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n  jQuery.each({ Height: 'height', Width: 'width' }, function (name, type) {\n    jQuery.each({ padding: 'inner' + name, content: type, '': 'outer' + name }, function (defaultExtra, funcName) {\n\n      // Margin is only for outerHeight, outerWidth\n      jQuery.fn[funcName] = function (margin, value) {\n        var chainable = arguments.length && (defaultExtra || typeof margin !== 'boolean'),\n            extra = defaultExtra || (margin === true || value === true ? 'margin' : 'border');\n\n        return access(this, function (elem, type, value) {\n          var doc;\n\n          if (isWindow(elem)) {\n\n            // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n            return funcName.indexOf('outer') === 0 ? elem['inner' + name] : elem.document.documentElement['client' + name];\n          }\n\n          // Get document width or height\n          if (elem.nodeType === 9) {\n            doc = elem.documentElement;\n\n            // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n            // whichever is greatest\n            return Math.max(elem.body['scroll' + name], doc['scroll' + name], elem.body['offset' + name], doc['offset' + name], doc['client' + name]);\n          }\n\n          return value === undefined ?\n\n          // Get width or height on the element, requesting but not forcing parseFloat\n          jQuery.css(elem, type, extra) :\n\n          // Set width or height on the element\n          jQuery.style(elem, type, value, extra);\n        }, type, chainable ? margin : undefined, chainable);\n      };\n    });\n  });\n\n  jQuery.each(('blur focus focusin focusout resize scroll click dblclick ' + 'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' + 'change select submit keydown keypress keyup contextmenu').split(' '), function (i, name) {\n\n    // Handle event binding\n    jQuery.fn[name] = function (data, fn) {\n      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);\n    };\n  });\n\n  jQuery.fn.extend({\n    hover: function hover(fnOver, fnOut) {\n      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);\n    }\n  });\n\n  jQuery.fn.extend({\n\n    bind: function bind(types, data, fn) {\n      return this.on(types, null, data, fn);\n    },\n    unbind: function unbind(types, fn) {\n      return this.off(types, null, fn);\n    },\n\n    delegate: function delegate(selector, types, data, fn) {\n      return this.on(types, selector, data, fn);\n    },\n    undelegate: function undelegate(selector, types, fn) {\n\n      // ( namespace ) or ( selector, types [, fn] )\n      return arguments.length === 1 ? this.off(selector, '**') : this.off(types, selector || '**', fn);\n    }\n  });\n\n  // Bind a function to a context, optionally partially applying any\n  // arguments.\n  // jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n  // However, it is not slated for removal any time soon\n  jQuery.proxy = function (fn, context) {\n    var tmp, args, proxy;\n\n    if (typeof context === 'string') {\n      tmp = fn[context];\n      context = fn;\n      fn = tmp;\n    }\n\n    // Quick check to determine if target is callable, in the spec\n    // this throws a TypeError, but we will just return undefined.\n    if (!isFunction(fn)) {\n      return undefined;\n    }\n\n    // Simulated bind\n    args = _slice.call(arguments, 2);\n    proxy = function proxy() {\n      return fn.apply(context || this, args.concat(_slice.call(arguments)));\n    };\n\n    // Set the guid of unique handler to the same of original handler, so it can be removed\n    proxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n    return proxy;\n  };\n\n  jQuery.holdReady = function (hold) {\n    if (hold) {\n      jQuery.readyWait++;\n    } else {\n      jQuery.ready(true);\n    }\n  };\n  jQuery.isArray = Array.isArray;\n  jQuery.parseJSON = JSON.parse;\n  jQuery.nodeName = nodeName;\n  jQuery.isFunction = isFunction;\n  jQuery.isWindow = isWindow;\n  jQuery.camelCase = camelCase;\n  jQuery.type = toType;\n\n  jQuery.now = Date.now;\n\n  jQuery.isNumeric = function (obj) {\n\n    // As of jQuery 3.0, isNumeric is limited to\n    // strings and numbers (primitives or objects)\n    // that can be coerced to finite numbers (gh-2662)\n    var type = jQuery.type(obj);\n    return (type === 'number' || type === 'string') &&\n\n    // parseFloat NaNs numeric-cast false positives (\"\")\n    // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n    // subtraction forces infinities to NaN\n    !isNaN(obj - parseFloat(obj));\n  };\n\n  // Register as a named AMD module, since jQuery can be concatenated with other\n  // files that may use define, but not via a proper concatenation script that\n  // understands anonymous AMD modules. A named AMD is safest and most robust\n  // way to register. Lowercase jquery is used because AMD module names are\n  // derived from file names, and jQuery is normally delivered in a lowercase\n  // file name. Do this after creating the global so that if an AMD module wants\n  // to call noConflict to hide this version of jQuery, it will work.\n\n  // Note that for maximum portability, libraries that are not jQuery should\n  // declare themselves as anonymous modules, and avoid setting a global if an\n  // AMD loader is present. jQuery is a special case. For more information, see\n  // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n      return jQuery;\n    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n\n  var\n\n  // Map over jQuery in case of overwrite\n  _jQuery = window.jQuery,\n\n\n  // Map over the $ in case of overwrite\n  _$ = window.$;\n\n  jQuery.noConflict = function (deep) {\n    if (window.$ === jQuery) {\n      window.$ = _$;\n    }\n\n    if (deep && window.jQuery === jQuery) {\n      window.jQuery = _jQuery;\n    }\n\n    return jQuery;\n  };\n\n  // Expose jQuery and $ identifiers, even in AMD\n  // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n  // and CommonJS for browser emulators (#13566)\n  if (!noGlobal) {\n    window.jQuery = window.$ = jQuery;\n  }\n\n  return jQuery;\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)(module)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9+L2pxdWVyeS9kaXN0L2pxdWVyeS5qcz82MTI5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2My4zLjFcbiAqIGh0dHBzOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE4LTAxLTIwVDE3OjI0WlxuICovXG4oIGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICggdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSAnb2JqZWN0JyApIHtcblxuICAgIC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2BcbiAgICAvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuICAgIC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG4gICAgLy8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG4gICAgLy8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cbiAgICAvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG4gICAgLy8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG4gICAgICBmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG4gICAgICBmdW5jdGlvbiggdyApIHtcbiAgICAgICAgaWYgKCAhdy5kb2N1bWVudCApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoICdqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50JyApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWN0b3J5KCB3ICk7XG4gICAgICB9O1xuICB9IGVsc2Uge1xuICAgIGZhY3RvcnkoIGdsb2JhbCApO1xuICB9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59ICkoIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XG5cbi8vIEVkZ2UgPD0gMTIgLSAxMyssIEZpcmVmb3ggPD0xOCAtIDQ1KywgSUUgMTAgLSAxMSwgU2FmYXJpIDUuMSAtIDkrLCBpT1MgNiAtIDkuMVxuLy8gdGhyb3cgZXhjZXB0aW9ucyB3aGVuIG5vbi1zdHJpY3QgY29kZSAoZS5nLiwgQVNQLk5FVCA0LjUpIGFjY2Vzc2VzIHN0cmljdCBtb2RlXG4vLyBhcmd1bWVudHMuY2FsbGVlLmNhbGxlciAodHJhYy0xMzMzNSkuIEJ1dCBhcyBvZiBqUXVlcnkgMy4wICgyMDE2KSwgc3RyaWN0IG1vZGUgc2hvdWxkIGJlIGNvbW1vblxuLy8gZW5vdWdoIHRoYXQgYWxsIHN1Y2ggYXR0ZW1wdHMgYXJlIGd1YXJkZWQgaW4gYSB0cnkgYmxvY2suXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgYXJyID0gW107XG5cbiAgdmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxuICB2YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbiAgdmFyIGNvbmNhdCA9IGFyci5jb25jYXQ7XG5cbiAgdmFyIHB1c2ggPSBhcnIucHVzaDtcblxuICB2YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG4gIHZhciBjbGFzczJ0eXBlID0ge307XG5cbiAgdmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxuICB2YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICB2YXIgZm5Ub1N0cmluZyA9IGhhc093bi50b1N0cmluZztcblxuICB2YXIgT2JqZWN0RnVuY3Rpb25TdHJpbmcgPSBmblRvU3RyaW5nLmNhbGwoIE9iamVjdCApO1xuXG4gIHZhciBzdXBwb3J0ID0ge307XG5cbiAgdmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKCBvYmogKSB7XG5cbiAgICAvLyBTdXBwb3J0OiBDaHJvbWUgPD01NywgRmlyZWZveCA8PTUyXG4gICAgLy8gSW4gc29tZSBicm93c2VycywgdHlwZW9mIHJldHVybnMgXCJmdW5jdGlvblwiIGZvciBIVE1MIDxvYmplY3Q+IGVsZW1lbnRzXG4gICAgLy8gKGkuZS4sIGB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvYmplY3RcIiApID09PSBcImZ1bmN0aW9uXCJgKS5cbiAgICAvLyBXZSBkb24ndCB3YW50IHRvIGNsYXNzaWZ5ICphbnkqIERPTSBub2RlIGFzIGEgZnVuY3Rpb24uXG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5ub2RlVHlwZSAhPT0gJ251bWJlcic7XG4gIH07XG5cblxuICB2YXIgaXNXaW5kb3cgPSBmdW5jdGlvbiBpc1dpbmRvdyggb2JqICkge1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG4gIH07XG5cblxuXG5cbiAgdmFyIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgPSB7XG4gICAgdHlwZTogdHJ1ZSxcbiAgICBzcmM6IHRydWUsXG4gICAgbm9Nb2R1bGU6IHRydWVcbiAgfTtcblxuICBmdW5jdGlvbiBET01FdmFsKCBjb2RlLCBkb2MsIG5vZGUgKSB7XG4gICAgZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuXG4gICAgdmFyIGksXG4gICAgICBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCggJ3NjcmlwdCcgKTtcblxuICAgIHNjcmlwdC50ZXh0ID0gY29kZTtcbiAgICBpZiAoIG5vZGUgKSB7XG4gICAgICBmb3IgKCBpIGluIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgKSB7XG4gICAgICAgIGlmICggbm9kZVsgaSBdICkge1xuICAgICAgICAgIHNjcmlwdFsgaSBdID0gbm9kZVsgaSBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gdG9UeXBlKCBvYmogKSB7XG4gICAgaWYgKCBvYmogPT0gbnVsbCApIHtcbiAgICAgIHJldHVybiBvYmogKyAnJztcbiAgICB9XG5cbiAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICBjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8ICdvYmplY3QnIDpcbiAgICAgIHR5cGVvZiBvYmo7XG4gIH1cbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICAvLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuZXNsaW50cmMuanNvbiB3b3VsZCBjcmVhdGUgYSBkYW5nZXIgb2YgdXNpbmcgdGhlIGdsb2JhbFxuICAvLyB1bmd1YXJkZWQgaW4gYW5vdGhlciBwbGFjZSwgaXQgc2VlbXMgc2FmZXIgdG8gZGVmaW5lIGdsb2JhbCBvbmx5IGZvciB0aGlzIG1vZHVsZVxuXG5cblxuICB2YXJcbiAgICB2ZXJzaW9uID0gJzMuMy4xJyxcblxuICAgIC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG4gICAgalF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXG4gICAgICAvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcbiAgICAgIC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG4gICAgICByZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuICAgIH0sXG5cbiAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcbiAgICAvLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1BcbiAgICBydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZztcblxuICBqUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXG4gICAgLy8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuICAgIGpxdWVyeTogdmVyc2lvbixcblxuICAgIGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cbiAgICAvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcbiAgICBsZW5ndGg6IDAsXG5cbiAgICB0b0FycmF5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1JcbiAgICAvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuICAgIGdldDogZnVuY3Rpb24oIG51bSApIHtcblxuICAgICAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuICAgICAgaWYgKCBudW0gPT0gbnVsbCApIHtcbiAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuICAgICAgcmV0dXJuIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF07XG4gICAgfSxcblxuICAgIC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcbiAgICAvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcbiAgICBwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuICAgICAgLy8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcbiAgICAgIHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuICAgICAgLy8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcbiAgICAgIHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblxuICAgICAgLy8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG4gICAgZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuICAgICAgcmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xuICAgIH0sXG5cbiAgICBtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcbiAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCggdGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG4gICAgICB9ICkgKTtcbiAgICB9LFxuXG4gICAgc2xpY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcbiAgICB9LFxuXG4gICAgZmlyc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZXEoIDAgKTtcbiAgICB9LFxuXG4gICAgbGFzdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5lcSggLTEgKTtcbiAgICB9LFxuXG4gICAgZXE6IGZ1bmN0aW9uKCBpICkge1xuICAgICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuICAgICAgICBqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuICAgIH0sXG5cbiAgICBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG4gICAgfSxcblxuICAgIC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cbiAgICAvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cbiAgICBwdXNoOiBwdXNoLFxuICAgIHNvcnQ6IGFyci5zb3J0LFxuICAgIHNwbGljZTogYXJyLnNwbGljZVxuICB9O1xuXG4gIGpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuICAgICAgdGFyZ2V0ID0gYXJndW1lbnRzWyAwIF0gfHwge30sXG4gICAgICBpID0gMSxcbiAgICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICBkZWVwID0gZmFsc2U7XG5cbiAgICAvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG4gICAgaWYgKCB0eXBlb2YgdGFyZ2V0ID09PSAnYm9vbGVhbicgKSB7XG4gICAgICBkZWVwID0gdGFyZ2V0O1xuXG4gICAgICAvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG4gICAgICB0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcbiAgICBpZiAoIHR5cGVvZiB0YXJnZXQgIT09ICdvYmplY3QnICYmICFpc0Z1bmN0aW9uKCB0YXJnZXQgKSApIHtcbiAgICAgIHRhcmdldCA9IHt9O1xuICAgIH1cblxuICAgIC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuICAgIGlmICggaSA9PT0gbGVuZ3RoICkge1xuICAgICAgdGFyZ2V0ID0gdGhpcztcbiAgICAgIGktLTtcbiAgICB9XG5cbiAgICBmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuICAgICAgLy8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuICAgICAgaWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuICAgICAgICBmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG4gICAgICAgICAgc3JjID0gdGFyZ2V0WyBuYW1lIF07XG4gICAgICAgICAgY29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuICAgICAgICAgIC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3BcbiAgICAgICAgICBpZiAoIHRhcmdldCA9PT0gY29weSApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuICAgICAgICAgIGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxuXHRcdFx0XHRcdCggY29weUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KCBjb3B5ICkgKSApICkge1xuXG4gICAgICAgICAgICBpZiAoIGNvcHlJc0FycmF5ICkge1xuICAgICAgICAgICAgICBjb3B5SXNBcnJheSA9IGZhbHNlO1xuICAgICAgICAgICAgICBjbG9uZSA9IHNyYyAmJiBBcnJheS5pc0FycmF5KCBzcmMgKSA/IHNyYyA6IFtdO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggc3JjICkgPyBzcmMgOiB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG4gICAgICAgICAgICB0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cbiAgICAgICAgICAgIC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcbiAgICAgICAgICB9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICB0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3RcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIGpRdWVyeS5leHRlbmQoIHtcblxuICAgIC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuICAgIGV4cGFuZG86ICdqUXVlcnknICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXEQvZywgJycgKSxcblxuICAgIC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG4gICAgaXNSZWFkeTogdHJ1ZSxcblxuICAgIGVycm9yOiBmdW5jdGlvbiggbXNnICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcbiAgICB9LFxuXG4gICAgbm9vcDogZnVuY3Rpb24oKSB7fSxcblxuICAgIGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG4gICAgICB2YXIgcHJvdG8sIEN0b3I7XG5cbiAgICAgIC8vIERldGVjdCBvYnZpb3VzIG5lZ2F0aXZlc1xuICAgICAgLy8gVXNlIHRvU3RyaW5nIGluc3RlYWQgb2YgalF1ZXJ5LnR5cGUgdG8gY2F0Y2ggaG9zdCBvYmplY3RzXG4gICAgICBpZiAoICFvYmogfHwgdG9TdHJpbmcuY2FsbCggb2JqICkgIT09ICdbb2JqZWN0IE9iamVjdF0nICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHByb3RvID0gZ2V0UHJvdG8oIG9iaiApO1xuXG4gICAgICAvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG4gICAgICBpZiAoICFwcm90byApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIE9iamVjdHMgd2l0aCBwcm90b3R5cGUgYXJlIHBsYWluIGlmZiB0aGV5IHdlcmUgY29uc3RydWN0ZWQgYnkgYSBnbG9iYWwgT2JqZWN0IGZ1bmN0aW9uXG4gICAgICBDdG9yID0gaGFzT3duLmNhbGwoIHByb3RvLCAnY29uc3RydWN0b3InICkgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gICAgICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgZm5Ub1N0cmluZy5jYWxsKCBDdG9yICkgPT09IE9iamVjdEZ1bmN0aW9uU3RyaW5nO1xuICAgIH0sXG5cbiAgICBpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy82MTI1XG4gICAgICB2YXIgbmFtZTtcblxuICAgICAgZm9yICggbmFtZSBpbiBvYmogKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dFxuICAgIGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlICkge1xuICAgICAgRE9NRXZhbCggY29kZSApO1xuICAgIH0sXG5cbiAgICBlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjayApIHtcbiAgICAgIHZhciBsZW5ndGgsIGkgPSAwO1xuXG4gICAgICBpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcbiAgICAgICAgbGVuZ3RoID0gb2JqLmxlbmd0aDtcbiAgICAgICAgZm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgaWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoIGkgaW4gb2JqICkge1xuICAgICAgICAgIGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcblxuICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuICAgIHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xuICAgICAgcmV0dXJuIHRleHQgPT0gbnVsbCA/XG4gICAgICAgICcnIDpcbiAgICAgICAgKCB0ZXh0ICsgJycgKS5yZXBsYWNlKCBydHJpbSwgJycgKTtcbiAgICB9LFxuXG4gICAgLy8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuICAgIG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcbiAgICAgIHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG4gICAgICBpZiAoIGFyciAhPSBudWxsICkge1xuICAgICAgICBpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG4gICAgICAgICAgalF1ZXJ5Lm1lcmdlKCByZXQsXG4gICAgICAgICAgICB0eXBlb2YgYXJyID09PSAnc3RyaW5nJyA/XG4gICAgICAgICAgICAgIFsgYXJyIF0gOiBhcnJcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHB1c2guY2FsbCggcmV0LCBhcnIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICBpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuICAgICAgcmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuICAgIH0sXG5cbiAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcbiAgICAvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG4gICAgbWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuICAgICAgdmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuICAgICAgICBqID0gMCxcbiAgICAgICAgaSA9IGZpcnN0Lmxlbmd0aDtcblxuICAgICAgZm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG4gICAgICAgIGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuICAgICAgfVxuXG4gICAgICBmaXJzdC5sZW5ndGggPSBpO1xuXG4gICAgICByZXR1cm4gZmlyc3Q7XG4gICAgfSxcblxuICAgIGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcbiAgICAgIHZhciBjYWxsYmFja0ludmVyc2UsXG4gICAgICAgIG1hdGNoZXMgPSBbXSxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcbiAgICAgICAgY2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG4gICAgICAvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG4gICAgICAvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuICAgICAgZm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuICAgICAgICBpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgfSxcblxuICAgIC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuICAgIG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuICAgICAgdmFyIGxlbmd0aCwgdmFsdWUsXG4gICAgICAgIGkgPSAwLFxuICAgICAgICByZXQgPSBbXTtcblxuICAgICAgLy8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcbiAgICAgIGlmICggaXNBcnJheUxpa2UoIGVsZW1zICkgKSB7XG4gICAgICAgIGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcbiAgICAgICAgZm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgdmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cbiAgICAgICAgICBpZiAoIHZhbHVlICE9IG51bGwgKSB7XG4gICAgICAgICAgICByZXQucHVzaCggdmFsdWUgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICggaSBpbiBlbGVtcyApIHtcbiAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuICAgICAgICAgIGlmICggdmFsdWUgIT0gbnVsbCApIHtcbiAgICAgICAgICAgIHJldC5wdXNoKCB2YWx1ZSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG4gICAgICByZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG4gICAgfSxcblxuICAgIC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuICAgIGd1aWQ6IDEsXG5cbiAgICAvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcbiAgICAvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuICAgIHN1cHBvcnQ6IHN1cHBvcnRcbiAgfSApO1xuXG4gIGlmICggdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICBqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcbiAgfVxuXG4gIC8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxuICBqUXVlcnkuZWFjaCggJ0Jvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sJy5zcGxpdCggJyAnICksXG4gICAgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG4gICAgICBjbGFzczJ0eXBlWyAnW29iamVjdCAnICsgbmFtZSArICddJyBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH0gKTtcblxuICBmdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xuXG4gICAgLy8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuICAgIC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcbiAgICAvLyBoYXNPd24gaXNuJ3QgdXNlZCBoZXJlIGR1ZSB0byBmYWxzZSBuZWdhdGl2ZXNcbiAgICAvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG4gICAgdmFyIGxlbmd0aCA9ICEhb2JqICYmICdsZW5ndGgnIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuICAgICAgdHlwZSA9IHRvVHlwZSggb2JqICk7XG5cbiAgICBpZiAoIGlzRnVuY3Rpb24oIG9iaiApIHx8IGlzV2luZG93KCBvYmogKSApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZSA9PT0gJ2FycmF5JyB8fCBsZW5ndGggPT09IDAgfHxcblx0XHR0eXBlb2YgbGVuZ3RoID09PSAnbnVtYmVyJyAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbiAgfVxuICB2YXIgU2l6emxlID1cbi8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMy4zXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNi0wOC0wOFxuICovXG4oZnVuY3Rpb24oIHdpbmRvdyApIHtcblxuICB2YXIgaSxcbiAgICBzdXBwb3J0LFxuICAgIEV4cHIsXG4gICAgZ2V0VGV4dCxcbiAgICBpc1hNTCxcbiAgICB0b2tlbml6ZSxcbiAgICBjb21waWxlLFxuICAgIHNlbGVjdCxcbiAgICBvdXRlcm1vc3RDb250ZXh0LFxuICAgIHNvcnRJbnB1dCxcbiAgICBoYXNEdXBsaWNhdGUsXG5cbiAgICAvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG4gICAgc2V0RG9jdW1lbnQsXG4gICAgZG9jdW1lbnQsXG4gICAgZG9jRWxlbSxcbiAgICBkb2N1bWVudElzSFRNTCxcbiAgICByYnVnZ3lRU0EsXG4gICAgcmJ1Z2d5TWF0Y2hlcyxcbiAgICBtYXRjaGVzLFxuICAgIGNvbnRhaW5zLFxuXG4gICAgLy8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuICAgIGV4cGFuZG8gPSAnc2l6emxlJyArIDEgKiBuZXcgRGF0ZSgpLFxuICAgIHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcbiAgICBkaXJydW5zID0gMCxcbiAgICBkb25lID0gMCxcbiAgICBjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcbiAgICB0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcbiAgICBjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcbiAgICBzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcbiAgICAgIGlmICggYSA9PT0gYiApIHtcbiAgICAgICAgaGFzRHVwbGljYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICAvLyBJbnN0YW5jZSBtZXRob2RzXG4gICAgaGFzT3duID0gKHt9KS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBhcnIgPSBbXSxcbiAgICBwb3AgPSBhcnIucG9wLFxuICAgIHB1c2hfbmF0aXZlID0gYXJyLnB1c2gsXG4gICAgcHVzaCA9IGFyci5wdXNoLFxuICAgIHNsaWNlID0gYXJyLnNsaWNlLFxuICAgIC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxuICAgIC8vIGh0dHBzOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcbiAgICBpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XG4gICAgICB2YXIgaSA9IDAsXG4gICAgICAgIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgZm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgIGlmICggbGlzdFtpXSA9PT0gZWxlbSApIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH0sXG5cbiAgICBib29sZWFucyA9ICdjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZCcsXG5cbiAgICAvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuICAgIHdoaXRlc3BhY2UgPSAnW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl0nLFxuXG4gICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXG4gICAgaWRlbnRpZmllciA9ICcoPzpcXFxcXFxcXC58W1xcXFx3LV18W15cXDAtXFxcXHhhMF0pKycsXG5cbiAgICAvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcbiAgICBhdHRyaWJ1dGVzID0gJ1xcXFxbJyArIHdoaXRlc3BhY2UgKyAnKignICsgaWRlbnRpZmllciArICcpKD86JyArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG5cdFx0JyooWypeJHwhfl0/PSknICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcblx0XHRcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArICcpKXwpJyArIHdoaXRlc3BhY2UgK1xuXHRcdCcqXFxcXF0nLFxuXG4gICAgcHNldWRvcyA9ICc6KCcgKyBpZGVudGlmaWVyICsgJykoPzpcXFxcKCgnICtcblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXHRcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxuXHRcdCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18JyArIGF0dHJpYnV0ZXMgKyAnKSopfCcgK1xuXHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcblx0XHQnLionICtcblx0XHQnKVxcXFwpfCknLFxuXG4gICAgLy8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuICAgIHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArICcrJywgJ2cnICksXG4gICAgcnRyaW0gPSBuZXcgUmVnRXhwKCAnXicgKyB3aGl0ZXNwYWNlICsgJyt8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopJyArIHdoaXRlc3BhY2UgKyAnKyQnLCAnZycgKSxcblxuICAgIHJjb21tYSA9IG5ldyBSZWdFeHAoICdeJyArIHdoaXRlc3BhY2UgKyAnKiwnICsgd2hpdGVzcGFjZSArICcqJyApLFxuICAgIHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoICdeJyArIHdoaXRlc3BhY2UgKyAnKihbPit+XXwnICsgd2hpdGVzcGFjZSArICcpJyArIHdoaXRlc3BhY2UgKyAnKicgKSxcblxuICAgIHJhdHRyaWJ1dGVRdW90ZXMgPSBuZXcgUmVnRXhwKCAnPScgKyB3aGl0ZXNwYWNlICsgXCIqKFteXFxcXF0nXFxcIl0qPylcIiArIHdoaXRlc3BhY2UgKyAnKlxcXFxdJywgJ2cnICksXG5cbiAgICBycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuICAgIHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggJ14nICsgaWRlbnRpZmllciArICckJyApLFxuXG4gICAgbWF0Y2hFeHByID0ge1xuICAgICAgJ0lEJzogbmV3IFJlZ0V4cCggJ14jKCcgKyBpZGVudGlmaWVyICsgJyknICksXG4gICAgICAnQ0xBU1MnOiBuZXcgUmVnRXhwKCAnXlxcXFwuKCcgKyBpZGVudGlmaWVyICsgJyknICksXG4gICAgICAnVEFHJzogbmV3IFJlZ0V4cCggJ14oJyArIGlkZW50aWZpZXIgKyAnfFsqXSknICksXG4gICAgICAnQVRUUic6IG5ldyBSZWdFeHAoICdeJyArIGF0dHJpYnV0ZXMgKSxcbiAgICAgICdQU0VVRE8nOiBuZXcgUmVnRXhwKCAnXicgKyBwc2V1ZG9zICksXG4gICAgICAnQ0hJTEQnOiBuZXcgUmVnRXhwKCAnXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXCgnICsgd2hpdGVzcGFjZSArXG5cdFx0XHQnKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpJyArIHdoaXRlc3BhY2UgKyAnKig/OihbKy1dfCknICsgd2hpdGVzcGFjZSArXG5cdFx0XHQnKihcXFxcZCspfCkpJyArIHdoaXRlc3BhY2UgKyAnKlxcXFwpfCknLCAnaScgKSxcbiAgICAgICdib29sJzogbmV3IFJlZ0V4cCggJ14oPzonICsgYm9vbGVhbnMgKyAnKSQnLCAnaScgKSxcbiAgICAgIC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuICAgICAgLy8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuICAgICAgJ25lZWRzQ29udGV4dCc6IG5ldyBSZWdFeHAoICdeJyArIHdoaXRlc3BhY2UgKyAnKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXCgnICtcblx0XHRcdHdoaXRlc3BhY2UgKyAnKigoPzotXFxcXGQpP1xcXFxkKiknICsgd2hpdGVzcGFjZSArICcqXFxcXCl8KSg/PVteLV18JCknLCAnaScgKVxuICAgIH0sXG5cbiAgICByaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcbiAgICByaGVhZGVyID0gL15oXFxkJC9pLFxuXG4gICAgcm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG5cbiAgICAvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcbiAgICBycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cbiAgICByc2libGluZyA9IC9bK35dLyxcblxuICAgIC8vIENTUyBlc2NhcGVzXG4gICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuICAgIHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoICdcXFxcXFxcXChbXFxcXGRhLWZdezEsNn0nICsgd2hpdGVzcGFjZSArICc/fCgnICsgd2hpdGVzcGFjZSArICcpfC4pJywgJ2lnJyApLFxuICAgIGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBfLCBlc2NhcGVkLCBlc2NhcGVkV2hpdGVzcGFjZSApIHtcbiAgICAgIHZhciBoaWdoID0gJzB4JyArIGVzY2FwZWQgLSAweDEwMDAwO1xuICAgICAgLy8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcbiAgICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcbiAgICAgIC8vIFdvcmthcm91bmQgZXJyb25lb3VzIG51bWVyaWMgaW50ZXJwcmV0YXRpb24gb2YgK1wiMHhcIlxuICAgICAgcmV0dXJuIGhpZ2ggIT09IGhpZ2ggfHwgZXNjYXBlZFdoaXRlc3BhY2UgP1xuICAgICAgICBlc2NhcGVkIDpcbiAgICAgICAgaGlnaCA8IDAgP1xuICAgICAgICAvLyBCTVAgY29kZXBvaW50XG4gICAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XG4gICAgICAgIC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxuICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuICAgIH0sXG5cbiAgICAvLyBDU1Mgc3RyaW5nL2lkZW50aWZpZXIgc2VyaWFsaXphdGlvblxuICAgIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xuICAgIHJjc3Nlc2NhcGUgPSAvKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXDAtXFx4MWZcXHg3Zi1cXHVGRkZGXFx3LV0vZyxcbiAgICBmY3NzZXNjYXBlID0gZnVuY3Rpb24oIGNoLCBhc0NvZGVQb2ludCApIHtcbiAgICAgIGlmICggYXNDb2RlUG9pbnQgKSB7XG5cbiAgICAgICAgLy8gVSswMDAwIE5VTEwgYmVjb21lcyBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG4gICAgICAgIGlmICggY2ggPT09ICdcXDAnICkge1xuICAgICAgICAgIHJldHVybiAnXFx1RkZGRCc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb250cm9sIGNoYXJhY3RlcnMgYW5kIChkZXBlbmRlbnQgdXBvbiBwb3NpdGlvbikgbnVtYmVycyBnZXQgZXNjYXBlZCBhcyBjb2RlIHBvaW50c1xuICAgICAgICByZXR1cm4gY2guc2xpY2UoIDAsIC0xICkgKyAnXFxcXCcgKyBjaC5jaGFyQ29kZUF0KCBjaC5sZW5ndGggLSAxICkudG9TdHJpbmcoIDE2ICkgKyAnICc7XG4gICAgICB9XG5cbiAgICAgIC8vIE90aGVyIHBvdGVudGlhbGx5LXNwZWNpYWwgQVNDSUkgY2hhcmFjdGVycyBnZXQgYmFja3NsYXNoLWVzY2FwZWRcbiAgICAgIHJldHVybiAnXFxcXCcgKyBjaDtcbiAgICB9LFxuXG4gICAgLy8gVXNlZCBmb3IgaWZyYW1lc1xuICAgIC8vIFNlZSBzZXREb2N1bWVudCgpXG4gICAgLy8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG4gICAgLy8gZXJyb3IgaW4gSUVcbiAgICB1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZXREb2N1bWVudCgpO1xuICAgIH0sXG5cbiAgICBkaXNhYmxlZEFuY2VzdG9yID0gYWRkQ29tYmluYXRvcihcbiAgICAgIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICByZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZSAmJiAoJ2Zvcm0nIGluIGVsZW0gfHwgJ2xhYmVsJyBpbiBlbGVtKTtcbiAgICAgIH0sXG4gICAgICB7IGRpcjogJ3BhcmVudE5vZGUnLCBuZXh0OiAnbGVnZW5kJyB9XG4gICAgKTtcblxuICAvLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxuICB0cnkge1xuICAgIHB1c2guYXBwbHkoXG4gICAgICAoYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSksXG4gICAgICBwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuICAgICk7XG4gICAgLy8gU3VwcG9ydDogQW5kcm9pZDw0LjBcbiAgICAvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG4gICAgYXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbiAgfSBjYXRjaCAoIGUgKSB7XG4gICAgcHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG4gICAgLy8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcbiAgICAgIGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcbiAgICAgICAgcHVzaF9uYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbChlbHMpICk7XG4gICAgICB9IDpcblxuICAgIC8vIFN1cHBvcnQ6IElFPDlcbiAgICAvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG4gICAgICBmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG4gICAgICAgIHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgLy8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG4gICAgICAgIHdoaWxlICggKHRhcmdldFtqKytdID0gZWxzW2krK10pICkge31cbiAgICAgICAgdGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuICAgIHZhciBtLCBpLCBlbGVtLCBuaWQsIG1hdGNoLCBncm91cHMsIG5ld1NlbGVjdG9yLFxuICAgICAgbmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG4gICAgICAvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG4gICAgICBub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcblxuICAgIHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG4gICAgLy8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcbiAgICBpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gJ3N0cmluZycgfHwgIXNlbGVjdG9yIHx8XG5cdFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICAvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG4gICAgaWYgKCAhc2VlZCApIHtcblxuICAgICAgaWYgKCAoIGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYyApICE9PSBkb2N1bWVudCApIHtcbiAgICAgICAgc2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG4gICAgICBpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXG4gICAgICAgIC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcImdldCpCeSpcIiBET00gbWV0aG9kXG4gICAgICAgIC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcbiAgICAgICAgaWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApKSApIHtcblxuICAgICAgICAgIC8vIElEIHNlbGVjdG9yXG4gICAgICAgICAgaWYgKCAobSA9IG1hdGNoWzFdKSApIHtcblxuICAgICAgICAgICAgLy8gRG9jdW1lbnQgY29udGV4dFxuICAgICAgICAgICAgaWYgKCBub2RlVHlwZSA9PT0gOSApIHtcbiAgICAgICAgICAgICAgaWYgKCAoZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG4gICAgICAgICAgICAgICAgLy8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuICAgICAgICAgICAgICAgIGlmICggZWxlbS5pZCA9PT0gbSApIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCggZWxlbSApO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gRWxlbWVudCBjb250ZXh0XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG4gICAgICAgICAgICAgIC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG4gICAgICAgICAgICAgIC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcbiAgICAgICAgICAgICAgaWYgKCBuZXdDb250ZXh0ICYmIChlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSAmJlxuXHRcdFx0XHRcdFx0XHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmXG5cdFx0XHRcdFx0XHRcdGVsZW0uaWQgPT09IG0gKSB7XG5cbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goIGVsZW0gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUeXBlIHNlbGVjdG9yXG4gICAgICAgICAgfSBlbHNlIGlmICggbWF0Y2hbMl0gKSB7XG4gICAgICAgICAgICBwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcblxuICAgICAgICAgICAgLy8gQ2xhc3Mgc2VsZWN0b3JcbiAgICAgICAgICB9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiZcblx0XHRcdFx0XHRjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cbiAgICAgICAgICAgIHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXG4gICAgICAgIGlmICggc3VwcG9ydC5xc2EgJiZcblx0XHRcdFx0IWNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgJyAnIF0gJiZcblx0XHRcdFx0KCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApKSApIHtcblxuICAgICAgICAgIGlmICggbm9kZVR5cGUgIT09IDEgKSB7XG4gICAgICAgICAgICBuZXdDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIG5ld1NlbGVjdG9yID0gc2VsZWN0b3I7XG5cbiAgICAgICAgICAgIC8vIHFTQSBsb29rcyBvdXRzaWRlIEVsZW1lbnQgY29udGV4dCwgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudFxuICAgICAgICAgICAgLy8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgd29ya2Fyb3VuZCB0ZWNobmlxdWVcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OFxuICAgICAgICAgICAgLy8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcbiAgICAgICAgICB9IGVsc2UgaWYgKCBjb250ZXh0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdvYmplY3QnICkge1xuXG4gICAgICAgICAgICAvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgaWYgKCAobmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoICdpZCcgKSkgKSB7XG4gICAgICAgICAgICAgIG5pZCA9IG5pZC5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb250ZXh0LnNldEF0dHJpYnV0ZSggJ2lkJywgKG5pZCA9IGV4cGFuZG8pICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuICAgICAgICAgICAgZ3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG4gICAgICAgICAgICBpID0gZ3JvdXBzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgICBncm91cHNbaV0gPSAnIycgKyBuaWQgKyAnICcgKyB0b1NlbGVjdG9yKCBncm91cHNbaV0gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oICcsJyApO1xuXG4gICAgICAgICAgICAvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcbiAgICAgICAgICAgIG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIG5ld1NlbGVjdG9yICkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcHVzaC5hcHBseSggcmVzdWx0cyxcbiAgICAgICAgICAgICAgICBuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9IGNhdGNoICggcXNhRXJyb3IgKSB7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBpZiAoIG5pZCA9PT0gZXhwYW5kbyApIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggJ2lkJyApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWxsIG90aGVyc1xuICAgIHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCAnJDEnICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbiAgfVxuXG4gIC8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbiAgZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcblxuICAgIGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuICAgICAgLy8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1NylcbiAgICAgIGlmICgga2V5cy5wdXNoKCBrZXkgKyAnICcgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG4gICAgICAgIC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuICAgICAgICBkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChjYWNoZVsga2V5ICsgJyAnIF0gPSB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZTtcbiAgfVxuXG4gIC8qKlxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gKi9cbiAgZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcbiAgICBmblsgZXhwYW5kbyBdID0gdHJ1ZTtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICAvKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbiAgZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmaWVsZHNldCcpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAhIWZuKCBlbCApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG4gICAgICBpZiAoIGVsLnBhcmVudE5vZGUgKSB7XG4gICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsICk7XG4gICAgICB9XG4gICAgICAvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuICAgICAgZWwgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbiAgZnVuY3Rpb24gYWRkSGFuZGxlKCBhdHRycywgaGFuZGxlciApIHtcbiAgICB2YXIgYXJyID0gYXR0cnMuc3BsaXQoJ3wnKSxcbiAgICAgIGkgPSBhcnIubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCBpLS0gKSB7XG4gICAgICBFeHByLmF0dHJIYW5kbGVbIGFycltpXSBdID0gaGFuZGxlcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcbiAqL1xuICBmdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG4gICAgdmFyIGN1ciA9IGIgJiYgYSxcbiAgICAgIGRpZmYgPSBjdXIgJiYgYS5ub2RlVHlwZSA9PT0gMSAmJiBiLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRhLnNvdXJjZUluZGV4IC0gYi5zb3VyY2VJbmRleDtcblxuICAgIC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuICAgIGlmICggZGlmZiApIHtcbiAgICAgIHJldHVybiBkaWZmO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG4gICAgaWYgKCBjdXIgKSB7XG4gICAgICB3aGlsZSAoIChjdXIgPSBjdXIubmV4dFNpYmxpbmcpICkge1xuICAgICAgICBpZiAoIGN1ciA9PT0gYiApIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYSA/IDEgOiAtMTtcbiAgfVxuXG4gIC8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuICBmdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICB2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiBuYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbiAgZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuICAgIHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgIHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIChuYW1lID09PSAnaW5wdXQnIHx8IG5hbWUgPT09ICdidXR0b24nKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciA6ZW5hYmxlZC86ZGlzYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcbiAqL1xuICBmdW5jdGlvbiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZGlzYWJsZWQgKSB7XG5cbiAgICAvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcbiAgICByZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cbiAgICAgIC8vIE9ubHkgY2VydGFpbiBlbGVtZW50cyBjYW4gbWF0Y2ggOmVuYWJsZWQgb3IgOmRpc2FibGVkXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1kaXNhYmxlZFxuICAgICAgaWYgKCAnZm9ybScgaW4gZWxlbSApIHtcblxuICAgICAgICAvLyBDaGVjayBmb3IgaW5oZXJpdGVkIGRpc2FibGVkbmVzcyBvbiByZWxldmFudCBub24tZGlzYWJsZWQgZWxlbWVudHM6XG4gICAgICAgIC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG4gICAgICAgIC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjYXRlZ29yeS1saXN0ZWRcbiAgICAgICAgLy8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtZmUtZGlzYWJsZWRcbiAgICAgICAgLy8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuICAgICAgICAvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1vcHRpb24tZGlzYWJsZWRcbiAgICAgICAgLy8gQWxsIHN1Y2ggZWxlbWVudHMgaGF2ZSBhIFwiZm9ybVwiIHByb3BlcnR5LlxuICAgICAgICBpZiAoIGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSApIHtcblxuICAgICAgICAgIC8vIE9wdGlvbiBlbGVtZW50cyBkZWZlciB0byBhIHBhcmVudCBvcHRncm91cCBpZiBwcmVzZW50XG4gICAgICAgICAgaWYgKCAnbGFiZWwnIGluIGVsZW0gKSB7XG4gICAgICAgICAgICBpZiAoICdsYWJlbCcgaW4gZWxlbS5wYXJlbnROb2RlICkge1xuICAgICAgICAgICAgICByZXR1cm4gZWxlbS5wYXJlbnROb2RlLmRpc2FibGVkID09PSBkaXNhYmxlZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA2IC0gMTFcbiAgICAgICAgICAvLyBVc2UgdGhlIGlzRGlzYWJsZWQgc2hvcnRjdXQgcHJvcGVydHkgdG8gY2hlY2sgZm9yIGRpc2FibGVkIGZpZWxkc2V0IGFuY2VzdG9yc1xuICAgICAgICAgIHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cblx0XHRcdFx0XHQvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxuXHRcdFx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0XHRcdGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRkaXNhYmxlZEFuY2VzdG9yKCBlbGVtICkgPT09IGRpc2FibGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXG4gICAgICAgIC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cbiAgICAgICAgLy8gU29tZSB2aWN0aW1zIGdldCBjYXVnaHQgaW4gb3VyIG5ldCAobGFiZWwsIGxlZ2VuZCwgbWVudSwgdHJhY2spLCBidXQgaXQgc2hvdWxkbid0XG4gICAgICAgIC8vIGV2ZW4gZXhpc3Qgb24gdGhlbSwgbGV0IGFsb25lIGhhdmUgYSBib29sZWFuIHZhbHVlLlxuICAgICAgfSBlbHNlIGlmICggJ2xhYmVsJyBpbiBlbGVtICkge1xuICAgICAgICByZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbWFpbmluZyBlbGVtZW50cyBhcmUgbmVpdGhlciA6ZW5hYmxlZCBub3IgOmRpc2FibGVkXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuICBmdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcbiAgICByZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcbiAgICAgIGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuICAgICAgcmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcbiAgICAgICAgdmFyIGosXG4gICAgICAgICAgbWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcbiAgICAgICAgICBpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuICAgICAgICAvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcbiAgICAgICAgd2hpbGUgKCBpLS0gKSB7XG4gICAgICAgICAgaWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcbiAgICAgICAgICAgIHNlZWRbal0gPSAhKG1hdGNoZXNbal0gPSBzZWVkW2pdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gKi9cbiAgZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG4gICAgcmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09ICd1bmRlZmluZWQnICYmIGNvbnRleHQ7XG4gIH1cblxuICAvLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxuICBzdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcblxuICAvKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG4gIGlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgLy8gZG9jdW1lbnRFbGVtZW50IGlzIHZlcmlmaWVkIGZvciBjYXNlcyB3aGVyZSBpdCBkb2Vzbid0IHlldCBleGlzdFxuICAgIC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxuICAgIHZhciBkb2N1bWVudEVsZW1lbnQgPSBlbGVtICYmIChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xuICAgIHJldHVybiBkb2N1bWVudEVsZW1lbnQgPyBkb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgIT09ICdIVE1MJyA6IGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG4gIHNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG4gICAgdmFyIGhhc0NvbXBhcmUsIHN1YldpbmRvdyxcbiAgICAgIGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuICAgIC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG4gICAgaWYgKCBkb2MgPT09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcbiAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlc1xuICAgIGRvY3VtZW50ID0gZG9jO1xuICAgIGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoIGRvY3VtZW50ICk7XG5cbiAgICAvLyBTdXBwb3J0OiBJRSA5LTExLCBFZGdlXG4gICAgLy8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxuICAgIGlmICggcHJlZmVycmVkRG9jICE9PSBkb2N1bWVudCAmJlxuXHRcdChzdWJXaW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldykgJiYgc3ViV2luZG93LnRvcCAhPT0gc3ViV2luZG93ICkge1xuXG4gICAgICAvLyBTdXBwb3J0OiBJRSAxMSwgRWRnZVxuICAgICAgaWYgKCBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcbiAgICAgICAgc3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICd1bmxvYWQnLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG4gICAgICB9IGVsc2UgaWYgKCBzdWJXaW5kb3cuYXR0YWNoRXZlbnQgKSB7XG4gICAgICAgIHN1YldpbmRvdy5hdHRhY2hFdmVudCggJ29udW5sb2FkJywgdW5sb2FkSGFuZGxlciApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gICAgLy8gU3VwcG9ydDogSUU8OFxuICAgIC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xuICAgIC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuICAgIHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG4gICAgICBlbC5jbGFzc05hbWUgPSAnaSc7XG4gICAgICByZXR1cm4gIWVsLmdldEF0dHJpYnV0ZSgnY2xhc3NOYW1lJyk7XG4gICAgfSk7XG5cbiAgICAvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAgIC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcbiAgICBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcbiAgICAgIGVsLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KCcnKSApO1xuICAgICAgcmV0dXJuICFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpLmxlbmd0aDtcbiAgICB9KTtcblxuICAgIC8vIFN1cHBvcnQ6IElFPDlcbiAgICBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuICAgIC8vIFN1cHBvcnQ6IElFPDEwXG4gICAgLy8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXG4gICAgLy8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbW1hdGljYWxseS1zZXQgbmFtZXMsXG4gICAgLy8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG4gICAgc3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcbiAgICAgIGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaWQgPSBleHBhbmRvO1xuICAgICAgcmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XG4gICAgfSk7XG5cbiAgICAvLyBJRCBmaWx0ZXIgYW5kIGZpbmRcbiAgICBpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcbiAgICAgIEV4cHIuZmlsdGVyWydJRCddID0gZnVuY3Rpb24oIGlkICkge1xuICAgICAgICB2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgIHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSgnaWQnKSA9PT0gYXR0cklkO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIEV4cHIuZmluZFsnSUQnXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcbiAgICAgICAgaWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG4gICAgICAgICAgdmFyIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuICAgICAgICAgIHJldHVybiBlbGVtID8gWyBlbGVtIF0gOiBbXTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgRXhwci5maWx0ZXJbJ0lEJ10gPSBmdW5jdGlvbiggaWQgKSB7XG4gICAgICAgIHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSAndW5kZWZpbmVkJyAmJlxuXHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlTm9kZSgnaWQnKTtcbiAgICAgICAgICByZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICAvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XG4gICAgICAvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG4gICAgICBFeHByLmZpbmRbJ0lEJ10gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG4gICAgICAgIGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50SXNIVE1MICkge1xuICAgICAgICAgIHZhciBub2RlLCBpLCBlbGVtcyxcbiAgICAgICAgICAgIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXG4gICAgICAgICAgaWYgKCBlbGVtICkge1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgdGhlIGlkIGF0dHJpYnV0ZVxuICAgICAgICAgICAgbm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSgnaWQnKTtcbiAgICAgICAgICAgIGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFsgZWxlbSBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGYWxsIGJhY2sgb24gZ2V0RWxlbWVudHNCeU5hbWVcbiAgICAgICAgICAgIGVsZW1zID0gY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZSggaWQgKTtcbiAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKCAoZWxlbSA9IGVsZW1zW2krK10pICkge1xuICAgICAgICAgICAgICBub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCdpZCcpO1xuICAgICAgICAgICAgICBpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsgZWxlbSBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFRhZ1xuICAgIEV4cHIuZmluZFsnVEFHJ10gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cbiAgICAgIGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG4gICAgICAgIGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuICAgICAgICAgIC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuICAgICAgICB9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcbiAgICAgICAgfVxuICAgICAgfSA6XG5cbiAgICAgIGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG4gICAgICAgIHZhciBlbGVtLFxuICAgICAgICAgIHRtcCA9IFtdLFxuICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgIC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cbiAgICAgICAgICByZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cbiAgICAgICAgLy8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuICAgICAgICBpZiAoIHRhZyA9PT0gJyonICkge1xuICAgICAgICAgIHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuICAgICAgICAgICAgaWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuICAgICAgICAgICAgICB0bXAucHVzaCggZWxlbSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0bXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9O1xuXG4gICAgLy8gQ2xhc3NcbiAgICBFeHByLmZpbmRbJ0NMQVNTJ10gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcbiAgICAgIGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAgIC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuICAgIC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG4gICAgcmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG4gICAgLy8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcbiAgICAvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3JcbiAgICAvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG4gICAgLy8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3JcbiAgICAvLyBTZWUgaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG4gICAgcmJ1Z2d5UVNBID0gW107XG5cbiAgICBpZiAoIChzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCApKSApIHtcbiAgICAgIC8vIEJ1aWxkIFFTQSByZWdleFxuICAgICAgLy8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuICAgICAgYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcbiAgICAgICAgLy8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuICAgICAgICAvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcbiAgICAgICAgLy8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG4gICAgICAgIC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG4gICAgICAgIC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuICAgICAgICBkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcbiAgICAgICAgLy8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxuICAgICAgICAvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcbiAgICAgICAgLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG4gICAgICAgIGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2FwdHVyZV49JyddXCIpLmxlbmd0aCApIHtcbiAgICAgICAgICByYnVnZ3lRU0EucHVzaCggJ1sqXiRdPScgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFOFxuICAgICAgICAvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG4gICAgICAgIGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tzZWxlY3RlZF0nKS5sZW5ndGggKSB7XG4gICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goICdcXFxcWycgKyB3aGl0ZXNwYWNlICsgJyooPzp2YWx1ZXwnICsgYm9vbGVhbnMgKyAnKScgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuICAgICAgICBpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCAnW2lkfj0nICsgZXhwYW5kbyArICctXScgKS5sZW5ndGggKSB7XG4gICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goJ349Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xuICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuICAgICAgICAvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuICAgICAgICBpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCc6Y2hlY2tlZCcpLmxlbmd0aCApIHtcbiAgICAgICAgICByYnVnZ3lRU0EucHVzaCgnOmNoZWNrZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN1cHBvcnQ6IFNhZmFyaSA4KywgaU9TIDgrXG4gICAgICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcbiAgICAgICAgLy8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2libGluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuICAgICAgICBpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCAnYSMnICsgZXhwYW5kbyArICcrKicgKS5sZW5ndGggKSB7XG4gICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goJy4jLitbK35dJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuICAgICAgICBlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JycgZGlzYWJsZWQ9J2Rpc2FibGVkJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgZGlzYWJsZWQ9J2Rpc2FibGVkJz48b3B0aW9uLz48L3NlbGVjdD5cIjtcblxuICAgICAgICAvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcbiAgICAgICAgLy8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG4gICAgICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSggJ3R5cGUnLCAnaGlkZGVuJyApO1xuICAgICAgICBlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoICduYW1lJywgJ0QnICk7XG5cbiAgICAgICAgLy8gU3VwcG9ydDogSUU4XG4gICAgICAgIC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuICAgICAgICBpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tuYW1lPWRdJykubGVuZ3RoICkge1xuICAgICAgICAgIHJidWdneVFTQS5wdXNoKCAnbmFtZScgKyB3aGl0ZXNwYWNlICsgJypbKl4kfCF+XT89JyApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcbiAgICAgICAgLy8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcbiAgICAgICAgaWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKCc6ZW5hYmxlZCcpLmxlbmd0aCAhPT0gMiApIHtcbiAgICAgICAgICByYnVnZ3lRU0EucHVzaCggJzplbmFibGVkJywgJzpkaXNhYmxlZCcgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFOS0xMStcbiAgICAgICAgLy8gSUUncyA6ZGlzYWJsZWQgc2VsZWN0b3IgZG9lcyBub3QgcGljayB1cCB0aGUgY2hpbGRyZW4gb2YgZGlzYWJsZWQgZmllbGRzZXRzXG4gICAgICAgIGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJzpkaXNhYmxlZCcpLmxlbmd0aCAhPT0gMiApIHtcbiAgICAgICAgICByYnVnZ3lRU0EucHVzaCggJzplbmFibGVkJywgJzpkaXNhYmxlZCcgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG4gICAgICAgIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJyosOngnKTtcbiAgICAgICAgcmJ1Z2d5UVNBLnB1c2goJywuKjonKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICggKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcblxuICAgICAgYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcbiAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG4gICAgICAgIC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG4gICAgICAgIHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGVsLCAnKicgKTtcblxuICAgICAgICAvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG4gICAgICAgIC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcbiAgICAgICAgbWF0Y2hlcy5jYWxsKCBlbCwgXCJbcyE9JyddOnhcIiApO1xuICAgICAgICByYnVnZ3lNYXRjaGVzLnB1c2goICchPScsIHBzZXVkb3MgKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oJ3wnKSApO1xuICAgIHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oJ3wnKSApO1xuXG4gICAgLyogQ29udGFpbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICAgIGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24gKTtcblxuICAgIC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuICAgIC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuICAgIC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG4gICAgY29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb250YWlucyApID9cbiAgICAgIGZ1bmN0aW9uKCBhLCBiICkge1xuICAgICAgICB2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuICAgICAgICAgIGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuICAgICAgICByZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcbiAgICAgICAgICBhZG93bi5jb250YWlucyA/XG4gICAgICAgICAgICBhZG93bi5jb250YWlucyggYnVwICkgOlxuICAgICAgICAgICAgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG4gICAgICAgICkpO1xuICAgICAgfSA6XG4gICAgICBmdW5jdGlvbiggYSwgYiApIHtcbiAgICAgICAgaWYgKCBiICkge1xuICAgICAgICAgIHdoaWxlICggKGIgPSBiLnBhcmVudE5vZGUpICkge1xuICAgICAgICAgICAgaWYgKCBiID09PSBhICkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcblxuICAgIC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gICAgLy8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuICAgIHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuICAgICAgZnVuY3Rpb24oIGEsIGIgKSB7XG5cbiAgICAgICAgLy8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcbiAgICAgICAgaWYgKCBhID09PSBiICkge1xuICAgICAgICAgIGhhc0R1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG4gICAgICAgIHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcbiAgICAgICAgaWYgKCBjb21wYXJlICkge1xuICAgICAgICAgIHJldHVybiBjb21wYXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuICAgICAgICBjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgP1xuICAgICAgICAgIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG4gICAgICAgICAgMTtcblxuICAgICAgICAvLyBEaXNjb25uZWN0ZWQgbm9kZXNcbiAgICAgICAgaWYgKCBjb21wYXJlICYgMSB8fFxuXHRcdFx0KCFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBhICkgPT09IGNvbXBhcmUpICkge1xuXG4gICAgICAgICAgLy8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG4gICAgICAgICAgaWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikgKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuICAgICAgICAgIHJldHVybiBzb3J0SW5wdXQgP1xuICAgICAgICAgICAgKCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuICAgICAgICAgICAgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcbiAgICAgIH0gOlxuICAgICAgZnVuY3Rpb24oIGEsIGIgKSB7XG4gICAgICAgIC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcbiAgICAgICAgaWYgKCBhID09PSBiICkge1xuICAgICAgICAgIGhhc0R1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3VyLFxuICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgIGF1cCA9IGEucGFyZW50Tm9kZSxcbiAgICAgICAgICBidXAgPSBiLnBhcmVudE5vZGUsXG4gICAgICAgICAgYXAgPSBbIGEgXSxcbiAgICAgICAgICBicCA9IFsgYiBdO1xuXG4gICAgICAgIC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG4gICAgICAgIGlmICggIWF1cCB8fCAhYnVwICkge1xuICAgICAgICAgIHJldHVybiBhID09PSBkb2N1bWVudCA/IC0xIDpcbiAgICAgICAgICAgIGIgPT09IGRvY3VtZW50ID8gMSA6XG4gICAgICAgICAgICAgIGF1cCA/IC0xIDpcbiAgICAgICAgICAgICAgICBidXAgPyAxIDpcbiAgICAgICAgICAgICAgICAgIHNvcnRJbnB1dCA/XG4gICAgICAgICAgICAgICAgICAgICggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcbiAgICAgICAgICAgICAgICAgICAgMDtcblxuICAgICAgICAgIC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG4gICAgICAgIH0gZWxzZSBpZiAoIGF1cCA9PT0gYnVwICkge1xuICAgICAgICAgIHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXG4gICAgICAgIGN1ciA9IGE7XG4gICAgICAgIHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcbiAgICAgICAgICBhcC51bnNoaWZ0KCBjdXIgKTtcbiAgICAgICAgfVxuICAgICAgICBjdXIgPSBiO1xuICAgICAgICB3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG4gICAgICAgICAgYnAudW5zaGlmdCggY3VyICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuICAgICAgICB3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaSA/XG4gICAgICAgIC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxuICAgICAgICAgIHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG4gICAgICAgIC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxuICAgICAgICAgIGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG4gICAgICAgICAgICBicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG4gICAgICAgICAgICAgIDA7XG4gICAgICB9O1xuXG4gICAgcmV0dXJuIGRvY3VtZW50O1xuICB9O1xuXG4gIFNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuICAgIHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XG4gIH07XG5cbiAgU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuICAgIC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuICAgIGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcbiAgICAgIHNldERvY3VtZW50KCBlbGVtICk7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgYXR0cmlidXRlIHNlbGVjdG9ycyBhcmUgcXVvdGVkXG4gICAgZXhwciA9IGV4cHIucmVwbGFjZSggcmF0dHJpYnV0ZVF1b3RlcywgXCI9JyQxJ11cIiApO1xuXG4gICAgaWYgKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdCFjb21waWxlckNhY2hlWyBleHByICsgJyAnIF0gJiZcblx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0KCAhcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggZXhwciApICkgKSB7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuICAgICAgICAvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG4gICAgICAgIGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgcmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcbiAgfTtcblxuICBTaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcbiAgICAvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcbiAgICBpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG4gICAgICBzZXREb2N1bWVudCggY29udGV4dCApO1xuICAgIH1cbiAgICByZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbiAgfTtcblxuICBTaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuICAgIC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuICAgIGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcbiAgICAgIHNldERvY3VtZW50KCBlbGVtICk7XG4gICAgfVxuXG4gICAgdmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcbiAgICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuICAgICAgdmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuICAgICAgICBmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuICAgICAgdmFsIDpcbiAgICAgIHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xuICAgICAgICBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcbiAgICAgICAgKHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZCA/XG4gICAgICAgICAgdmFsLnZhbHVlIDpcbiAgICAgICAgICBudWxsO1xuICB9O1xuXG4gIFNpenpsZS5lc2NhcGUgPSBmdW5jdGlvbiggc2VsICkge1xuICAgIHJldHVybiAoc2VsICsgJycpLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcbiAgfTtcblxuICBTaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuICAgIHRocm93IG5ldyBFcnJvciggJ1N5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246ICcgKyBtc2cgKTtcbiAgfTtcblxuICAvKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cbiAgU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcbiAgICB2YXIgZWxlbSxcbiAgICAgIGR1cGxpY2F0ZXMgPSBbXSxcbiAgICAgIGogPSAwLFxuICAgICAgaSA9IDA7XG5cbiAgICAvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG4gICAgaGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcbiAgICBzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcbiAgICByZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG4gICAgaWYgKCBoYXNEdXBsaWNhdGUgKSB7XG4gICAgICB3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcbiAgICAgICAgaWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG4gICAgICAgICAgaiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoIGotLSApIHtcbiAgICAgICAgcmVzdWx0cy5zcGxpY2UoIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG4gICAgc29ydElucHV0ID0gbnVsbDtcblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG4gIGdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgIHZhciBub2RlLFxuICAgICAgcmV0ID0gJycsXG4gICAgICBpID0gMCxcbiAgICAgIG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuICAgIGlmICggIW5vZGVUeXBlICkge1xuICAgICAgLy8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcbiAgICAgIHdoaWxlICggKG5vZGUgPSBlbGVtW2krK10pICkge1xuICAgICAgICAvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuICAgICAgICByZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcbiAgICAgIC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcbiAgICAgIC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXG4gICAgICBpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgcmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cbiAgICAgICAgZm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG4gICAgICAgICAgcmV0ICs9IGdldFRleHQoIGVsZW0gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuICAgICAgcmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuICAgIH1cbiAgICAvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cbiAgICAvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcbiAgICBjYWNoZUxlbmd0aDogNTAsXG5cbiAgICBjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuICAgIG1hdGNoOiBtYXRjaEV4cHIsXG5cbiAgICBhdHRySGFuZGxlOiB7fSxcblxuICAgIGZpbmQ6IHt9LFxuXG4gICAgcmVsYXRpdmU6IHtcbiAgICAgICc+JzogeyBkaXI6ICdwYXJlbnROb2RlJywgZmlyc3Q6IHRydWUgfSxcbiAgICAgICcgJzogeyBkaXI6ICdwYXJlbnROb2RlJyB9LFxuICAgICAgJysnOiB7IGRpcjogJ3ByZXZpb3VzU2libGluZycsIGZpcnN0OiB0cnVlIH0sXG4gICAgICAnfic6IHsgZGlyOiAncHJldmlvdXNTaWJsaW5nJyB9XG4gICAgfSxcblxuICAgIHByZUZpbHRlcjoge1xuICAgICAgJ0FUVFInOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG4gICAgICAgIG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuICAgICAgICAvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuICAgICAgICBtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgJycgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG4gICAgICAgIGlmICggbWF0Y2hbMl0gPT09ICd+PScgKSB7XG4gICAgICAgICAgbWF0Y2hbM10gPSAnICcgKyBtYXRjaFszXSArICcgJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuICAgICAgfSxcblxuICAgICAgJ0NISUxEJzogZnVuY3Rpb24oIG1hdGNoICkge1xuICAgICAgICAvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuICAgICAgICBtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgaWYgKCBtYXRjaFsxXS5zbGljZSggMCwgMyApID09PSAnbnRoJyApIHtcbiAgICAgICAgICAvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuICAgICAgICAgIGlmICggIW1hdGNoWzNdICkge1xuICAgICAgICAgICAgU2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuICAgICAgICAgIC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcbiAgICAgICAgICBtYXRjaFs0XSA9ICsoIG1hdGNoWzRdID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSkgOiAyICogKCBtYXRjaFszXSA9PT0gJ2V2ZW4nIHx8IG1hdGNoWzNdID09PSAnb2RkJyApICk7XG4gICAgICAgICAgbWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gJ29kZCcgKTtcblxuICAgICAgICAgIC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuICAgICAgICB9IGVsc2UgaWYgKCBtYXRjaFszXSApIHtcbiAgICAgICAgICBTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9LFxuXG4gICAgICAnUFNFVURPJzogZnVuY3Rpb24oIG1hdGNoICkge1xuICAgICAgICB2YXIgZXhjZXNzLFxuICAgICAgICAgIHVucXVvdGVkID0gIW1hdGNoWzZdICYmIG1hdGNoWzJdO1xuXG4gICAgICAgIGlmICggbWF0Y2hFeHByWydDSElMRCddLnRlc3QoIG1hdGNoWzBdICkgKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuICAgICAgICBpZiAoIG1hdGNoWzNdICkge1xuICAgICAgICAgIG1hdGNoWzJdID0gbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgJyc7XG5cbiAgICAgICAgICAvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuICAgICAgICB9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoICcpJywgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGgpICkge1xuXG4gICAgICAgICAgLy8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcbiAgICAgICAgICBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwLCBleGNlc3MgKTtcbiAgICAgICAgICBtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuICAgICAgICByZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDMgKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZmlsdGVyOiB7XG5cbiAgICAgICdUQUcnOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcbiAgICAgICAgdmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSAnKicgP1xuICAgICAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSA6XG4gICAgICAgICAgZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuICAgICAgICAgIH07XG4gICAgICB9LFxuXG4gICAgICAnQ0xBU1MnOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuICAgICAgICB2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArICcgJyBdO1xuXG4gICAgICAgIHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggJyhefCcgKyB3aGl0ZXNwYWNlICsgJyknICsgY2xhc3NOYW1lICsgJygnICsgd2hpdGVzcGFjZSArICd8JCknICkpICYmXG5cdFx0XHRcdGNsYXNzQ2FjaGUoIGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdCAgcmV0dXJuIHBhdHRlcm4udGVzdCggdHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSAnc3RyaW5nJyAmJiBlbGVtLmNsYXNzTmFtZSB8fCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09ICd1bmRlZmluZWQnICYmIGVsZW0uZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnICk7XG5cdFx0XHRcdH0pO1xuICAgICAgfSxcblxuICAgICAgJ0FUVFInOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cbiAgICAgICAgICBpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuICAgICAgICAgICAgcmV0dXJuIG9wZXJhdG9yID09PSAnIT0nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoICFvcGVyYXRvciApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdCArPSAnJztcblxuICAgICAgICAgIHJldHVybiBvcGVyYXRvciA9PT0gJz0nID8gcmVzdWx0ID09PSBjaGVjayA6XG4gICAgICAgICAgICBvcGVyYXRvciA9PT0gJyE9JyA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuICAgICAgICAgICAgICBvcGVyYXRvciA9PT0gJ149JyA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwIDpcbiAgICAgICAgICAgICAgICBvcGVyYXRvciA9PT0gJyo9JyA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPT09ICckPScgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9PT0gJ349JyA/ICggJyAnICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCAnICcgKSArICcgJyApLmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG4gICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPT09ICd8PScgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArICctJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgIH0sXG5cbiAgICAgICdDSElMRCc6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBhcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG4gICAgICAgIHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09ICdudGgnLFxuICAgICAgICAgIGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSAnbGFzdCcsXG4gICAgICAgICAgb2ZUeXBlID0gd2hhdCA9PT0gJ29mLXR5cGUnO1xuXG4gICAgICAgIHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuICAgICAgICAvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG4gICAgICAgICAgZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICByZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG4gICAgICAgICAgfSA6XG5cbiAgICAgICAgICBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuICAgICAgICAgICAgdmFyIGNhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgbm9kZUluZGV4LCBzdGFydCxcbiAgICAgICAgICAgICAgZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gJ25leHRTaWJsaW5nJyA6ICdwcmV2aW91c1NpYmxpbmcnLFxuICAgICAgICAgICAgICBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgIG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICB1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcbiAgICAgICAgICAgICAgZGlmZiA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoIHBhcmVudCApIHtcblxuICAgICAgICAgICAgICAvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG4gICAgICAgICAgICAgIGlmICggc2ltcGxlICkge1xuICAgICAgICAgICAgICAgIHdoaWxlICggZGlyICkge1xuICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsZW07XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoIChub2RlID0gbm9kZVsgZGlyIF0pICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIG9mVHlwZSA/XG4gICAgICAgICAgICAgICAgICAgICAgbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcbiAgICAgICAgICAgICAgICAgICAgICBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcbiAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gJ29ubHknICYmICFzdGFydCAmJiAnbmV4dFNpYmxpbmcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cbiAgICAgICAgICAgICAgLy8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcbiAgICAgICAgICAgICAgaWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuXG4gICAgICAgICAgICAgICAgLy8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cbiAgICAgICAgICAgICAgICAvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICBvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG4gICAgICAgICAgICAgICAgLy8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG4gICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG4gICAgICAgICAgICAgICAgY2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcbiAgICAgICAgICAgICAgICBkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRmFsbGJhY2sgdG8gc2Vla2luZyBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuICAgICAgICAgICAgICAgICAgLy8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcbiAgICAgICAgICAgICAgICAgIGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgbm9kZUluZGV4LCBkaWZmIF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIGlmICggdXNlQ2FjaGUgKSB7XG4gICAgICAgICAgICAgICAgICAvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG4gICAgICAgICAgICAgICAgICBub2RlID0gZWxlbTtcbiAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPDkgb25seVxuICAgICAgICAgICAgICAgICAgLy8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG4gICAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuICAgICAgICAgICAgICAgICAgY2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgbm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuICAgICAgICAgICAgICAgICAgZGlmZiA9IG5vZGVJbmRleDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB4bWwgOm50aC1jaGlsZCguLi4pXG4gICAgICAgICAgICAgICAgLy8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuICAgICAgICAgICAgICAgIGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuICAgICAgICAgICAgICAgICAgd2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggKCBvZlR5cGUgP1xuICAgICAgICAgICAgICAgICAgICAgIG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG4gICAgICAgICAgICAgICAgICAgICAgbm9kZS5ub2RlVHlwZSA9PT0gMSApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCsrZGlmZiApIHtcblxuICAgICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIHVzZUNhY2hlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCBub2RlID09PSBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcbiAgICAgICAgICAgICAgZGlmZiAtPSBsYXN0O1xuICAgICAgICAgICAgICByZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgJ1BTRVVETyc6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuICAgICAgICAvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcbiAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuICAgICAgICAvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuICAgICAgICAvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG4gICAgICAgIHZhciBhcmdzLFxuICAgICAgICAgIGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoICd1bnN1cHBvcnRlZCBwc2V1ZG86ICcgKyBwc2V1ZG8gKTtcblxuICAgICAgICAvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG4gICAgICAgIC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG4gICAgICAgIC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcbiAgICAgICAgaWYgKCBmblsgZXhwYW5kbyBdICkge1xuICAgICAgICAgIHJldHVybiBmbiggYXJndW1lbnQgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuICAgICAgICBpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG4gICAgICAgICAgYXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sICcnLCBhcmd1bWVudCBdO1xuICAgICAgICAgIHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuICAgICAgICAgICAgbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuICAgICAgICAgICAgICB2YXIgaWR4LFxuICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcbiAgICAgICAgICAgICAgICBpID0gbWF0Y2hlZC5sZW5ndGg7XG4gICAgICAgICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgICAgIGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbaV0gKTtcbiAgICAgICAgICAgICAgICBzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFtpXSApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSA6XG4gICAgICAgICAgICBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBwc2V1ZG9zOiB7XG4gICAgICAvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3NcbiAgICAgICdub3QnOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuICAgICAgICAvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuICAgICAgICAvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuICAgICAgICAvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcbiAgICAgICAgdmFyIGlucHV0ID0gW10sXG4gICAgICAgICAgcmVzdWx0cyA9IFtdLFxuICAgICAgICAgIG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgJyQxJyApICk7XG5cbiAgICAgICAgcmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG4gICAgICAgICAgbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBjb250ZXh0LCB4bWwgKSB7XG4gICAgICAgICAgICB2YXIgZWxlbSxcbiAgICAgICAgICAgICAgdW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuICAgICAgICAgICAgICBpID0gc2VlZC5sZW5ndGg7XG5cbiAgICAgICAgICAgIC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcbiAgICAgICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgICBpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcbiAgICAgICAgICAgICAgICBzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSA6XG4gICAgICAgICAgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcbiAgICAgICAgICAgIGlucHV0WzBdID0gZWxlbTtcbiAgICAgICAgICAgIG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcbiAgICAgICAgICAgIC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG4gICAgICAgICAgICBpbnB1dFswXSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gIXJlc3VsdHMucG9wKCk7XG4gICAgICAgICAgfTtcbiAgICAgIH0pLFxuXG4gICAgICAnaGFzJzogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgIHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcbiAgICAgICAgfTtcbiAgICAgIH0pLFxuXG4gICAgICAnY29udGFpbnMnOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHRleHQgKSB7XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICByZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJUZXh0IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuICAgICAgICB9O1xuICAgICAgfSksXG5cbiAgICAgIC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuICAgICAgLy8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcbiAgICAgIC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXG4gICAgICAvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuICAgICAgLy8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG4gICAgICAvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXG4gICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG4gICAgICAnbGFuZyc6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG4gICAgICAgIC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcbiAgICAgICAgaWYgKCAhcmlkZW50aWZpZXIudGVzdChsYW5nIHx8ICcnKSApIHtcbiAgICAgICAgICBTaXp6bGUuZXJyb3IoICd1bnN1cHBvcnRlZCBsYW5nOiAnICsgbGFuZyApO1xuICAgICAgICB9XG4gICAgICAgIGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgIHZhciBlbGVtTGFuZztcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoIChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cbiAgICAgICAgICAgICAgZWxlbS5sYW5nIDpcbiAgICAgICAgICAgICAgZWxlbS5nZXRBdHRyaWJ1dGUoJ3htbDpsYW5nJykgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoJ2xhbmcnKSkgKSB7XG5cbiAgICAgICAgICAgICAgZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArICctJyApID09PSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKCAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgIH0pLFxuXG4gICAgICAvLyBNaXNjZWxsYW5lb3VzXG4gICAgICAndGFyZ2V0JzogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgIHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuICAgICAgICByZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG4gICAgICB9LFxuXG4gICAgICAncm9vdCc6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICByZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcbiAgICAgIH0sXG5cbiAgICAgICdmb2N1cyc6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICByZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkpICYmICEhKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXgpO1xuICAgICAgfSxcblxuICAgICAgLy8gQm9vbGVhbiBwcm9wZXJ0aWVzXG4gICAgICAnZW5hYmxlZCc6IGNyZWF0ZURpc2FibGVkUHNldWRvKCBmYWxzZSApLFxuICAgICAgJ2Rpc2FibGVkJzogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIHRydWUgKSxcblxuICAgICAgJ2NoZWNrZWQnOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgLy8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXG4gICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG4gICAgICAgIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIChub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSAnb3B0aW9uJyAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuICAgICAgfSxcblxuICAgICAgJ3NlbGVjdGVkJzogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgIC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcbiAgICAgICAgLy8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuICAgICAgICBpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcbiAgICAgICAgICBlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuICAgICAgfSxcblxuICAgICAgLy8gQ29udGVudHNcbiAgICAgICdlbXB0eSc6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuICAgICAgICAvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG4gICAgICAgIC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG4gICAgICAgIC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cbiAgICAgICAgZm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG4gICAgICAgICAgaWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuXG4gICAgICAncGFyZW50JzogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgIHJldHVybiAhRXhwci5wc2V1ZG9zWydlbXB0eSddKCBlbGVtICk7XG4gICAgICB9LFxuXG4gICAgICAvLyBFbGVtZW50L2lucHV0IHR5cGVzXG4gICAgICAnaGVhZGVyJzogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgIHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcbiAgICAgIH0sXG5cbiAgICAgICdpbnB1dCc6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICByZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG4gICAgICB9LFxuXG4gICAgICAnYnV0dG9uJzogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgIHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gbmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICdidXR0b24nIHx8IG5hbWUgPT09ICdidXR0b24nO1xuICAgICAgfSxcblxuICAgICAgJ3RleHQnOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgdmFyIGF0dHI7XG4gICAgICAgIHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSAndGV4dCcgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw4XG5cdFx0XHRcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXG5cdFx0XHRcdCggKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZSgndHlwZScpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gJ3RleHQnICk7XG4gICAgICB9LFxuXG4gICAgICAvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXG4gICAgICAnZmlyc3QnOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gWyAwIF07XG4gICAgICB9KSxcblxuICAgICAgJ2xhc3QnOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcbiAgICAgICAgcmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuICAgICAgfSksXG5cbiAgICAgICdlcSc6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcbiAgICAgICAgcmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuICAgICAgfSksXG5cbiAgICAgICdldmVuJzogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgZm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG4gICAgICAgICAgbWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF0Y2hJbmRleGVzO1xuICAgICAgfSksXG5cbiAgICAgICdvZGQnOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcbiAgICAgICAgdmFyIGkgPSAxO1xuICAgICAgICBmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcbiAgICAgICAgICBtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXRjaEluZGV4ZXM7XG4gICAgICB9KSxcblxuICAgICAgJ2x0JzogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuICAgICAgICB2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG4gICAgICAgIGZvciAoIDsgLS1pID49IDA7ICkge1xuICAgICAgICAgIG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoSW5kZXhlcztcbiAgICAgIH0pLFxuXG4gICAgICAnZ3QnOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG4gICAgICAgIHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcbiAgICAgICAgZm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuICAgICAgICAgIG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoSW5kZXhlcztcbiAgICAgIH0pXG4gICAgfVxuICB9O1xuXG4gIEV4cHIucHNldWRvc1snbnRoJ10gPSBFeHByLnBzZXVkb3NbJ2VxJ107XG5cbiAgLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbiAgZm9yICggaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0gKSB7XG4gICAgRXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xuICB9XG4gIGZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0gKSB7XG4gICAgRXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbiAgfVxuXG4gIC8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuICBmdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbiAgc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG4gIEV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG5cbiAgdG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcbiAgICB2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcbiAgICAgIHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG4gICAgICBjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArICcgJyBdO1xuXG4gICAgaWYgKCBjYWNoZWQgKSB7XG4gICAgICByZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuICAgIH1cblxuICAgIHNvRmFyID0gc2VsZWN0b3I7XG4gICAgZ3JvdXBzID0gW107XG4gICAgcHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG4gICAgd2hpbGUgKCBzb0ZhciApIHtcblxuICAgICAgLy8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuICAgICAgaWYgKCAhbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSkgKSB7XG4gICAgICAgIGlmICggbWF0Y2ggKSB7XG4gICAgICAgICAgLy8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcbiAgICAgICAgICBzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFswXS5sZW5ndGggKSB8fCBzb0ZhcjtcbiAgICAgICAgfVxuICAgICAgICBncm91cHMucHVzaCggKHRva2VucyA9IFtdKSApO1xuICAgICAgfVxuXG4gICAgICBtYXRjaGVkID0gZmFsc2U7XG5cbiAgICAgIC8vIENvbWJpbmF0b3JzXG4gICAgICBpZiAoIChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKCBzb0ZhciApKSApIHtcbiAgICAgICAgbWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICB2YWx1ZTogbWF0Y2hlZCxcbiAgICAgICAgICAvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2VcbiAgICAgICAgICB0eXBlOiBtYXRjaFswXS5yZXBsYWNlKCBydHJpbSwgJyAnIClcbiAgICAgICAgfSk7XG4gICAgICAgIHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbHRlcnNcbiAgICAgIGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG4gICAgICAgIGlmICggKG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSkgJiYgKCFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApKSkgKSB7XG4gICAgICAgICAgbWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG4gICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdmFsdWU6IG1hdGNoZWQsXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgbWF0Y2hlczogbWF0Y2hcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICggIW1hdGNoZWQgKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuICAgIC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuICAgIC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuICAgIHJldHVybiBwYXJzZU9ubHkgP1xuICAgICAgc29GYXIubGVuZ3RoIDpcbiAgICAgIHNvRmFyID9cbiAgICAgICAgU2l6emxlLmVycm9yKCBzZWxlY3RvciApIDpcbiAgICAgIC8vIENhY2hlIHRoZSB0b2tlbnNcbiAgICAgICAgdG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG4gIH07XG5cbiAgZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuICAgIHZhciBpID0gMCxcbiAgICAgIGxlbiA9IHRva2Vucy5sZW5ndGgsXG4gICAgICBzZWxlY3RvciA9ICcnO1xuICAgIGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgc2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuICAgIHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcbiAgICAgIHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG4gICAgICBrZXkgPSBza2lwIHx8IGRpcixcbiAgICAgIGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGtleSA9PT0gJ3BhcmVudE5vZGUnLFxuICAgICAgZG9uZU5hbWUgPSBkb25lKys7XG5cbiAgICByZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG4gICAgLy8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG4gICAgICBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuICAgICAgICB3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuICAgICAgICAgIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IDpcblxuICAgIC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuICAgICAgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcbiAgICAgICAgdmFyIG9sZENhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSxcbiAgICAgICAgICBuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuICAgICAgICAvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcbiAgICAgICAgaWYgKCB4bWwgKSB7XG4gICAgICAgICAgd2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcbiAgICAgICAgICAgIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuICAgICAgICAgICAgICBpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG4gICAgICAgICAgICBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcbiAgICAgICAgICAgICAgb3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXG4gICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcbiAgICAgICAgICAgICAgLy8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG4gICAgICAgICAgICAgIHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8IChvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSk7XG5cbiAgICAgICAgICAgICAgaWYgKCBza2lwICYmIHNraXAgPT09IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSApIHtcbiAgICAgICAgICAgICAgICBlbGVtID0gZWxlbVsgZGlyIF0gfHwgZWxlbTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGtleSBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG4gICAgICAgICAgICAgICAgLy8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcbiAgICAgICAgICAgICAgICByZXR1cm4gKG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGVbIGtleSBdID0gbmV3Q2FjaGU7XG5cbiAgICAgICAgICAgICAgICAvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcbiAgICAgICAgICAgICAgICBpZiAoIChuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkpICkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSB7XG4gICAgcmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuICAgICAgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcbiAgICAgICAgdmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgIGlmICggIW1hdGNoZXJzW2ldKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IDpcbiAgICAgIG1hdGNoZXJzWzBdO1xuICB9XG5cbiAgZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuICAgIHZhciBpID0gMCxcbiAgICAgIGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcbiAgICBmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHRzW2ldLCByZXN1bHRzICk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgZnVuY3Rpb24gY29uZGVuc2UoIHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCApIHtcbiAgICB2YXIgZWxlbSxcbiAgICAgIG5ld1VubWF0Y2hlZCA9IFtdLFxuICAgICAgaSA9IDAsXG4gICAgICBsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuICAgICAgbWFwcGVkID0gbWFwICE9IG51bGw7XG5cbiAgICBmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgIGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuICAgICAgICBpZiAoICFmaWx0ZXIgfHwgZmlsdGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcbiAgICAgICAgICBuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xuICAgICAgICAgIGlmICggbWFwcGVkICkge1xuICAgICAgICAgICAgbWFwLnB1c2goIGkgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3VW5tYXRjaGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuICAgIGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuICAgICAgcG9zdEZpbHRlciA9IHNldE1hdGNoZXIoIHBvc3RGaWx0ZXIgKTtcbiAgICB9XG4gICAgaWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG4gICAgICBwb3N0RmluZGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcbiAgICAgIHZhciB0ZW1wLCBpLCBlbGVtLFxuICAgICAgICBwcmVNYXAgPSBbXSxcbiAgICAgICAgcG9zdE1hcCA9IFtdLFxuICAgICAgICBwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuXG4gICAgICAgIC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG4gICAgICAgIGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCAnKicsIGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsIFtdICksXG5cbiAgICAgICAgLy8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG4gICAgICAgIG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuICAgICAgICAgIGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcbiAgICAgICAgICBlbGVtcyxcblxuICAgICAgICBtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXG4gICAgICAgICAgcG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG4gICAgICAgICAgLy8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG4gICAgICAgICAgICBbXSA6XG5cbiAgICAgICAgICAvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcbiAgICAgICAgICAgIHJlc3VsdHMgOlxuICAgICAgICAgIG1hdGNoZXJJbjtcblxuICAgICAgLy8gRmluZCBwcmltYXJ5IG1hdGNoZXNcbiAgICAgIGlmICggbWF0Y2hlciApIHtcbiAgICAgICAgbWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcbiAgICAgIH1cblxuICAgICAgLy8gQXBwbHkgcG9zdEZpbHRlclxuICAgICAgaWYgKCBwb3N0RmlsdGVyICkge1xuICAgICAgICB0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcbiAgICAgICAgcG9zdEZpbHRlciggdGVtcCwgW10sIGNvbnRleHQsIHhtbCApO1xuXG4gICAgICAgIC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cbiAgICAgICAgaSA9IHRlbXAubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgICBpZiAoIChlbGVtID0gdGVtcFtpXSkgKSB7XG4gICAgICAgICAgICBtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICggc2VlZCApIHtcbiAgICAgICAgaWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcbiAgICAgICAgICBpZiAoIHBvc3RGaW5kZXIgKSB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcbiAgICAgICAgICAgIHRlbXAgPSBbXTtcbiAgICAgICAgICAgIGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgICBpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcbiAgICAgICAgICAgICAgICB0ZW1wLnB1c2goIChtYXRjaGVySW5baV0gPSBlbGVtKSApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3N0RmluZGVyKCBudWxsLCAobWF0Y2hlck91dCA9IFtdKSwgdGVtcCwgeG1sICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcbiAgICAgICAgICBpID0gbWF0Y2hlck91dC5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKCBpLS0gKSB7XG4gICAgICAgICAgICBpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuICAgICAgICAgICAgICBzZWVkW3RlbXBdID0gIShyZXN1bHRzW3RlbXBdID0gZWxlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG4gICAgICAgICAgbWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG4gICAgICAgICAgICBtYXRjaGVyT3V0LnNwbGljZSggcHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoICkgOlxuICAgICAgICAgICAgbWF0Y2hlck91dFxuICAgICAgICApO1xuICAgICAgICBpZiAoIHBvc3RGaW5kZXIgKSB7XG4gICAgICAgICAgcG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuICAgIHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG4gICAgICBsZW4gPSB0b2tlbnMubGVuZ3RoLFxuICAgICAgbGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcbiAgICAgIGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVsnICddLFxuICAgICAgaSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG4gICAgICAvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuICAgICAgbWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgIHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG4gICAgICB9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG4gICAgICBtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgcmV0dXJuIGluZGV4T2YoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG4gICAgICB9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG4gICAgICBtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcbiAgICAgICAgdmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG4gICAgICAgICAgKGNoZWNrQ29udGV4dCA9IGNvbnRleHQpLm5vZGVUeXBlID9cbiAgICAgICAgICAgIG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuICAgICAgICAgICAgbWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xuICAgICAgICAvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcbiAgICAgICAgY2hlY2tDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0gXTtcblxuICAgIGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgaWYgKCAobWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1tpXS50eXBlIF0pICkge1xuICAgICAgICBtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlcikgXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoZXIgPSBFeHByLmZpbHRlclsgdG9rZW5zW2ldLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zW2ldLm1hdGNoZXMgKTtcblxuICAgICAgICAvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuICAgICAgICBpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcbiAgICAgICAgICAvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcbiAgICAgICAgICBqID0gKytpO1xuICAgICAgICAgIGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuICAgICAgICAgICAgaWYgKCBFeHByLnJlbGF0aXZlWyB0b2tlbnNbal0udHlwZSBdICkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNldE1hdGNoZXIoXG4gICAgICAgICAgICBpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcbiAgICAgICAgICAgIGkgPiAxICYmIHRvU2VsZWN0b3IoXG4gICAgICAgICAgICAgIC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG4gICAgICAgICAgICAgIHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09ICcgJyA/ICcqJyA6ICcnIH0pXG4gICAgICAgICAgICApLnJlcGxhY2UoIHJ0cmltLCAnJDEnICksXG4gICAgICAgICAgICBtYXRjaGVyLFxuICAgICAgICAgICAgaSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXG4gICAgICAgICAgICBqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG4gICAgICAgICAgICBqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuICAgIHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG4gICAgICBieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcbiAgICAgIHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcbiAgICAgICAgdmFyIGVsZW0sIGosIG1hdGNoZXIsXG4gICAgICAgICAgbWF0Y2hlZENvdW50ID0gMCxcbiAgICAgICAgICBpID0gJzAnLFxuICAgICAgICAgIHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG4gICAgICAgICAgc2V0TWF0Y2hlZCA9IFtdLFxuICAgICAgICAgIGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuICAgICAgICAgIC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcbiAgICAgICAgICBlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFsnVEFHJ10oICcqJywgb3V0ZXJtb3N0ICksXG4gICAgICAgICAgLy8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcbiAgICAgICAgICBkaXJydW5zVW5pcXVlID0gKGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xKSxcbiAgICAgICAgICBsZW4gPSBlbGVtcy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKCBvdXRlcm1vc3QgKSB7XG4gICAgICAgICAgb3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgPT09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcbiAgICAgICAgLy8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG4gICAgICAgIC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxuICAgICAgICBmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG4gICAgICAgICAgaWYgKCBieUVsZW1lbnQgJiYgZWxlbSApIHtcbiAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgaWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICkge1xuICAgICAgICAgICAgICBzZXREb2N1bWVudCggZWxlbSApO1xuICAgICAgICAgICAgICB4bWwgPSAhZG9jdW1lbnRJc0hUTUw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoIChtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzW2orK10pICkge1xuICAgICAgICAgICAgICBpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCkgKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKCBlbGVtICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggb3V0ZXJtb3N0ICkge1xuICAgICAgICAgICAgICBkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUcmFjayB1bm1hdGNoZWQgZWxlbWVudHMgZm9yIHNldCBmaWx0ZXJzXG4gICAgICAgICAgaWYgKCBieVNldCApIHtcbiAgICAgICAgICAgIC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcbiAgICAgICAgICAgIGlmICggKGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtKSApIHtcbiAgICAgICAgICAgICAgbWF0Y2hlZENvdW50LS07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3RcbiAgICAgICAgICAgIGlmICggc2VlZCApIHtcbiAgICAgICAgICAgICAgdW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBgaWAgaXMgbm93IHRoZSBjb3VudCBvZiBlbGVtZW50cyB2aXNpdGVkIGFib3ZlLCBhbmQgYWRkaW5nIGl0IHRvIGBtYXRjaGVkQ291bnRgXG4gICAgICAgIC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG4gICAgICAgIG1hdGNoZWRDb3VudCArPSBpO1xuXG4gICAgICAgIC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuICAgICAgICAvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG4gICAgICAgIC8vIGVxdWFscyBgaWApLCB1bmxlc3Mgd2UgZGlkbid0IHZpc2l0IF9hbnlfIGVsZW1lbnRzIGluIHRoZSBhYm92ZSBsb29wIGJlY2F1c2Ugd2UgaGF2ZVxuICAgICAgICAvLyBubyBlbGVtZW50IG1hdGNoZXJzIGFuZCBubyBzZWVkLlxuICAgICAgICAvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG4gICAgICAgIC8vIGNhc2UsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgXCIwMFwiIGBtYXRjaGVkQ291bnRgIHRoYXQgZGlmZmVycyBmcm9tIGBpYCBidXQgaXMgYWxzb1xuICAgICAgICAvLyBudW1lcmljYWxseSB6ZXJvLlxuICAgICAgICBpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcbiAgICAgICAgICBqID0gMDtcbiAgICAgICAgICB3aGlsZSAoIChtYXRjaGVyID0gc2V0TWF0Y2hlcnNbaisrXSkgKSB7XG4gICAgICAgICAgICBtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICggc2VlZCApIHtcbiAgICAgICAgICAgIC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcbiAgICAgICAgICAgIGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcbiAgICAgICAgICAgICAgd2hpbGUgKCBpLS0gKSB7XG4gICAgICAgICAgICAgICAgaWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcbiAgICAgICAgICAgICAgICAgIHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEaXNjYXJkIGluZGV4IHBsYWNlaG9sZGVyIHZhbHVlcyB0byBnZXQgb25seSBhY3R1YWwgbWF0Y2hlc1xuICAgICAgICAgICAgc2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xuICAgICAgICAgIHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuICAgICAgICAgIC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuICAgICAgICAgIGlmICggb3V0ZXJtb3N0ICYmICFzZWVkICYmIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJlxuXHRcdFx0XHRcdCggbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoICkgPiAxICkge1xuXG4gICAgICAgICAgICBTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuICAgICAgICBpZiAoIG91dGVybW9zdCApIHtcbiAgICAgICAgICBkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcbiAgICAgICAgICBvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1bm1hdGNoZWQ7XG4gICAgICB9O1xuXG4gICAgcmV0dXJuIGJ5U2V0ID9cbiAgICAgIG1hcmtGdW5jdGlvbiggc3VwZXJNYXRjaGVyICkgOlxuICAgICAgc3VwZXJNYXRjaGVyO1xuICB9XG5cbiAgY29tcGlsZSA9IFNpenpsZS5jb21waWxlID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBtYXRjaCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcbiAgICB2YXIgaSxcbiAgICAgIHNldE1hdGNoZXJzID0gW10sXG4gICAgICBlbGVtZW50TWF0Y2hlcnMgPSBbXSxcbiAgICAgIGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgJyAnIF07XG5cbiAgICBpZiAoICFjYWNoZWQgKSB7XG4gICAgICAvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcbiAgICAgIGlmICggIW1hdGNoICkge1xuICAgICAgICBtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuICAgICAgfVxuICAgICAgaSA9IG1hdGNoLmxlbmd0aDtcbiAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICBjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbaV0gKTtcbiAgICAgICAgaWYgKCBjYWNoZWRbIGV4cGFuZG8gXSApIHtcbiAgICAgICAgICBzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXG4gICAgICBjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuICAgICAgLy8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG4gICAgICBjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfTtcblxuICAvKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbiAgc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcbiAgICB2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcbiAgICAgIGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSAnZnVuY3Rpb24nICYmIHNlbGVjdG9yLFxuICAgICAgbWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cbiAgICByZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuICAgIC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNlbGVjdG9yIGluIHRoZSBsaXN0IGFuZCBubyBzZWVkXG4gICAgLy8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuICAgIGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xuXG4gICAgICAvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxuICAgICAgdG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuICAgICAgaWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAodG9rZW4gPSB0b2tlbnNbMF0pLnR5cGUgPT09ICdJRCcgJiZcblx0XHRcdFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG4gICAgICAgIGNvbnRleHQgPSAoIEV4cHIuZmluZFsnSUQnXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG4gICAgICAgIGlmICggIWNvbnRleHQgKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG5cbiAgICAgICAgICAvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG4gICAgICAgIH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcbiAgICAgIH1cblxuICAgICAgLy8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuICAgICAgaSA9IG1hdGNoRXhwclsnbmVlZHNDb250ZXh0J10udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBpLS0gKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICAgIC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3JcbiAgICAgICAgaWYgKCBFeHByLnJlbGF0aXZlWyAodHlwZSA9IHRva2VuLnR5cGUpIF0gKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCAoZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdKSApIHtcbiAgICAgICAgICAvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcbiAgICAgICAgICBpZiAoIChzZWVkID0gZmluZChcbiAgICAgICAgICAgIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcbiAgICAgICAgICAgIHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcbiAgICAgICAgICApKSApIHtcblxuICAgICAgICAgICAgLy8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG4gICAgICAgICAgICB0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG4gICAgICAgICAgICBzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xuICAgICAgICAgICAgaWYgKCAhc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICAgIHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuICAgIC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcbiAgICAoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoXG4gICAgICBzZWVkLFxuICAgICAgY29udGV4dCxcbiAgICAgICFkb2N1bWVudElzSFRNTCxcbiAgICAgIHJlc3VsdHMsXG4gICAgICAhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuXG4gIC8vIFNvcnQgc3RhYmlsaXR5XG4gIHN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoJycpLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oJycpID09PSBleHBhbmRvO1xuXG4gIC8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcbiAgLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuICBzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcblxuICAvLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbiAgc2V0RG9jdW1lbnQoKTtcblxuICAvLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxuICAvLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbiAgc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuICAgIC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuICAgIHJldHVybiBlbC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZmllbGRzZXQnKSApICYgMTtcbiAgfSk7XG5cbiAgLy8gU3VwcG9ydDogSUU8OFxuICAvLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxuICAvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxuICBpZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuICAgIGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiO1xuICAgIHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSgnaHJlZicpID09PSAnIycgO1xuICB9KSApIHtcbiAgICBhZGRIYW5kbGUoICd0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoJywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuICAgICAgaWYgKCAhaXNYTUwgKSB7XG4gICAgICAgIHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSAndHlwZScgPyAxIDogMiApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gU3VwcG9ydDogSUU8OVxuICAvLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG4gIGlmICggIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcbiAgICBlbC5pbm5lckhUTUwgPSAnPGlucHV0Lz4nO1xuICAgIGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCAndmFsdWUnLCAnJyApO1xuICAgIHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApID09PSAnJztcbiAgfSkgKSB7XG4gICAgYWRkSGFuZGxlKCAndmFsdWUnLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG4gICAgICBpZiAoICFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgKSB7XG4gICAgICAgIHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIFN1cHBvcnQ6IElFPDlcbiAgLy8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xuICBpZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgPT0gbnVsbDtcbiAgfSkgKSB7XG4gICAgYWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuICAgICAgdmFyIHZhbDtcbiAgICAgIGlmICggIWlzWE1MICkge1xuICAgICAgICByZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcbiAgICAgICAgICAodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkpICYmIHZhbC5zcGVjaWZpZWQgP1xuICAgICAgICAgICAgdmFsLnZhbHVlIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gU2l6emxlO1xuXG59KSggd2luZG93ICk7XG5cblxuXG4gIGpRdWVyeS5maW5kID0gU2l6emxlO1xuICBqUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XG5cbiAgLy8gRGVwcmVjYXRlZFxuICBqUXVlcnkuZXhwclsgJzonIF0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xuICBqUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbiAgalF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcbiAgalF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xuICBqUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG4gIGpRdWVyeS5lc2NhcGVTZWxlY3RvciA9IFNpenpsZS5lc2NhcGU7XG5cblxuXG5cbiAgdmFyIGRpciA9IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuICAgIHZhciBtYXRjaGVkID0gW10sXG4gICAgICB0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XG5cbiAgICB3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSApIHtcbiAgICAgIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcbiAgICAgICAgaWYgKCB0cnVuY2F0ZSAmJiBqUXVlcnkoIGVsZW0gKS5pcyggdW50aWwgKSApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBtYXRjaGVkLnB1c2goIGVsZW0gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZWQ7XG4gIH07XG5cblxuICB2YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcbiAgICB2YXIgbWF0Y2hlZCA9IFtdO1xuXG4gICAgZm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcbiAgICAgIGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuICAgICAgICBtYXRjaGVkLnB1c2goIG4gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2hlZDtcbiAgfTtcblxuXG4gIHZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG5cblxuICBmdW5jdGlvbiBub2RlTmFtZSggZWxlbSwgbmFtZSApIHtcblxuICAgIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIH07XG4gIHZhciByc2luZ2xlVGFnID0gKCAvXjwoW2Etel1bXlxcL1xcMD46XFx4MjBcXHRcXHJcXG5cXGZdKilbXFx4MjBcXHRcXHJcXG5cXGZdKlxcLz8+KD86PFxcL1xcMT58KSQvaSApO1xuXG5cblxuICAvLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuICBmdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcbiAgICBpZiAoIGlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuICAgICAgcmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG4gICAgICAgIHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcbiAgICAgIH0gKTtcbiAgICB9XG5cbiAgICAvLyBTaW5nbGUgZWxlbWVudFxuICAgIGlmICggcXVhbGlmaWVyLm5vZGVUeXBlICkge1xuICAgICAgcmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgIHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG4gICAgICB9ICk7XG4gICAgfVxuXG4gICAgLy8gQXJyYXlsaWtlIG9mIGVsZW1lbnRzIChqUXVlcnksIGFyZ3VtZW50cywgQXJyYXkpXG4gICAgaWYgKCB0eXBlb2YgcXVhbGlmaWVyICE9PSAnc3RyaW5nJyApIHtcbiAgICAgIHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICByZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90O1xuICAgICAgfSApO1xuICAgIH1cblxuICAgIC8vIEZpbHRlcmVkIGRpcmVjdGx5IGZvciBib3RoIHNpbXBsZSBhbmQgY29tcGxleCBzZWxlY3RvcnNcbiAgICByZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG4gIH1cblxuICBqUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG4gICAgdmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG4gICAgaWYgKCBub3QgKSB7XG4gICAgICBleHByID0gJzpub3QoJyArIGV4cHIgKyAnKSc7XG4gICAgfVxuXG4gICAgaWYgKCBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcbiAgICAgIHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICByZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcbiAgICB9ICkgKTtcbiAgfTtcblxuICBqUXVlcnkuZm4uZXh0ZW5kKCB7XG4gICAgZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuICAgICAgdmFyIGksIHJldCxcbiAgICAgICAgbGVuID0gdGhpcy5sZW5ndGgsXG4gICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gJ3N0cmluZycgKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgICAgIGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9ICkgKTtcbiAgICAgIH1cblxuICAgICAgcmV0ID0gdGhpcy5wdXNoU3RhY2soIFtdICk7XG5cbiAgICAgIGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgIGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggcmV0ICkgOiByZXQ7XG4gICAgfSxcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcbiAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UgKSApO1xuICAgIH0sXG4gICAgbm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUgKSApO1xuICAgIH0sXG4gICAgaXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcbiAgICAgIHJldHVybiAhIXdpbm5vdyhcbiAgICAgICAgdGhpcyxcblxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG4gICAgICAgIC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cbiAgICAgICAgdHlwZW9mIHNlbGVjdG9yID09PSAnc3RyaW5nJyAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuICAgICAgICAgIGpRdWVyeSggc2VsZWN0b3IgKSA6XG4gICAgICAgICAgc2VsZWN0b3IgfHwgW10sXG4gICAgICAgIGZhbHNlXG4gICAgICApLmxlbmd0aDtcbiAgICB9XG4gIH0gKTtcblxuXG4gIC8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuICAvLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbiAgdmFyIHJvb3RqUXVlcnksXG5cbiAgICAvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuICAgIC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcbiAgICAvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcbiAgICAvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG4gICAgcnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSspKSQvLFxuXG4gICAgaW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuICAgICAgdmFyIG1hdGNoLCBlbGVtO1xuXG4gICAgICAvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcbiAgICAgIGlmICggIXNlbGVjdG9yICkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG4gICAgICAvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG4gICAgICByb290ID0gcm9vdCB8fCByb290alF1ZXJ5O1xuXG4gICAgICAvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG4gICAgICBpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgIGlmICggc2VsZWN0b3JbIDAgXSA9PT0gJzwnICYmXG5cdFx0XHRcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09ICc+JyAmJlxuXHRcdFx0XHRzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcblxuICAgICAgICAgIC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG4gICAgICAgICAgbWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcbiAgICAgICAgaWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuICAgICAgICAgIC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuICAgICAgICAgIGlmICggbWF0Y2hbIDEgXSApIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuICAgICAgICAgICAgLy8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG4gICAgICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxuICAgICAgICAgICAgalF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuICAgICAgICAgICAgICBtYXRjaFsgMSBdLFxuICAgICAgICAgICAgICBjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApICk7XG5cbiAgICAgICAgICAgIC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcbiAgICAgICAgICAgIGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcbiAgICAgICAgICAgICAgZm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuICAgICAgICAgICAgICAgIC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgICBpZiAoIGlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcbiAgICAgICAgICAgICAgICAgIHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuICAgICAgICAgICAgICAgICAgLy8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgICAgICAvLyBIQU5ETEU6ICQoI2lkKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuICAgICAgICAgICAgaWYgKCBlbGVtICkge1xuXG4gICAgICAgICAgICAgIC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG4gICAgICAgICAgICAgIHRoaXNbIDAgXSA9IGVsZW07XG4gICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG4gICAgICAgIH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xuICAgICAgICAgIHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XG5cbiAgICAgICAgICAvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcbiAgICAgICAgICAvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcbiAgICAgIH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuICAgICAgICB0aGlzWyAwIF0gPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG4gICAgICAgIC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxuICAgICAgfSBlbHNlIGlmICggaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcbiAgICAgICAgcmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgcm9vdC5yZWFkeSggc2VsZWN0b3IgKSA6XG5cbiAgICAgICAgLy8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuICAgICAgICAgIHNlbGVjdG9yKCBqUXVlcnkgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yLCB0aGlzICk7XG4gICAgfTtcblxuICAvLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG4gIGluaXQucHJvdG90eXBlID0galF1ZXJ5LmZuO1xuXG4gIC8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbiAgcm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG4gIHZhciBycGFyZW50c3ByZXYgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcblxuICAgIC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG4gICAgZ3VhcmFudGVlZFVuaXF1ZSA9IHtcbiAgICAgIGNoaWxkcmVuOiB0cnVlLFxuICAgICAgY29udGVudHM6IHRydWUsXG4gICAgICBuZXh0OiB0cnVlLFxuICAgICAgcHJldjogdHJ1ZVxuICAgIH07XG5cbiAgalF1ZXJ5LmZuLmV4dGVuZCgge1xuICAgIGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcbiAgICAgIHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcbiAgICAgICAgbCA9IHRhcmdldHMubGVuZ3RoO1xuXG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGZvciAoIDsgaSA8IGw7IGkrKyApIHtcbiAgICAgICAgICBpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1sgaSBdICkgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gKTtcbiAgICB9LFxuXG4gICAgY2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcbiAgICAgIHZhciBjdXIsXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBsID0gdGhpcy5sZW5ndGgsXG4gICAgICAgIG1hdGNoZWQgPSBbXSxcbiAgICAgICAgdGFyZ2V0cyA9IHR5cGVvZiBzZWxlY3RvcnMgIT09ICdzdHJpbmcnICYmIGpRdWVyeSggc2VsZWN0b3JzICk7XG5cbiAgICAgIC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcbiAgICAgIGlmICggIXJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgKSB7XG4gICAgICAgIGZvciAoIDsgaSA8IGw7IGkrKyApIHtcbiAgICAgICAgICBmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG4gICAgICAgICAgICAvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcbiAgICAgICAgICAgIGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCB0YXJnZXRzID9cbiAgICAgICAgICAgICAgdGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XG5cbiAgICAgICAgICAgIC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuICAgICAgICAgICAgICBjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBjdXIsIHNlbGVjdG9ycyApICkgKSB7XG5cbiAgICAgICAgICAgICAgbWF0Y2hlZC5wdXNoKCBjdXIgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcbiAgICB9LFxuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpbiB0aGUgc2V0XG4gICAgaW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG4gICAgICAvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuICAgICAgaWYgKCAhZWxlbSApIHtcbiAgICAgICAgcmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuICAgICAgfVxuXG4gICAgICAvLyBJbmRleCBpbiBzZWxlY3RvclxuICAgICAgaWYgKCB0eXBlb2YgZWxlbSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgIHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcbiAgICAgIH1cblxuICAgICAgLy8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG4gICAgICByZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG4gICAgICAgIC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuICAgICAgICBlbGVtLmpxdWVyeSA/IGVsZW1bIDAgXSA6IGVsZW1cbiAgICAgICk7XG4gICAgfSxcblxuICAgIGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuICAgICAgICBqUXVlcnkudW5pcXVlU29ydChcbiAgICAgICAgICBqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSxcblxuICAgIGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG4gICAgICAgIHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoIHNlbGVjdG9yIClcbiAgICAgICk7XG4gICAgfVxuICB9ICk7XG5cbiAgZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG4gICAgd2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuICAgIHJldHVybiBjdXI7XG4gIH1cblxuICBqUXVlcnkuZWFjaCgge1xuICAgIHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuICAgICAgcmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcbiAgICB9LFxuICAgIHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgcmV0dXJuIGRpciggZWxlbSwgJ3BhcmVudE5vZGUnICk7XG4gICAgfSxcbiAgICBwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcbiAgICAgIHJldHVybiBkaXIoIGVsZW0sICdwYXJlbnROb2RlJywgdW50aWwgKTtcbiAgICB9LFxuICAgIG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgcmV0dXJuIHNpYmxpbmcoIGVsZW0sICduZXh0U2libGluZycgKTtcbiAgICB9LFxuICAgIHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgcmV0dXJuIHNpYmxpbmcoIGVsZW0sICdwcmV2aW91c1NpYmxpbmcnICk7XG4gICAgfSxcbiAgICBuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgIHJldHVybiBkaXIoIGVsZW0sICduZXh0U2libGluZycgKTtcbiAgICB9LFxuICAgIHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgcmV0dXJuIGRpciggZWxlbSwgJ3ByZXZpb3VzU2libGluZycgKTtcbiAgICB9LFxuICAgIG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuICAgICAgcmV0dXJuIGRpciggZWxlbSwgJ25leHRTaWJsaW5nJywgdW50aWwgKTtcbiAgICB9LFxuICAgIHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuICAgICAgcmV0dXJuIGRpciggZWxlbSwgJ3ByZXZpb3VzU2libGluZycsIHVudGlsICk7XG4gICAgfSxcbiAgICBzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICByZXR1cm4gc2libGluZ3MoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xuICAgIH0sXG4gICAgY2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgcmV0dXJuIHNpYmxpbmdzKCBlbGVtLmZpcnN0Q2hpbGQgKTtcbiAgICB9LFxuICAgIGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgIGlmICggbm9kZU5hbWUoIGVsZW0sICdpZnJhbWUnICkgKSB7XG4gICAgICAgIHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudDtcbiAgICAgIH1cblxuICAgICAgLy8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHksIGlPUyA3IG9ubHksIEFuZHJvaWQgQnJvd3NlciA8PTQuMyBvbmx5XG4gICAgICAvLyBUcmVhdCB0aGUgdGVtcGxhdGUgZWxlbWVudCBhcyBhIHJlZ3VsYXIgb25lIGluIGJyb3dzZXJzIHRoYXRcbiAgICAgIC8vIGRvbid0IHN1cHBvcnQgaXQuXG4gICAgICBpZiAoIG5vZGVOYW1lKCBlbGVtLCAndGVtcGxhdGUnICkgKSB7XG4gICAgICAgIGVsZW0gPSBlbGVtLmNvbnRlbnQgfHwgZWxlbTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuICAgIH1cbiAgfSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuICAgIGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcbiAgICAgIHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cbiAgICAgIGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gJ1VudGlsJyApIHtcbiAgICAgICAgc2VsZWN0b3IgPSB1bnRpbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09ICdzdHJpbmcnICkge1xuICAgICAgICBtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cbiAgICAgICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZXNcbiAgICAgICAgaWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuICAgICAgICAgIGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuICAgICAgICBpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG4gICAgICAgICAgbWF0Y2hlZC5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkICk7XG4gICAgfTtcbiAgfSApO1xuICB2YXIgcm5vdGh0bWx3aGl0ZSA9ICggL1teXFx4MjBcXHRcXHJcXG5cXGZdKy9nICk7XG5cblxuXG4gIC8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG4gIGZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG4gICAgdmFyIG9iamVjdCA9IHt9O1xuICAgIGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuICAgICAgb2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xuICAgIH0gKTtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbiAgalF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG4gICAgLy8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxuICAgIC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcbiAgICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnID9cbiAgICAgIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG4gICAgICBqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG4gICAgdmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcbiAgICAgIGZpcmluZyxcblxuICAgICAgLy8gTGFzdCBmaXJlIHZhbHVlIGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHNcbiAgICAgIG1lbW9yeSxcblxuICAgICAgLy8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcbiAgICAgIGZpcmVkLFxuXG4gICAgICAvLyBGbGFnIHRvIHByZXZlbnQgZmlyaW5nXG4gICAgICBsb2NrZWQsXG5cbiAgICAgIC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG4gICAgICBsaXN0ID0gW10sXG5cbiAgICAgIC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG4gICAgICBxdWV1ZSA9IFtdLFxuXG4gICAgICAvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSBhZGQvcmVtb3ZlIGFzIG5lZWRlZClcbiAgICAgIGZpcmluZ0luZGV4ID0gLTEsXG5cbiAgICAgIC8vIEZpcmUgY2FsbGJhY2tzXG4gICAgICBmaXJlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG4gICAgICAgIGxvY2tlZCA9IGxvY2tlZCB8fCBvcHRpb25zLm9uY2U7XG5cbiAgICAgICAgLy8gRXhlY3V0ZSBjYWxsYmFja3MgZm9yIGFsbCBwZW5kaW5nIGV4ZWN1dGlvbnMsXG4gICAgICAgIC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcbiAgICAgICAgZmlyZWQgPSBmaXJpbmcgPSB0cnVlO1xuICAgICAgICBmb3IgKCA7IHF1ZXVlLmxlbmd0aDsgZmlyaW5nSW5kZXggPSAtMSApIHtcbiAgICAgICAgICBtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgIHdoaWxlICggKytmaXJpbmdJbmRleCA8IGxpc3QubGVuZ3RoICkge1xuXG4gICAgICAgICAgICAvLyBSdW4gY2FsbGJhY2sgYW5kIGNoZWNrIGZvciBlYXJseSB0ZXJtaW5hdGlvblxuICAgICAgICAgICAgaWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cbiAgICAgICAgICAgICAgLy8gSnVtcCB0byBlbmQgYW5kIGZvcmdldCB0aGUgZGF0YSBzbyAuYWRkIGRvZXNuJ3QgcmUtZmlyZVxuICAgICAgICAgICAgICBmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgICBtZW1vcnkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XG4gICAgICAgIGlmICggIW9wdGlvbnMubWVtb3J5ICkge1xuICAgICAgICAgIG1lbW9yeSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZmlyaW5nID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2RcbiAgICAgICAgaWYgKCBsb2NrZWQgKSB7XG5cbiAgICAgICAgICAvLyBLZWVwIGFuIGVtcHR5IGxpc3QgaWYgd2UgaGF2ZSBkYXRhIGZvciBmdXR1cmUgYWRkIGNhbGxzXG4gICAgICAgICAgaWYgKCBtZW1vcnkgKSB7XG4gICAgICAgICAgICBsaXN0ID0gW107XG5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlzdCA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLy8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3RcbiAgICAgIHNlbGYgPSB7XG5cbiAgICAgICAgLy8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuICAgICAgICBhZGQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICggbGlzdCApIHtcblxuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBtZW1vcnkgZnJvbSBhIHBhc3QgcnVuLCB3ZSBzaG91bGQgZmlyZSBhZnRlciBhZGRpbmdcbiAgICAgICAgICAgIGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG4gICAgICAgICAgICAgIGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICBxdWV1ZS5wdXNoKCBtZW1vcnkgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgKCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG4gICAgICAgICAgICAgIGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuICAgICAgICAgICAgICAgIGlmICggaXNGdW5jdGlvbiggYXJnICkgKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0LnB1c2goIGFyZyApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIHRvVHlwZSggYXJnICkgIT09ICdzdHJpbmcnICkge1xuXG4gICAgICAgICAgICAgICAgICAvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICAgICAgICBhZGQoIGFyZyApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgfSApKCBhcmd1bWVudHMgKTtcblxuICAgICAgICAgICAgaWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcbiAgICAgICAgICAgICAgZmlyZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgalF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcbiAgICAgICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgICAgIHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuICAgICAgICAgICAgICBsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblxuICAgICAgICAgICAgICAvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcbiAgICAgICAgICAgICAgaWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcbiAgICAgICAgICAgICAgICBmaXJpbmdJbmRleC0tO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSApO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG4gICAgICAgIC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxuICAgICAgICBoYXM6IGZ1bmN0aW9uKCBmbiApIHtcbiAgICAgICAgICByZXR1cm4gZm4gP1xuICAgICAgICAgICAgalF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6XG4gICAgICAgICAgICBsaXN0Lmxlbmd0aCA+IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuICAgICAgICBlbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCBsaXN0ICkge1xuICAgICAgICAgICAgbGlzdCA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG4gICAgICAgIC8vIEFib3J0IGFueSBjdXJyZW50L3BlbmRpbmcgZXhlY3V0aW9uc1xuICAgICAgICAvLyBDbGVhciBhbGwgY2FsbGJhY2tzIGFuZCB2YWx1ZXNcbiAgICAgICAgZGlzYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbG9ja2VkID0gcXVldWUgPSBbXTtcbiAgICAgICAgICBsaXN0ID0gbWVtb3J5ID0gJyc7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGRpc2FibGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gIWxpc3Q7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRGlzYWJsZSAuZmlyZVxuICAgICAgICAvLyBBbHNvIGRpc2FibGUgLmFkZCB1bmxlc3Mgd2UgaGF2ZSBtZW1vcnkgKHNpbmNlIGl0IHdvdWxkIGhhdmUgbm8gZWZmZWN0KVxuICAgICAgICAvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG4gICAgICAgIGxvY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxvY2tlZCA9IHF1ZXVlID0gW107XG4gICAgICAgICAgaWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG4gICAgICAgICAgICBsaXN0ID0gbWVtb3J5ID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiAhIWxvY2tlZDtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG4gICAgICAgIGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcbiAgICAgICAgICBpZiAoICFsb2NrZWQgKSB7XG4gICAgICAgICAgICBhcmdzID0gYXJncyB8fCBbXTtcbiAgICAgICAgICAgIGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKCBhcmdzICk7XG4gICAgICAgICAgICBpZiAoICFmaXJpbmcgKSB7XG4gICAgICAgICAgICAgIGZpcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcbiAgICAgICAgZmlyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG4gICAgICAgIGZpcmVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gISFmaXJlZDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG5cbiAgZnVuY3Rpb24gSWRlbnRpdHkoIHYgKSB7XG4gICAgcmV0dXJuIHY7XG4gIH1cbiAgZnVuY3Rpb24gVGhyb3dlciggZXggKSB7XG4gICAgdGhyb3cgZXg7XG4gIH1cblxuICBmdW5jdGlvbiBhZG9wdFZhbHVlKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0LCBub1ZhbHVlICkge1xuICAgIHZhciBtZXRob2Q7XG5cbiAgICB0cnkge1xuXG4gICAgICAvLyBDaGVjayBmb3IgcHJvbWlzZSBhc3BlY3QgZmlyc3QgdG8gcHJpdmlsZWdlIHN5bmNocm9ub3VzIGJlaGF2aW9yXG4gICAgICBpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUucHJvbWlzZSApICkgKSB7XG4gICAgICAgIG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuICAgICAgICAvLyBPdGhlciB0aGVuYWJsZXNcbiAgICAgIH0gZWxzZSBpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XG4gICAgICAgIG1ldGhvZC5jYWxsKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0ICk7XG5cbiAgICAgICAgLy8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuICAgICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBDb250cm9sIGByZXNvbHZlYCBhcmd1bWVudHMgYnkgbGV0dGluZyBBcnJheSNzbGljZSBjYXN0IGJvb2xlYW4gYG5vVmFsdWVgIHRvIGludGVnZXI6XG4gICAgICAgIC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcbiAgICAgICAgLy8gKiB0cnVlOiBbIHZhbHVlIF0uc2xpY2UoIDEgKSA9PiByZXNvbHZlKClcbiAgICAgICAgcmVzb2x2ZS5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0uc2xpY2UoIG5vVmFsdWUgKSApO1xuICAgICAgfVxuXG4gICAgICAvLyBGb3IgUHJvbWlzZXMvQSssIGNvbnZlcnQgZXhjZXB0aW9ucyBpbnRvIHJlamVjdGlvbnNcbiAgICAgIC8vIFNpbmNlIGpRdWVyeS53aGVuIGRvZXNuJ3QgdW53cmFwIHRoZW5hYmxlcywgd2UgY2FuIHNraXAgdGhlIGV4dHJhIGNoZWNrcyBhcHBlYXJpbmcgaW5cbiAgICAgIC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG4gICAgfSBjYXRjaCAoIHZhbHVlICkge1xuXG4gICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCBvbmx5XG4gICAgICAvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG4gICAgICByZWplY3QuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdICk7XG4gICAgfVxuICB9XG5cbiAgalF1ZXJ5LmV4dGVuZCgge1xuXG4gICAgRGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuICAgICAgdmFyIHR1cGxlcyA9IFtcblxuICAgICAgICAgIC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBjYWxsYmFja3MsXG4gICAgICAgICAgLy8gLi4uIC50aGVuIGhhbmRsZXJzLCBhcmd1bWVudCBpbmRleCwgW2ZpbmFsIHN0YXRlXVxuICAgICAgICAgIFsgJ25vdGlmeScsICdwcm9ncmVzcycsIGpRdWVyeS5DYWxsYmFja3MoICdtZW1vcnknICksXG4gICAgICAgICAgICBqUXVlcnkuQ2FsbGJhY2tzKCAnbWVtb3J5JyApLCAyIF0sXG4gICAgICAgICAgWyAncmVzb2x2ZScsICdkb25lJywgalF1ZXJ5LkNhbGxiYWNrcyggJ29uY2UgbWVtb3J5JyApLFxuICAgICAgICAgICAgalF1ZXJ5LkNhbGxiYWNrcyggJ29uY2UgbWVtb3J5JyApLCAwLCAncmVzb2x2ZWQnIF0sXG4gICAgICAgICAgWyAncmVqZWN0JywgJ2ZhaWwnLCBqUXVlcnkuQ2FsbGJhY2tzKCAnb25jZSBtZW1vcnknICksXG4gICAgICAgICAgICBqUXVlcnkuQ2FsbGJhY2tzKCAnb25jZSBtZW1vcnknICksIDEsICdyZWplY3RlZCcgXVxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZSA9ICdwZW5kaW5nJyxcbiAgICAgICAgcHJvbWlzZSA9IHtcbiAgICAgICAgICBzdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhbHdheXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9LFxuICAgICAgICAgICdjYXRjaCc6IGZ1bmN0aW9uKCBmbiApIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oIG51bGwsIGZuICk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcbiAgICAgICAgICBwaXBlOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XG4gICAgICAgICAgICB2YXIgZm5zID0gYXJndW1lbnRzO1xuXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG4gICAgICAgICAgICAgIGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblxuICAgICAgICAgICAgICAgIC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxuICAgICAgICAgICAgICAgIHZhciBmbiA9IGlzRnVuY3Rpb24oIGZuc1sgdHVwbGVbIDQgXSBdICkgJiYgZm5zWyB0dXBsZVsgNCBdIF07XG5cbiAgICAgICAgICAgICAgICAvLyBkZWZlcnJlZC5wcm9ncmVzcyhmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5ub3RpZnkgfSlcbiAgICAgICAgICAgICAgICAvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcbiAgICAgICAgICAgICAgICAvLyBkZWZlcnJlZC5mYWlsKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlamVjdCB9KVxuICAgICAgICAgICAgICAgIGRlZmVycmVkWyB0dXBsZVsgMSBdIF0oIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuICAgICAgICAgICAgICAgICAgaWYgKCByZXR1cm5lZCAmJiBpc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybmVkLnByb21pc2UoKVxuICAgICAgICAgICAgICAgICAgICAgIC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcbiAgICAgICAgICAgICAgICAgICAgICAuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG4gICAgICAgICAgICAgICAgICAgICAgLmZhaWwoIG5ld0RlZmVyLnJlamVjdCApO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGVmZXJbIHR1cGxlWyAwIF0gKyAnV2l0aCcgXShcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgIGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgIGZucyA9IG51bGw7XG4gICAgICAgICAgICB9ICkucHJvbWlzZSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzICkge1xuICAgICAgICAgICAgdmFyIG1heERlcHRoID0gMDtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlc29sdmUoIGRlcHRoLCBkZWZlcnJlZCwgaGFuZGxlciwgc3BlY2lhbCApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICBtaWdodFRocm93ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5lZCwgdGhlbjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuM1xuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZG91YmxlLXJlc29sdXRpb24gYXR0ZW1wdHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkZXB0aCA8IG1heERlcHRoICkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybmVkID0gaGFuZGxlci5hcHBseSggdGhhdCwgYXJncyApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNDhcbiAgICAgICAgICAgICAgICAgICAgaWYgKCByZXR1cm5lZCA9PT0gZGVmZXJyZWQucHJvbWlzZSgpICkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoICdUaGVuYWJsZSBzZWxmLXJlc29sdXRpb24nICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9ucyAyLjMuMy4xLCAzLjVcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTRcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0cmlldmUgYHRoZW5gIG9ubHkgb25jZVxuICAgICAgICAgICAgICAgICAgICB0aGVuID0gcmV0dXJuZWQgJiZcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy40XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTY0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgY2hlY2sgb2JqZWN0cyBhbmQgZnVuY3Rpb25zIGZvciB0aGVuYWJpbGl0eVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHR5cGVvZiByZXR1cm5lZCA9PT0gJ29iamVjdCcgfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgcmV0dXJuZWQgPT09ICdmdW5jdGlvbicgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC50aGVuO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBhIHJldHVybmVkIHRoZW5hYmxlXG4gICAgICAgICAgICAgICAgICAgIGlmICggaXNGdW5jdGlvbiggdGhlbiApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuICAgICAgICAgICAgICAgICAgICAgIGlmICggc3BlY2lhbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4uY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsIClcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBhbHNvIGhvb2sgaW50byBwcm9ncmVzc1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLmFuZCBkaXNyZWdhcmQgb2xkZXIgcmVzb2x1dGlvbiB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heERlcHRoKys7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4uY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQubm90aWZ5V2l0aCApXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBhbGwgb3RoZXIgcmV0dXJuZWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCBoYW5kbGVyICE9PSBJZGVudGl0eSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gWyByZXR1cm5lZCBdO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIHZhbHVlKHMpXG4gICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcbiAgICAgICAgICAgICAgICAgICAgICAoIHNwZWNpYWwgfHwgZGVmZXJyZWQucmVzb2x2ZVdpdGggKSggdGhhdCwgYXJncyApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAvLyBPbmx5IG5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBjYXRjaCBhbmQgcmVqZWN0IGV4Y2VwdGlvbnNcbiAgICAgICAgICAgICAgICAgIHByb2Nlc3MgPSBzcGVjaWFsID9cbiAgICAgICAgICAgICAgICAgICAgbWlnaHRUaHJvdyA6XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaWdodFRocm93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoIGUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKCBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3Muc3RhY2tUcmFjZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02MVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHBvc3QtcmVzb2x1dGlvbiBleGNlcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGhhbmRsZXIgIT09IFRocm93ZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gWyBlIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3RXaXRoKCB0aGF0LCBhcmdzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjFcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01N1xuICAgICAgICAgICAgICAgIC8vIFJlLXJlc29sdmUgcHJvbWlzZXMgaW1tZWRpYXRlbHkgdG8gZG9kZ2UgZmFsc2UgcmVqZWN0aW9uIGZyb21cbiAgICAgICAgICAgICAgICAvLyBzdWJzZXF1ZW50IGVycm9yc1xuICAgICAgICAgICAgICAgIGlmICggZGVwdGggKSB7XG4gICAgICAgICAgICAgICAgICBwcm9jZXNzKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgLy8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgc3RhY2ssIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgICAvLyBzaW5jZSBpdCdzIG90aGVyd2lzZSBsb3N0IHdoZW4gZXhlY3V0aW9uIGdvZXMgYXN5bmNcbiAgICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vayApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5zdGFja1RyYWNlID0galF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaygpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoIHByb2Nlc3MgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblxuICAgICAgICAgICAgICAvLyBwcm9ncmVzc19oYW5kbGVycy5hZGQoIC4uLiApXG4gICAgICAgICAgICAgIHR1cGxlc1sgMCBdWyAzIF0uYWRkKFxuICAgICAgICAgICAgICAgIHJlc29sdmUoXG4gICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgbmV3RGVmZXIsXG4gICAgICAgICAgICAgICAgICBpc0Z1bmN0aW9uKCBvblByb2dyZXNzICkgP1xuICAgICAgICAgICAgICAgICAgICBvblByb2dyZXNzIDpcbiAgICAgICAgICAgICAgICAgICAgSWRlbnRpdHksXG4gICAgICAgICAgICAgICAgICBuZXdEZWZlci5ub3RpZnlXaXRoXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgIC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5hZGQoIC4uLiApXG4gICAgICAgICAgICAgIHR1cGxlc1sgMSBdWyAzIF0uYWRkKFxuICAgICAgICAgICAgICAgIHJlc29sdmUoXG4gICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgbmV3RGVmZXIsXG4gICAgICAgICAgICAgICAgICBpc0Z1bmN0aW9uKCBvbkZ1bGZpbGxlZCApID9cbiAgICAgICAgICAgICAgICAgICAgb25GdWxmaWxsZWQgOlxuICAgICAgICAgICAgICAgICAgICBJZGVudGl0eVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAvLyByZWplY3RlZF9oYW5kbGVycy5hZGQoIC4uLiApXG4gICAgICAgICAgICAgIHR1cGxlc1sgMiBdWyAzIF0uYWRkKFxuICAgICAgICAgICAgICAgIHJlc29sdmUoXG4gICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgbmV3RGVmZXIsXG4gICAgICAgICAgICAgICAgICBpc0Z1bmN0aW9uKCBvblJlamVjdGVkICkgP1xuICAgICAgICAgICAgICAgICAgICBvblJlamVjdGVkIDpcbiAgICAgICAgICAgICAgICAgICAgVGhyb3dlclxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gKS5wcm9taXNlKCk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcbiAgICAgICAgICAvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG4gICAgICAgICAgcHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcbiAgICAgICAgICAgIHJldHVybiBvYmogIT0gbnVsbCA/IGpRdWVyeS5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRlZmVycmVkID0ge307XG5cbiAgICAgIC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcbiAgICAgIGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcbiAgICAgICAgdmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuICAgICAgICAgIHN0YXRlU3RyaW5nID0gdHVwbGVbIDUgXTtcblxuICAgICAgICAvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcbiAgICAgICAgLy8gcHJvbWlzZS5kb25lID0gbGlzdC5hZGRcbiAgICAgICAgLy8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcbiAgICAgICAgcHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XG5cbiAgICAgICAgLy8gSGFuZGxlIHN0YXRlXG4gICAgICAgIGlmICggc3RhdGVTdHJpbmcgKSB7XG4gICAgICAgICAgbGlzdC5hZGQoXG4gICAgICAgICAgICBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAvLyBzdGF0ZSA9IFwicmVzb2x2ZWRcIiAoaS5lLiwgZnVsZmlsbGVkKVxuICAgICAgICAgICAgICAvLyBzdGF0ZSA9IFwicmVqZWN0ZWRcIlxuICAgICAgICAgICAgICBzdGF0ZSA9IHN0YXRlU3RyaW5nO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcbiAgICAgICAgICAgIC8vIGZ1bGZpbGxlZF9jYWxsYmFja3MuZGlzYWJsZVxuICAgICAgICAgICAgdHVwbGVzWyAzIC0gaSBdWyAyIF0uZGlzYWJsZSxcblxuICAgICAgICAgICAgLy8gcmVqZWN0ZWRfaGFuZGxlcnMuZGlzYWJsZVxuICAgICAgICAgICAgLy8gZnVsZmlsbGVkX2hhbmRsZXJzLmRpc2FibGVcbiAgICAgICAgICAgIHR1cGxlc1sgMyAtIGkgXVsgMyBdLmRpc2FibGUsXG5cbiAgICAgICAgICAgIC8vIHByb2dyZXNzX2NhbGxiYWNrcy5sb2NrXG4gICAgICAgICAgICB0dXBsZXNbIDAgXVsgMiBdLmxvY2ssXG5cbiAgICAgICAgICAgIC8vIHByb2dyZXNzX2hhbmRsZXJzLmxvY2tcbiAgICAgICAgICAgIHR1cGxlc1sgMCBdWyAzIF0ubG9ja1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXG4gICAgICAgIC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5maXJlXG4gICAgICAgIC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcbiAgICAgICAgbGlzdC5hZGQoIHR1cGxlWyAzIF0uZmlyZSApO1xuXG4gICAgICAgIC8vIGRlZmVycmVkLm5vdGlmeSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5ub3RpZnlXaXRoKC4uLikgfVxuICAgICAgICAvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxuICAgICAgICAvLyBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVqZWN0V2l0aCguLi4pIH1cbiAgICAgICAgZGVmZXJyZWRbIHR1cGxlWyAwIF0gXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGRlZmVycmVkWyB0dXBsZVsgMCBdICsgJ1dpdGgnIF0oIHRoaXMgPT09IGRlZmVycmVkID8gdW5kZWZpbmVkIDogdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZGVmZXJyZWQubm90aWZ5V2l0aCA9IGxpc3QuZmlyZVdpdGhcbiAgICAgICAgLy8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXG4gICAgICAgIC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXG4gICAgICAgIGRlZmVycmVkWyB0dXBsZVsgMCBdICsgJ1dpdGgnIF0gPSBsaXN0LmZpcmVXaXRoO1xuICAgICAgfSApO1xuXG4gICAgICAvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2VcbiAgICAgIHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuICAgICAgLy8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuICAgICAgaWYgKCBmdW5jICkge1xuICAgICAgICBmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuICAgICAgfVxuXG4gICAgICAvLyBBbGwgZG9uZSFcbiAgICAgIHJldHVybiBkZWZlcnJlZDtcbiAgICB9LFxuXG4gICAgLy8gRGVmZXJyZWQgaGVscGVyXG4gICAgd2hlbjogZnVuY3Rpb24oIHNpbmdsZVZhbHVlICkge1xuICAgICAgdmFyXG5cbiAgICAgICAgLy8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG4gICAgICAgIHJlbWFpbmluZyA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cbiAgICAgICAgLy8gY291bnQgb2YgdW5wcm9jZXNzZWQgYXJndW1lbnRzXG4gICAgICAgIGkgPSByZW1haW5pbmcsXG5cbiAgICAgICAgLy8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxuICAgICAgICByZXNvbHZlQ29udGV4dHMgPSBBcnJheSggaSApLFxuICAgICAgICByZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cbiAgICAgICAgLy8gdGhlIG1hc3RlciBEZWZlcnJlZFxuICAgICAgICBtYXN0ZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblxuICAgICAgICAvLyBzdWJvcmRpbmF0ZSBjYWxsYmFjayBmYWN0b3J5XG4gICAgICAgIHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuICAgICAgICAgICAgcmVzb2x2ZUNvbnRleHRzWyBpIF0gPSB0aGlzO1xuICAgICAgICAgICAgcmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuICAgICAgICAgICAgaWYgKCAhKCAtLXJlbWFpbmluZyApICkge1xuICAgICAgICAgICAgICBtYXN0ZXIucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgIC8vIFNpbmdsZS0gYW5kIGVtcHR5IGFyZ3VtZW50cyBhcmUgYWRvcHRlZCBsaWtlIFByb21pc2UucmVzb2x2ZVxuICAgICAgaWYgKCByZW1haW5pbmcgPD0gMSApIHtcbiAgICAgICAgYWRvcHRWYWx1ZSggc2luZ2xlVmFsdWUsIG1hc3Rlci5kb25lKCB1cGRhdGVGdW5jKCBpICkgKS5yZXNvbHZlLCBtYXN0ZXIucmVqZWN0LFxuICAgICAgICAgICFyZW1haW5pbmcgKTtcblxuICAgICAgICAvLyBVc2UgLnRoZW4oKSB0byB1bndyYXAgc2Vjb25kYXJ5IHRoZW5hYmxlcyAoY2YuIGdoLTMwMDApXG4gICAgICAgIGlmICggbWFzdGVyLnN0YXRlKCkgPT09ICdwZW5kaW5nJyB8fFxuXHRcdFx0XHRpc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0gJiYgcmVzb2x2ZVZhbHVlc1sgaSBdLnRoZW4gKSApIHtcblxuICAgICAgICAgIHJldHVybiBtYXN0ZXIudGhlbigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE11bHRpcGxlIGFyZ3VtZW50cyBhcmUgYWdncmVnYXRlZCBsaWtlIFByb21pc2UuYWxsIGFycmF5IGVsZW1lbnRzXG4gICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgYWRvcHRWYWx1ZSggcmVzb2x2ZVZhbHVlc1sgaSBdLCB1cGRhdGVGdW5jKCBpICksIG1hc3Rlci5yZWplY3QgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hc3Rlci5wcm9taXNlKCk7XG4gICAgfVxuICB9ICk7XG5cblxuICAvLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcbiAgLy8gd2FybiBhYm91dCB0aGVtIEFTQVAgcmF0aGVyIHRoYW4gc3dhbGxvd2luZyB0aGVtIGJ5IGRlZmF1bHQuXG4gIHZhciByZXJyb3JOYW1lcyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xuXG4gIGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBzdGFjayApIHtcblxuICAgIC8vIFN1cHBvcnQ6IElFIDggLSA5IG9ubHlcbiAgICAvLyBDb25zb2xlIGV4aXN0cyB3aGVuIGRldiB0b29scyBhcmUgb3Blbiwgd2hpY2ggY2FuIGhhcHBlbiBhdCBhbnkgdGltZVxuICAgIGlmICggd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2FybiAmJiBlcnJvciAmJiByZXJyb3JOYW1lcy50ZXN0KCBlcnJvci5uYW1lICkgKSB7XG4gICAgICB3aW5kb3cuY29uc29sZS53YXJuKCAnalF1ZXJ5LkRlZmVycmVkIGV4Y2VwdGlvbjogJyArIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrLCBzdGFjayApO1xuICAgIH1cbiAgfTtcblxuXG5cblxuICBqUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiggZXJyb3IgKSB7XG4gICAgd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSApO1xuICB9O1xuXG5cblxuXG4gIC8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxuICB2YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbiAgalF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oIGZuICkge1xuXG4gICAgcmVhZHlMaXN0XG4gICAgICAudGhlbiggZm4gKVxuXG4gICAgLy8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcbiAgICAvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcbiAgICAvLyByZWdpc3RyYXRpb24uXG4gICAgICAuY2F0Y2goIGZ1bmN0aW9uKCBlcnJvciApIHtcbiAgICAgICAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uKCBlcnJvciApO1xuICAgICAgfSApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgalF1ZXJ5LmV4dGVuZCgge1xuXG4gICAgLy8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cbiAgICBpc1JlYWR5OiBmYWxzZSxcblxuICAgIC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcbiAgICAvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuICAgIHJlYWR5V2FpdDogMSxcblxuICAgIC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcbiAgICByZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cbiAgICAgIC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcbiAgICAgIGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuICAgICAgalF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG4gICAgICAvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuICAgICAgaWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuICAgICAgcmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuICAgIH1cbiAgfSApO1xuXG4gIGpRdWVyeS5yZWFkeS50aGVuID0gcmVhZHlMaXN0LnRoZW47XG5cbiAgLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbiAgZnVuY3Rpb24gY29tcGxldGVkKCkge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdET01Db250ZW50TG9hZGVkJywgY29tcGxldGVkICk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdsb2FkJywgY29tcGxldGVkICk7XG4gICAgalF1ZXJ5LnJlYWR5KCk7XG4gIH1cblxuICAvLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuICAvLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cbiAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTAgb25seVxuICAvLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cbiAgaWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnIHx8XG5cdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2xvYWRpbmcnICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuICAgIC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuICAgIHdpbmRvdy5zZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcblxuICB9IGVsc2Uge1xuXG4gICAgLy8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdET01Db250ZW50TG9hZGVkJywgY29tcGxldGVkICk7XG5cbiAgICAvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIGNvbXBsZXRlZCApO1xuICB9XG5cblxuXG5cbiAgLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4gIC8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxuICB2YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuICAgIHZhciBpID0gMCxcbiAgICAgIGxlbiA9IGVsZW1zLmxlbmd0aCxcbiAgICAgIGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuICAgIC8vIFNldHMgbWFueSB2YWx1ZXNcbiAgICBpZiAoIHRvVHlwZSgga2V5ICkgPT09ICdvYmplY3QnICkge1xuICAgICAgY2hhaW5hYmxlID0gdHJ1ZTtcbiAgICAgIGZvciAoIGkgaW4ga2V5ICkge1xuICAgICAgICBhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0cyBvbmUgdmFsdWVcbiAgICB9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgY2hhaW5hYmxlID0gdHJ1ZTtcblxuICAgICAgaWYgKCAhaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcbiAgICAgICAgcmF3ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCBidWxrICkge1xuXG4gICAgICAgIC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuICAgICAgICBpZiAoIHJhdyApIHtcbiAgICAgICAgICBmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcbiAgICAgICAgICBmbiA9IG51bGw7XG5cbiAgICAgICAgICAvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVsayA9IGZuO1xuICAgICAgICAgIGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICggZm4gKSB7XG4gICAgICAgIGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgIGZuKFxuICAgICAgICAgICAgZWxlbXNbIGkgXSwga2V5LCByYXcgP1xuICAgICAgICAgICAgICB2YWx1ZSA6XG4gICAgICAgICAgICAgIHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICggY2hhaW5hYmxlICkge1xuICAgICAgcmV0dXJuIGVsZW1zO1xuICAgIH1cblxuICAgIC8vIEdldHNcbiAgICBpZiAoIGJ1bGsgKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCggZWxlbXMgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XG4gIH07XG5cblxuICAvLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcbiAgdmFyIHJtc1ByZWZpeCA9IC9eLW1zLS8sXG4gICAgcmRhc2hBbHBoYSA9IC8tKFthLXpdKS9nO1xuXG4gIC8vIFVzZWQgYnkgY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuICBmdW5jdGlvbiBmY2FtZWxDYXNlKCBhbGwsIGxldHRlciApIHtcbiAgICByZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG4gIH1cblxuICAvLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG4gIC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcbiAgLy8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuICBmdW5jdGlvbiBjYW1lbENhc2UoIHN0cmluZyApIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHJtc1ByZWZpeCwgJ21zLScgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG4gIH1cbiAgdmFyIGFjY2VwdERhdGEgPSBmdW5jdGlvbiggb3duZXIgKSB7XG5cbiAgICAvLyBBY2NlcHRzIG9ubHk6XG4gICAgLy8gIC0gTm9kZVxuICAgIC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcbiAgICAvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuICAgIC8vICAtIE9iamVjdFxuICAgIC8vICAgIC0gQW55XG4gICAgcmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xuICB9O1xuXG5cblxuXG4gIGZ1bmN0aW9uIERhdGEoKSB7XG4gICAgdGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xuICB9XG5cbiAgRGF0YS51aWQgPSAxO1xuXG4gIERhdGEucHJvdG90eXBlID0ge1xuXG4gICAgY2FjaGU6IGZ1bmN0aW9uKCBvd25lciApIHtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlXG4gICAgICB2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cbiAgICAgIC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuICAgICAgaWYgKCAhdmFsdWUgKSB7XG4gICAgICAgIHZhbHVlID0ge307XG5cbiAgICAgICAgLy8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG4gICAgICAgIC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG4gICAgICAgIC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuICAgICAgICBpZiAoIGFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cbiAgICAgICAgICAvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXG4gICAgICAgICAgLy8gdXNlIHBsYWluIGFzc2lnbm1lbnRcbiAgICAgICAgICBpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuICAgICAgICAgICAgb3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XG5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuICAgICAgICAgICAgLy8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcbiAgICAgICAgICAgIC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBvd25lciwgdGhpcy5leHBhbmRvLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9ICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24oIG93bmVyLCBkYXRhLCB2YWx1ZSApIHtcbiAgICAgIHZhciBwcm9wLFxuICAgICAgICBjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cbiAgICAgIC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3NcbiAgICAgIC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1NylcbiAgICAgIGlmICggdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnICkge1xuICAgICAgICBjYWNoZVsgY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xuXG4gICAgICAgIC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG4gICAgICAgIGZvciAoIHByb3AgaW4gZGF0YSApIHtcbiAgICAgICAgICBjYWNoZVsgY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcbiAgICAgIHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgIHRoaXMuY2FjaGUoIG93bmVyICkgOlxuXG4gICAgICAvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG4gICAgICAgIG93bmVyWyB0aGlzLmV4cGFuZG8gXSAmJiBvd25lclsgdGhpcy5leHBhbmRvIF1bIGNhbWVsQ2FzZSgga2V5ICkgXTtcbiAgICB9LFxuICAgIGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXG4gICAgICAvLyBJbiBjYXNlcyB3aGVyZSBlaXRoZXI6XG4gICAgICAvL1xuICAgICAgLy8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuICAgICAgLy8gICAyLiBBIHN0cmluZyBrZXkgd2FzIHNwZWNpZmllZCwgYnV0IG5vIHZhbHVlIHByb3ZpZGVkXG4gICAgICAvL1xuICAgICAgLy8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG4gICAgICAvLyB3aGljaCB2YWx1ZSB0byByZXR1cm4sIHJlc3BlY3RpdmVseSBlaXRoZXI6XG4gICAgICAvL1xuICAgICAgLy8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuICAgICAgLy8gICAyLiBUaGUgZGF0YSBzdG9yZWQgYXQgdGhlIGtleVxuICAgICAgLy9cbiAgICAgIGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KCAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcbiAgICAgIC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuICAgICAgLy9cbiAgICAgIC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcbiAgICAgIC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG4gICAgICAvL1xuICAgICAgdGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cbiAgICAgIC8vIFNpbmNlIHRoZSBcInNldFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xuICAgICAgLy8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXG4gICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcbiAgICAgIHZhciBpLFxuICAgICAgICBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuICAgICAgaWYgKCBjYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICgga2V5ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgLy8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcbiAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KCBrZXkgKSApIHtcblxuICAgICAgICAgIC8vIElmIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG4gICAgICAgICAgLy8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG4gICAgICAgICAga2V5ID0ga2V5Lm1hcCggY2FtZWxDYXNlICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2V5ID0gY2FtZWxDYXNlKCBrZXkgKTtcblxuICAgICAgICAgIC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cbiAgICAgICAgICAvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuICAgICAgICAgIGtleSA9IGtleSBpbiBjYWNoZSA/XG4gICAgICAgICAgICBbIGtleSBdIDpcbiAgICAgICAgICAgICgga2V5Lm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgPSBrZXkubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgIGRlbGV0ZSBjYWNoZVsga2V5WyBpIF0gXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcbiAgICAgIGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cbiAgICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NVxuICAgICAgICAvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuICAgICAgICAvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG4gICAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3ODYwNyAoYnVnIHJlc3RyaWN0ZWQpXG4gICAgICAgIGlmICggb3duZXIubm9kZVR5cGUgKSB7XG4gICAgICAgICAgb3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcbiAgICAgIHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcbiAgICAgIHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcbiAgICB9XG4gIH07XG4gIHZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbiAgdmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcblxuXG5cbiAgLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbiAgLy9cbiAgLy9cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcbiAgLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuICAvL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4gIC8vXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxuICAvL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuICAvL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4gIC8vXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcblxuICB2YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuICAgIHJtdWx0aURhc2ggPSAvW0EtWl0vZztcblxuICBmdW5jdGlvbiBnZXREYXRhKCBkYXRhICkge1xuICAgIGlmICggZGF0YSA9PT0gJ3RydWUnICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCBkYXRhID09PSAnZmFsc2UnICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICggZGF0YSA9PT0gJ251bGwnICkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcbiAgICBpZiAoIGRhdGEgPT09ICtkYXRhICsgJycgKSB7XG4gICAgICByZXR1cm4gK2RhdGE7XG4gICAgfVxuXG4gICAgaWYgKCByYnJhY2UudGVzdCggZGF0YSApICkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG4gICAgdmFyIG5hbWU7XG5cbiAgICAvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG4gICAgLy8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG4gICAgaWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcbiAgICAgIG5hbWUgPSAnZGF0YS0nICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsICctJCYnICkudG9Mb3dlckNhc2UoKTtcbiAgICAgIGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG4gICAgICBpZiAoIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkYXRhID0gZ2V0RGF0YSggZGF0YSApO1xuICAgICAgICB9IGNhdGNoICggZSApIHt9XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG4gICAgICAgIGRhdGFVc2VyLnNldCggZWxlbSwga2V5LCBkYXRhICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGpRdWVyeS5leHRlbmQoIHtcbiAgICBoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgIHJldHVybiBkYXRhVXNlci5oYXNEYXRhKCBlbGVtICkgfHwgZGF0YVByaXYuaGFzRGF0YSggZWxlbSApO1xuICAgIH0sXG5cbiAgICBkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcbiAgICAgIHJldHVybiBkYXRhVXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG4gICAgICBkYXRhVXNlci5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcbiAgICB9LFxuXG4gICAgLy8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcbiAgICAvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhUHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cbiAgICBfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG4gICAgICByZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG4gICAgfSxcblxuICAgIF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcbiAgICAgIGRhdGFQcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuICAgIH1cbiAgfSApO1xuXG4gIGpRdWVyeS5mbi5leHRlbmQoIHtcbiAgICBkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcbiAgICAgIHZhciBpLCBuYW1lLCBkYXRhLFxuICAgICAgICBlbGVtID0gdGhpc1sgMCBdLFxuICAgICAgICBhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG4gICAgICAvLyBHZXRzIGFsbCB2YWx1ZXNcbiAgICAgIGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIGlmICggdGhpcy5sZW5ndGggKSB7XG4gICAgICAgICAgZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xuXG4gICAgICAgICAgaWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sICdoYXNEYXRhQXR0cnMnICkgKSB7XG4gICAgICAgICAgICBpID0gYXR0cnMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCBpLS0gKSB7XG5cbiAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgMTEgb25seVxuICAgICAgICAgICAgICAvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcbiAgICAgICAgICAgICAgaWYgKCBhdHRyc1sgaSBdICkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCBuYW1lLmluZGV4T2YoICdkYXRhLScgKSA9PT0gMCApIHtcbiAgICAgICAgICAgICAgICAgIG5hbWUgPSBjYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuICAgICAgICAgICAgICAgICAgZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YVByaXYuc2V0KCBlbGVtLCAnaGFzRGF0YUF0dHJzJywgdHJ1ZSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuICAgICAgaWYgKCB0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXkgKTtcbiAgICAgICAgfSApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG4gICAgICAgIHZhciBkYXRhO1xuXG4gICAgICAgIC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XG4gICAgICAgIC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG4gICAgICAgIC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG4gICAgICAgIC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cbiAgICAgICAgaWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG4gICAgICAgICAgLy8gVGhlIGtleSB3aWxsIGFsd2F5cyBiZSBjYW1lbENhc2VkIGluIERhdGFcbiAgICAgICAgICBkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcbiAgICAgICAgICBpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXG4gICAgICAgICAgLy8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuICAgICAgICAgIGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5ICk7XG4gICAgICAgICAgaWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHRoZSBkYXRhLi4uXG4gICAgICAgIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XG4gICAgICAgICAgZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXksIHZhbHVlICk7XG4gICAgICAgIH0gKTtcbiAgICAgIH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuICAgIH0sXG5cbiAgICByZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgIGRhdGFVc2VyLnJlbW92ZSggdGhpcywga2V5ICk7XG4gICAgICB9ICk7XG4gICAgfVxuICB9ICk7XG5cblxuICBqUXVlcnkuZXh0ZW5kKCB7XG4gICAgcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuICAgICAgdmFyIHF1ZXVlO1xuXG4gICAgICBpZiAoIGVsZW0gKSB7XG4gICAgICAgIHR5cGUgPSAoIHR5cGUgfHwgJ2Z4JyApICsgJ3F1ZXVlJztcbiAgICAgICAgcXVldWUgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIHR5cGUgKTtcblxuICAgICAgICAvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG4gICAgICAgIGlmICggZGF0YSApIHtcbiAgICAgICAgICBpZiAoICFxdWV1ZSB8fCBBcnJheS5pc0FycmF5KCBkYXRhICkgKSB7XG4gICAgICAgICAgICBxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goIGRhdGEgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHF1ZXVlIHx8IFtdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcbiAgICAgIHR5cGUgPSB0eXBlIHx8ICdmeCc7XG5cbiAgICAgIHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuICAgICAgICBzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcbiAgICAgICAgZm4gPSBxdWV1ZS5zaGlmdCgpLFxuICAgICAgICBob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuICAgICAgICBuZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgalF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcbiAgICAgICAgfTtcblxuICAgICAgLy8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuICAgICAgaWYgKCBmbiA9PT0gJ2lucHJvZ3Jlc3MnICkge1xuICAgICAgICBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIHN0YXJ0TGVuZ3RoLS07XG4gICAgICB9XG5cbiAgICAgIGlmICggZm4gKSB7XG5cbiAgICAgICAgLy8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG4gICAgICAgIGlmICggdHlwZSA9PT0gJ2Z4JyApIHtcbiAgICAgICAgICBxdWV1ZS51bnNoaWZ0KCAnaW5wcm9ncmVzcycgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cbiAgICAgICAgZGVsZXRlIGhvb2tzLnN0b3A7XG4gICAgICAgIGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG4gICAgICB9XG5cbiAgICAgIGlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkge1xuICAgICAgICBob29rcy5lbXB0eS5maXJlKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG4gICAgX3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuICAgICAgdmFyIGtleSA9IHR5cGUgKyAncXVldWVIb29rcyc7XG4gICAgICByZXR1cm4gZGF0YVByaXYuZ2V0KCBlbGVtLCBrZXkgKSB8fCBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIGtleSwge1xuICAgICAgICBlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggJ29uY2UgbWVtb3J5JyApLmFkZCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyAncXVldWUnLCBrZXkgXSApO1xuICAgICAgICB9IClcbiAgICAgIH0gKTtcbiAgICB9XG4gIH0gKTtcblxuICBqUXVlcnkuZm4uZXh0ZW5kKCB7XG4gICAgcXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuICAgICAgdmFyIHNldHRlciA9IDI7XG5cbiAgICAgIGlmICggdHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnICkge1xuICAgICAgICBkYXRhID0gdHlwZTtcbiAgICAgICAgdHlwZSA9ICdmeCc7XG4gICAgICAgIHNldHRlci0tO1xuICAgICAgfVxuXG4gICAgICBpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG4gICAgICAgIHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbIDAgXSwgdHlwZSApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgdGhpcyA6XG4gICAgICAgIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cbiAgICAgICAgICAvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuICAgICAgICAgIGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG4gICAgICAgICAgaWYgKCB0eXBlID09PSAnZngnICYmIHF1ZXVlWyAwIF0gIT09ICdpbnByb2dyZXNzJyApIHtcbiAgICAgICAgICAgIGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG4gICAgICAgICAgfVxuICAgICAgICB9ICk7XG4gICAgfSxcbiAgICBkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuICAgICAgICBqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuICAgICAgfSApO1xuICAgIH0sXG4gICAgY2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG4gICAgICByZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCAnZngnLCBbXSApO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXG4gICAgLy8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG4gICAgcHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcbiAgICAgIHZhciB0bXAsXG4gICAgICAgIGNvdW50ID0gMSxcbiAgICAgICAgZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcbiAgICAgICAgZWxlbWVudHMgPSB0aGlzLFxuICAgICAgICBpID0gdGhpcy5sZW5ndGgsXG4gICAgICAgIHJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoICEoIC0tY291bnQgKSApIHtcbiAgICAgICAgICAgIGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICBpZiAoIHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJyApIHtcbiAgICAgICAgb2JqID0gdHlwZTtcbiAgICAgICAgdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHR5cGUgPSB0eXBlIHx8ICdmeCc7XG5cbiAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICB0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyAncXVldWVIb29rcycgKTtcbiAgICAgICAgaWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgdG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXNvbHZlKCk7XG4gICAgICByZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG4gICAgfVxuICB9ICk7XG4gIHZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxuICB2YXIgcmNzc051bSA9IG5ldyBSZWdFeHAoICdeKD86KFsrLV0pPXwpKCcgKyBwbnVtICsgJykoW2EteiVdKikkJywgJ2knICk7XG5cblxuICB2YXIgY3NzRXhwYW5kID0gWyAnVG9wJywgJ1JpZ2h0JywgJ0JvdHRvbScsICdMZWZ0JyBdO1xuXG4gIHZhciBpc0hpZGRlbldpdGhpblRyZWUgPSBmdW5jdGlvbiggZWxlbSwgZWwgKSB7XG5cbiAgICAvLyBpc0hpZGRlbldpdGhpblRyZWUgbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcbiAgICAvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcbiAgICBlbGVtID0gZWwgfHwgZWxlbTtcblxuICAgIC8vIElubGluZSBzdHlsZSB0cnVtcHMgYWxsXG4gICAgcmV0dXJuIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnIHx8XG5cdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPT09ICcnICYmXG5cblx0XHRcdC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG5cdFx0XHQvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcblx0XHRcdC8vIGluIHRoZSBkb2N1bWVudC5cblx0XHRcdGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgJiZcblxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgJ2Rpc3BsYXknICkgPT09ICdub25lJztcbiAgfTtcblxuICB2YXIgc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjaywgYXJncyApIHtcbiAgICB2YXIgcmV0LCBuYW1lLFxuICAgICAgb2xkID0ge307XG5cbiAgICAvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcbiAgICBmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG4gICAgICBvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcbiAgICAgIGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcbiAgICB9XG5cbiAgICByZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xuXG4gICAgLy8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG4gICAgZm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuICAgICAgZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuXG5cblxuICBmdW5jdGlvbiBhZGp1c3RDU1MoIGVsZW0sIHByb3AsIHZhbHVlUGFydHMsIHR3ZWVuICkge1xuICAgIHZhciBhZGp1c3RlZCwgc2NhbGUsXG4gICAgICBtYXhJdGVyYXRpb25zID0gMjAsXG4gICAgICBjdXJyZW50VmFsdWUgPSB0d2VlbiA/XG4gICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0d2Vlbi5jdXIoKTtcbiAgICAgICAgfSA6XG4gICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCAnJyApO1xuICAgICAgICB9LFxuICAgICAgaW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuICAgICAgdW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gJycgOiAncHgnICksXG5cbiAgICAgIC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG4gICAgICBpbml0aWFsSW5Vbml0ID0gKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gJ3B4JyAmJiAraW5pdGlhbCApICYmXG5cdFx0XHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG4gICAgaWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcblxuICAgICAgLy8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG4gICAgICAvLyBIYWx2ZSB0aGUgaXRlcmF0aW9uIHRhcmdldCB2YWx1ZSB0byBwcmV2ZW50IGludGVyZmVyZW5jZSBmcm9tIENTUyB1cHBlciBib3VuZHMgKGdoLTIxNDQpXG4gICAgICBpbml0aWFsID0gaW5pdGlhbCAvIDI7XG5cbiAgICAgIC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3NcbiAgICAgIHVuaXQgPSB1bml0IHx8IGluaXRpYWxJblVuaXRbIDMgXTtcblxuICAgICAgLy8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcbiAgICAgIGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG4gICAgICB3aGlsZSAoIG1heEl0ZXJhdGlvbnMtLSApIHtcblxuICAgICAgICAvLyBFdmFsdWF0ZSBhbmQgdXBkYXRlIG91ciBiZXN0IGd1ZXNzIChkb3VibGluZyBndWVzc2VzIHRoYXQgemVybyBvdXQpLlxuICAgICAgICAvLyBGaW5pc2ggaWYgdGhlIHNjYWxlIGVxdWFscyBvciBjcm9zc2VzIDEgKG1ha2luZyB0aGUgb2xkKm5ldyBwcm9kdWN0IG5vbi1wb3NpdGl2ZSkuXG4gICAgICAgIGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcbiAgICAgICAgaWYgKCAoIDEgLSBzY2FsZSApICogKCAxIC0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCB8fCAwLjUgKSApIDw9IDAgKSB7XG4gICAgICAgICAgbWF4SXRlcmF0aW9ucyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcblxuICAgICAgfVxuXG4gICAgICBpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAqIDI7XG4gICAgICBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cbiAgICAgIHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuICAgIH1cblxuICAgIGlmICggdmFsdWVQYXJ0cyApIHtcbiAgICAgIGluaXRpYWxJblVuaXQgPSAraW5pdGlhbEluVW5pdCB8fCAraW5pdGlhbCB8fCAwO1xuXG4gICAgICAvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcbiAgICAgIGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cbiAgICAgICAgaW5pdGlhbEluVW5pdCArICggdmFsdWVQYXJ0c1sgMSBdICsgMSApICogdmFsdWVQYXJ0c1sgMiBdIDpcbiAgICAgICAgK3ZhbHVlUGFydHNbIDIgXTtcbiAgICAgIGlmICggdHdlZW4gKSB7XG4gICAgICAgIHR3ZWVuLnVuaXQgPSB1bml0O1xuICAgICAgICB0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG4gICAgICAgIHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWRqdXN0ZWQ7XG4gIH1cblxuXG4gIHZhciBkZWZhdWx0RGlzcGxheU1hcCA9IHt9O1xuXG4gIGZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xuICAgIHZhciB0ZW1wLFxuICAgICAgZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuICAgICAgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuICAgICAgZGlzcGxheSA9IGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdO1xuXG4gICAgaWYgKCBkaXNwbGF5ICkge1xuICAgICAgcmV0dXJuIGRpc3BsYXk7XG4gICAgfVxuXG4gICAgdGVtcCA9IGRvYy5ib2R5LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlRWxlbWVudCggbm9kZU5hbWUgKSApO1xuICAgIGRpc3BsYXkgPSBqUXVlcnkuY3NzKCB0ZW1wLCAnZGlzcGxheScgKTtcblxuICAgIHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xuXG4gICAgaWYgKCBkaXNwbGF5ID09PSAnbm9uZScgKSB7XG4gICAgICBkaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB9XG4gICAgZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXG4gICAgcmV0dXJuIGRpc3BsYXk7XG4gIH1cblxuICBmdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG4gICAgdmFyIGRpc3BsYXksIGVsZW0sXG4gICAgICB2YWx1ZXMgPSBbXSxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuICAgIC8vIERldGVybWluZSBuZXcgZGlzcGxheSB2YWx1ZSBmb3IgZWxlbWVudHMgdGhhdCBuZWVkIHRvIGNoYW5nZVxuICAgIGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG4gICAgICBlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG4gICAgICBpZiAoICFlbGVtLnN0eWxlICkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcbiAgICAgIGlmICggc2hvdyApIHtcblxuICAgICAgICAvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG4gICAgICAgIC8vIGNoZWNrIGlzIHJlcXVpcmVkIGluIHRoaXMgZmlyc3QgbG9vcCB1bmxlc3Mgd2UgaGF2ZSBhIG5vbmVtcHR5IGRpc3BsYXkgdmFsdWUgKGVpdGhlclxuICAgICAgICAvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXG4gICAgICAgIGlmICggZGlzcGxheSA9PT0gJ25vbmUnICkge1xuICAgICAgICAgIHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgJ2Rpc3BsYXknICkgfHwgbnVsbDtcbiAgICAgICAgICBpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XG4gICAgICAgICAgICBlbGVtLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09ICcnICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApICkge1xuICAgICAgICAgIHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICggZGlzcGxheSAhPT0gJ25vbmUnICkge1xuICAgICAgICAgIHZhbHVlc1sgaW5kZXggXSA9ICdub25lJztcblxuICAgICAgICAgIC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcbiAgICAgICAgICBkYXRhUHJpdi5zZXQoIGVsZW0sICdkaXNwbGF5JywgZGlzcGxheSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoZSBkaXNwbGF5IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wIHRvIGF2b2lkIGNvbnN0YW50IHJlZmxvd1xuICAgIGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG4gICAgICBpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xuICAgICAgICBlbGVtZW50c1sgaW5kZXggXS5zdHlsZS5kaXNwbGF5ID0gdmFsdWVzWyBpbmRleCBdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50cztcbiAgfVxuXG4gIGpRdWVyeS5mbi5leHRlbmQoIHtcbiAgICBzaG93OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuICAgIH0sXG4gICAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcbiAgICB9LFxuICAgIHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xuICAgICAgaWYgKCB0eXBlb2Ygc3RhdGUgPT09ICdib29sZWFuJyApIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICggaXNIaWRkZW5XaXRoaW5UcmVlKCB0aGlzICkgKSB7XG4gICAgICAgICAgalF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGpRdWVyeSggdGhpcyApLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgfSApO1xuICAgIH1cbiAgfSApO1xuICB2YXIgcmNoZWNrYWJsZVR5cGUgPSAoIC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pICk7XG5cbiAgdmFyIHJ0YWdOYW1lID0gKCAvPChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSspL2kgKTtcblxuICB2YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxebW9kdWxlJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbiAgLy8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcbiAgdmFyIHdyYXBNYXAgPSB7XG5cbiAgICAvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuICAgIG9wdGlvbjogWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgJzwvc2VsZWN0PicgXSxcblxuICAgIC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXG4gICAgLy8gc2FtZSB3YXkgdGhhdCB0YWcgc291cCBwYXJzZXJzIGRvLiBTbyB3ZSBjYW5ub3Qgc2hvcnRlblxuICAgIC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cbiAgICB0aGVhZDogWyAxLCAnPHRhYmxlPicsICc8L3RhYmxlPicgXSxcbiAgICBjb2w6IFsgMiwgJzx0YWJsZT48Y29sZ3JvdXA+JywgJzwvY29sZ3JvdXA+PC90YWJsZT4nIF0sXG4gICAgdHI6IFsgMiwgJzx0YWJsZT48dGJvZHk+JywgJzwvdGJvZHk+PC90YWJsZT4nIF0sXG4gICAgdGQ6IFsgMywgJzx0YWJsZT48dGJvZHk+PHRyPicsICc8L3RyPjwvdGJvZHk+PC90YWJsZT4nIF0sXG5cbiAgICBfZGVmYXVsdDogWyAwLCAnJywgJycgXVxuICB9O1xuXG4gIC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4gIHdyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbjtcblxuICB3cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xuICB3cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuXG4gIGZ1bmN0aW9uIGdldEFsbCggY29udGV4dCwgdGFnICkge1xuXG4gICAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuICAgIC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcbiAgICB2YXIgcmV0O1xuXG4gICAgaWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICByZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgJyonICk7XG5cbiAgICB9IGVsc2UgaWYgKCB0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSAndW5kZWZpbmVkJyApIHtcbiAgICAgIHJldCA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8ICcqJyApO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldCA9IFtdO1xuICAgIH1cblxuICAgIGlmICggdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIG5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSApIHtcbiAgICAgIHJldHVybiBqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cblxuICAvLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbiAgZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xuICAgIHZhciBpID0gMCxcbiAgICAgIGwgPSBlbGVtcy5sZW5ndGg7XG5cbiAgICBmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG4gICAgICBkYXRhUHJpdi5zZXQoXG4gICAgICAgIGVsZW1zWyBpIF0sXG4gICAgICAgICdnbG9iYWxFdmFsJyxcbiAgICAgICAgIXJlZkVsZW1lbnRzIHx8IGRhdGFQcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgJ2dsb2JhbEV2YWwnIClcbiAgICAgICk7XG4gICAgfVxuICB9XG5cblxuICB2YXIgcmh0bWwgPSAvPHwmIz9cXHcrOy87XG5cbiAgZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcbiAgICB2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGNvbnRhaW5zLCBqLFxuICAgICAgZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcbiAgICAgIG5vZGVzID0gW10sXG4gICAgICBpID0gMCxcbiAgICAgIGwgPSBlbGVtcy5sZW5ndGg7XG5cbiAgICBmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG4gICAgICBlbGVtID0gZWxlbXNbIGkgXTtcblxuICAgICAgaWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cbiAgICAgICAgLy8gQWRkIG5vZGVzIGRpcmVjdGx5XG4gICAgICAgIGlmICggdG9UeXBlKCBlbGVtICkgPT09ICdvYmplY3QnICkge1xuXG4gICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG4gICAgICAgICAgLy8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuICAgICAgICAgIGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuICAgICAgICAgIC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuICAgICAgICB9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuICAgICAgICAgIG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xuXG4gICAgICAgICAgLy8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoICdkaXYnICkgKTtcblxuICAgICAgICAgIC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cbiAgICAgICAgICB0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbICcnLCAnJyBdIClbIDEgXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuICAgICAgICAgIHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG4gICAgICAgICAgLy8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XG4gICAgICAgICAgaiA9IHdyYXBbIDAgXTtcbiAgICAgICAgICB3aGlsZSAoIGotLSApIHtcbiAgICAgICAgICAgIHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG4gICAgICAgICAgLy8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuICAgICAgICAgIGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cbiAgICAgICAgICAvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuICAgICAgICAgIHRtcCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cbiAgICAgICAgICAvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXG4gICAgICAgICAgdG1wLnRleHRDb250ZW50ID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG4gICAgZnJhZ21lbnQudGV4dENvbnRlbnQgPSAnJztcblxuICAgIGkgPSAwO1xuICAgIHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cbiAgICAgIC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG4gICAgICBpZiAoIHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheSggZWxlbSwgc2VsZWN0aW9uICkgPiAtMSApIHtcbiAgICAgICAgaWYgKCBpZ25vcmVkICkge1xuICAgICAgICAgIGlnbm9yZWQucHVzaCggZWxlbSApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb250YWlucyA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cbiAgICAgIC8vIEFwcGVuZCB0byBmcmFnbWVudFxuICAgICAgdG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCAnc2NyaXB0JyApO1xuXG4gICAgICAvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG4gICAgICBpZiAoIGNvbnRhaW5zICkge1xuICAgICAgICBzZXRHbG9iYWxFdmFsKCB0bXAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuICAgICAgaWYgKCBzY3JpcHRzICkge1xuICAgICAgICBqID0gMDtcbiAgICAgICAgd2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG4gICAgICAgICAgaWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgJycgKSApIHtcbiAgICAgICAgICAgIHNjcmlwdHMucHVzaCggZWxlbSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfVxuXG5cbiAgKCBmdW5jdGlvbigpIHtcbiAgICB2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG4gICAgICBkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKSApLFxuICAgICAgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnaW5wdXQnICk7XG5cbiAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG4gICAgLy8gQ2hlY2sgc3RhdGUgbG9zdCBpZiB0aGUgbmFtZSBpcyBzZXQgKCMxMTIxNylcbiAgICAvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG4gICAgLy8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG4gICAgaW5wdXQuc2V0QXR0cmlidXRlKCAndHlwZScsICdyYWRpbycgKTtcbiAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoICdjaGVja2VkJywgJ2NoZWNrZWQnICk7XG4gICAgaW5wdXQuc2V0QXR0cmlidXRlKCAnbmFtZScsICd0JyApO1xuXG4gICAgZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXG4gICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XG4gICAgLy8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG4gICAgc3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xuXG4gICAgLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4gICAgLy8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcbiAgICBkaXYuaW5uZXJIVE1MID0gJzx0ZXh0YXJlYT54PC90ZXh0YXJlYT4nO1xuICAgIHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSAhIWRpdi5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xuICB9ICkoKTtcbiAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cbiAgdmFyXG4gICAgcmtleUV2ZW50ID0gL15rZXkvLFxuICAgIHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svLFxuICAgIHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpLztcblxuICBmdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbiAgLy8gU2VlICMxMzM5MyBmb3IgbW9yZSBpbmZvXG4gIGZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICB9IGNhdGNoICggZXJyICkgeyB9XG4gIH1cblxuICBmdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuICAgIHZhciBvcmlnRm4sIHR5cGU7XG5cbiAgICAvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcbiAgICBpZiAoIHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcgKSB7XG5cbiAgICAgIC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG4gICAgICBpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gJ3N0cmluZycgKSB7XG5cbiAgICAgICAgLy8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuICAgICAgICBkYXRhID0gZGF0YSB8fCBzZWxlY3RvcjtcbiAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuICAgICAgICBvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW07XG4gICAgfVxuXG4gICAgaWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcblxuICAgICAgLy8gKCB0eXBlcywgZm4gKVxuICAgICAgZm4gPSBzZWxlY3RvcjtcbiAgICAgIGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuICAgICAgaWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09ICdzdHJpbmcnICkge1xuXG4gICAgICAgIC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG4gICAgICAgIGZuID0gZGF0YTtcbiAgICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gKCB0eXBlcywgZGF0YSwgZm4gKVxuICAgICAgICBmbiA9IGRhdGE7XG4gICAgICAgIGRhdGEgPSBzZWxlY3RvcjtcbiAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICggZm4gPT09IGZhbHNlICkge1xuICAgICAgZm4gPSByZXR1cm5GYWxzZTtcbiAgICB9IGVsc2UgaWYgKCAhZm4gKSB7XG4gICAgICByZXR1cm4gZWxlbTtcbiAgICB9XG5cbiAgICBpZiAoIG9uZSA9PT0gMSApIHtcbiAgICAgIG9yaWdGbiA9IGZuO1xuICAgICAgZm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cbiAgICAgICAgLy8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG4gICAgICAgIGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcbiAgICAgICAgcmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICB9O1xuXG4gICAgICAvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuICAgICAgZm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG4gICAgfVxuICAgIHJldHVybiBlbGVtLmVhY2goIGZ1bmN0aW9uKCkge1xuICAgICAgalF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuICAgIH0gKTtcbiAgfVxuXG4gIC8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG4gIGpRdWVyeS5ldmVudCA9IHtcblxuICAgIGdsb2JhbDoge30sXG5cbiAgICBhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cbiAgICAgIHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcbiAgICAgICAgZXZlbnRzLCB0LCBoYW5kbGVPYmosXG4gICAgICAgIHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcbiAgICAgICAgZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuICAgICAgLy8gRG9uJ3QgYXR0YWNoIGV2ZW50cyB0byBub0RhdGEgb3IgdGV4dC9jb21tZW50IG5vZGVzIChidXQgYWxsb3cgcGxhaW4gb2JqZWN0cylcbiAgICAgIGlmICggIWVsZW1EYXRhICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuICAgICAgaWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG4gICAgICAgIGhhbmRsZU9iakluID0gaGFuZGxlcjtcbiAgICAgICAgaGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG4gICAgICAgIHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG4gICAgICB9XG5cbiAgICAgIC8vIEVuc3VyZSB0aGF0IGludmFsaWQgc2VsZWN0b3JzIHRocm93IGV4Y2VwdGlvbnMgYXQgYXR0YWNoIHRpbWVcbiAgICAgIC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuICAgICAgaWYgKCBzZWxlY3RvciApIHtcbiAgICAgICAgalF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBkb2N1bWVudEVsZW1lbnQsIHNlbGVjdG9yICk7XG4gICAgICB9XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuICAgICAgaWYgKCAhaGFuZGxlci5ndWlkICkge1xuICAgICAgICBoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuICAgICAgfVxuXG4gICAgICAvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG4gICAgICBpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuICAgICAgICBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcbiAgICAgICAgZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblxuICAgICAgICAgIC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG4gICAgICAgICAgLy8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuICAgICAgICAgIHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSAndW5kZWZpbmVkJyAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBlbGVtLCBhcmd1bWVudHMgKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuICAgICAgdHlwZXMgPSAoIHR5cGVzIHx8ICcnICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbICcnIF07XG4gICAgICB0ID0gdHlwZXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCB0LS0gKSB7XG4gICAgICAgIHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcbiAgICAgICAgdHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG4gICAgICAgIG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8ICcnICkuc3BsaXQoICcuJyApLnNvcnQoKTtcblxuICAgICAgICAvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcbiAgICAgICAgaWYgKCAhdHlwZSApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuICAgICAgICAvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcbiAgICAgICAgdHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcbiAgICAgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cbiAgICAgICAgLy8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgaGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xuICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgb3JpZ1R5cGU6IG9yaWdUeXBlLFxuICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgICAgICBndWlkOiBoYW5kbGVyLmd1aWQsXG4gICAgICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgICAgICAgIG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG4gICAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oICcuJyApXG4gICAgICAgIH0sIGhhbmRsZU9iakluICk7XG5cbiAgICAgICAgLy8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3RcbiAgICAgICAgaWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XG4gICAgICAgICAgaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuICAgICAgICAgIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG4gICAgICAgICAgLy8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG4gICAgICAgICAgaWYgKCAhc3BlY2lhbC5zZXR1cCB8fFxuXHRcdFx0XHRcdHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICAgIGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuICAgICAgICAgICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBzcGVjaWFsLmFkZCApIHtcbiAgICAgICAgICBzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuICAgICAgICAgIGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG4gICAgICAgICAgICBoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG4gICAgICAgIGlmICggc2VsZWN0b3IgKSB7XG4gICAgICAgICAgaGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuICAgICAgICBqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuICAgIHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cbiAgICAgIHZhciBqLCBvcmlnQ291bnQsIHRtcCxcbiAgICAgICAgZXZlbnRzLCB0LCBoYW5kbGVPYmosXG4gICAgICAgIHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcbiAgICAgICAgZWxlbURhdGEgPSBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICkgJiYgZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cbiAgICAgIGlmICggIWVsZW1EYXRhIHx8ICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcbiAgICAgIHR5cGVzID0gKCB0eXBlcyB8fCAnJyApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyAnJyBdO1xuICAgICAgdCA9IHR5cGVzLmxlbmd0aDtcbiAgICAgIHdoaWxlICggdC0tICkge1xuICAgICAgICB0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG4gICAgICAgIHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuICAgICAgICBuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCAnJyApLnNwbGl0KCAnLicgKS5zb3J0KCk7XG5cbiAgICAgICAgLy8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG4gICAgICAgIGlmICggIXR5cGUgKSB7XG4gICAgICAgICAgZm9yICggdHlwZSBpbiBldmVudHMgKSB7XG4gICAgICAgICAgICBqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcbiAgICAgICAgdHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuICAgICAgICBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuICAgICAgICB0bXAgPSB0bXBbIDIgXSAmJlxuXHRcdFx0XHRuZXcgUmVnRXhwKCAnKF58XFxcXC4pJyArIG5hbWVzcGFjZXMuam9pbiggJ1xcXFwuKD86LipcXFxcLnwpJyApICsgJyhcXFxcLnwkKScgKTtcblxuICAgICAgICAvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG4gICAgICAgIG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggai0tICkge1xuICAgICAgICAgIGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cbiAgICAgICAgICBpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPT09ICcqKicgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG4gICAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuICAgICAgICAgICAgaWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICAgIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG4gICAgICAgICAgICAgIHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3RcbiAgICAgICAgLy8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG4gICAgICAgIGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG4gICAgICAgICAgaWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxuXHRcdFx0XHRcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXG4gICAgICAgICAgICBqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuICAgICAgaWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG4gICAgICAgIGRhdGFQcml2LnJlbW92ZSggZWxlbSwgJ2hhbmRsZSBldmVudHMnICk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGRpc3BhdGNoOiBmdW5jdGlvbiggbmF0aXZlRXZlbnQgKSB7XG5cbiAgICAgIC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuICAgICAgdmFyIGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKTtcblxuICAgICAgdmFyIGksIGosIHJldCwgbWF0Y2hlZCwgaGFuZGxlT2JqLCBoYW5kbGVyUXVldWUsXG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoIGFyZ3VtZW50cy5sZW5ndGggKSxcbiAgICAgICAgaGFuZGxlcnMgPSAoIGRhdGFQcml2LmdldCggdGhpcywgJ2V2ZW50cycgKSB8fCB7fSApWyBldmVudC50eXBlIF0gfHwgW10sXG4gICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG4gICAgICAvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuICAgICAgYXJnc1sgMCBdID0gZXZlbnQ7XG5cbiAgICAgIGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICBhcmdzWyBpIF0gPSBhcmd1bWVudHNbIGkgXTtcbiAgICAgIH1cblxuICAgICAgZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG4gICAgICAvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG4gICAgICBpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXRlcm1pbmUgaGFuZGxlcnNcbiAgICAgIGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuICAgICAgLy8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcbiAgICAgIGkgPSAwO1xuICAgICAgd2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG4gICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cbiAgICAgICAgaiA9IDA7XG4gICAgICAgIHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG5cdFx0XHRcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG4gICAgICAgICAgLy8gVHJpZ2dlcmVkIGV2ZW50IG11c3QgZWl0aGVyIDEpIGhhdmUgbm8gbmFtZXNwYWNlLCBvciAyKSBoYXZlIG5hbWVzcGFjZShzKVxuICAgICAgICAgIC8vIGEgc3Vic2V0IG9yIGVxdWFsIHRvIHRob3NlIGluIHRoZSBib3VuZCBldmVudCAoYm90aCBjYW4gaGF2ZSBubyBuYW1lc3BhY2UpLlxuICAgICAgICAgIGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgZXZlbnQucm5hbWVzcGFjZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cbiAgICAgICAgICAgIGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcbiAgICAgICAgICAgIGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuICAgICAgICAgICAgcmV0ID0gKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyBoYW5kbGVPYmoub3JpZ1R5cGUgXSB8fCB7fSApLmhhbmRsZSB8fFxuXHRcdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIgKS5hcHBseSggbWF0Y2hlZC5lbGVtLCBhcmdzICk7XG5cbiAgICAgICAgICAgIGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgIGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG4gICAgICBpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuICAgICAgICBzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXZlbnQucmVzdWx0O1xuICAgIH0sXG5cbiAgICBoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcbiAgICAgIHZhciBpLCBoYW5kbGVPYmosIHNlbCwgbWF0Y2hlZEhhbmRsZXJzLCBtYXRjaGVkU2VsZWN0b3JzLFxuICAgICAgICBoYW5kbGVyUXVldWUgPSBbXSxcbiAgICAgICAgZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG4gICAgICAgIGN1ciA9IGV2ZW50LnRhcmdldDtcblxuICAgICAgLy8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuICAgICAgaWYgKCBkZWxlZ2F0ZUNvdW50ICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OVxuXHRcdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKHRyYWMtMTMxODApXG5cdFx0XHRjdXIubm9kZVR5cGUgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQyXG5cdFx0XHQvLyBTdXBwcmVzcyBzcGVjLXZpb2xhdGluZyBjbGlja3MgaW5kaWNhdGluZyBhIG5vbi1wcmltYXJ5IHBvaW50ZXIgYnV0dG9uICh0cmFjLTM4NjEpXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudC10eXBlLWNsaWNrXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHQvLyAuLi5idXQgbm90IGFycm93IGtleSBcImNsaWNrc1wiIG9mIHJhZGlvIGlucHV0cywgd2hpY2ggY2FuIGhhdmUgYGJ1dHRvbmAgLTEgKGdoLTIzNDMpXG5cdFx0XHQhKCBldmVudC50eXBlID09PSAnY2xpY2snICYmIGV2ZW50LmJ1dHRvbiA+PSAxICkgKSB7XG5cbiAgICAgICAgZm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cbiAgICAgICAgICAvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcbiAgICAgICAgICAvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcbiAgICAgICAgICBpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAhKCBldmVudC50eXBlID09PSAnY2xpY2snICYmIGN1ci5kaXNhYmxlZCA9PT0gdHJ1ZSApICkge1xuICAgICAgICAgICAgbWF0Y2hlZEhhbmRsZXJzID0gW107XG4gICAgICAgICAgICBtYXRjaGVkU2VsZWN0b3JzID0ge307XG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcbiAgICAgICAgICAgICAgaGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblxuICAgICAgICAgICAgICAvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuICAgICAgICAgICAgICBzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyAnICc7XG5cbiAgICAgICAgICAgICAgaWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG4gICAgICAgICAgICAgICAgICBqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcbiAgICAgICAgICAgICAgICAgIGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSApIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVkSGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggbWF0Y2hlZEhhbmRsZXJzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgaGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlZEhhbmRsZXJzIH0gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuICAgICAgY3VyID0gdGhpcztcbiAgICAgIGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcbiAgICAgICAgaGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9ICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYW5kbGVyUXVldWU7XG4gICAgfSxcblxuICAgIGFkZFByb3A6IGZ1bmN0aW9uKCBuYW1lLCBob29rICkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGlzRnVuY3Rpb24oIGhvb2sgKSA/XG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhvb2soIHRoaXMub3JpZ2luYWxFdmVudCApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gOlxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgbmFtZSwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgfSApO1xuICAgICAgICB9XG4gICAgICB9ICk7XG4gICAgfSxcblxuICAgIGZpeDogZnVuY3Rpb24oIG9yaWdpbmFsRXZlbnQgKSB7XG4gICAgICByZXR1cm4gb3JpZ2luYWxFdmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG4gICAgICAgIG9yaWdpbmFsRXZlbnQgOlxuICAgICAgICBuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XG4gICAgfSxcblxuICAgIHNwZWNpYWw6IHtcbiAgICAgIGxvYWQ6IHtcblxuICAgICAgICAvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG4gICAgICAgIG5vQnViYmxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgZm9jdXM6IHtcblxuICAgICAgICAvLyBGaXJlIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3RcbiAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCB0aGlzICE9PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuZm9jdXMgKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZWxlZ2F0ZVR5cGU6ICdmb2N1c2luJ1xuICAgICAgfSxcbiAgICAgIGJsdXI6IHtcbiAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCB0aGlzID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuYmx1ciApIHtcbiAgICAgICAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGVsZWdhdGVUeXBlOiAnZm9jdXNvdXQnXG4gICAgICB9LFxuICAgICAgY2xpY2s6IHtcblxuICAgICAgICAvLyBGb3IgY2hlY2tib3gsIGZpcmUgbmF0aXZlIGV2ZW50IHNvIGNoZWNrZWQgc3RhdGUgd2lsbCBiZSByaWdodFxuICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoIHRoaXMudHlwZSA9PT0gJ2NoZWNrYm94JyAmJiB0aGlzLmNsaWNrICYmIG5vZGVOYW1lKCB0aGlzLCAnaW5wdXQnICkgKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWNrKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBkb24ndCBmaXJlIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuICAgICAgICBfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuICAgICAgICAgIHJldHVybiBub2RlTmFtZSggZXZlbnQudGFyZ2V0LCAnYScgKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgYmVmb3JldW5sb2FkOiB7XG4gICAgICAgIHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG4gICAgICAgICAgLy8gU3VwcG9ydDogRmlyZWZveCAyMCtcbiAgICAgICAgICAvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG4gICAgICAgICAgaWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuICAgICAgICAgICAgZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgalF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuICAgIC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuICAgIGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcbiAgICB9XG4gIH07XG5cbiAgalF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cbiAgICAvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcbiAgICBpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQgKSApIHtcbiAgICAgIHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG4gICAgfVxuXG4gICAgLy8gRXZlbnQgb2JqZWN0XG4gICAgaWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG4gICAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG4gICAgICB0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuICAgICAgLy8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcbiAgICAgIC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuICAgICAgICByZXR1cm5UcnVlIDpcbiAgICAgICAgcmV0dXJuRmFsc2U7XG5cbiAgICAgIC8vIENyZWF0ZSB0YXJnZXQgcHJvcGVydGllc1xuICAgICAgLy8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuICAgICAgLy8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0MylcbiAgICAgIHRoaXMudGFyZ2V0ID0gKCBzcmMudGFyZ2V0ICYmIHNyYy50YXJnZXQubm9kZVR5cGUgPT09IDMgKSA/XG4gICAgICAgIHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XG4gICAgICAgIHNyYy50YXJnZXQ7XG5cbiAgICAgIHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xuICAgICAgdGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cbiAgICAgIC8vIEV2ZW50IHR5cGVcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50eXBlID0gc3JjO1xuICAgIH1cblxuICAgIC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG4gICAgaWYgKCBwcm9wcyApIHtcbiAgICAgIGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcbiAgICB0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG5cbiAgICAvLyBNYXJrIGl0IGFzIGZpeGVkXG4gICAgdGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG4gIH07XG5cbiAgLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbiAgalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuICAgIGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG4gICAgaXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuICAgIGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcbiAgICBpc1NpbXVsYXRlZDogZmFsc2UsXG5cbiAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG4gICAgICBpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuICAgICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cbiAgICAgIGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuICAgICAgdGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cbiAgICAgIGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gSW5jbHVkZXMgYWxsIGNvbW1vbiBldmVudCBwcm9wcyBpbmNsdWRpbmcgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnQgc3BlY2lmaWMgcHJvcHNcbiAgalF1ZXJ5LmVhY2goIHtcbiAgICBhbHRLZXk6IHRydWUsXG4gICAgYnViYmxlczogdHJ1ZSxcbiAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgIGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxuICAgIGN0cmxLZXk6IHRydWUsXG4gICAgZGV0YWlsOiB0cnVlLFxuICAgIGV2ZW50UGhhc2U6IHRydWUsXG4gICAgbWV0YUtleTogdHJ1ZSxcbiAgICBwYWdlWDogdHJ1ZSxcbiAgICBwYWdlWTogdHJ1ZSxcbiAgICBzaGlmdEtleTogdHJ1ZSxcbiAgICB2aWV3OiB0cnVlLFxuICAgICdjaGFyJzogdHJ1ZSxcbiAgICBjaGFyQ29kZTogdHJ1ZSxcbiAgICBrZXk6IHRydWUsXG4gICAga2V5Q29kZTogdHJ1ZSxcbiAgICBidXR0b246IHRydWUsXG4gICAgYnV0dG9uczogdHJ1ZSxcbiAgICBjbGllbnRYOiB0cnVlLFxuICAgIGNsaWVudFk6IHRydWUsXG4gICAgb2Zmc2V0WDogdHJ1ZSxcbiAgICBvZmZzZXRZOiB0cnVlLFxuICAgIHBvaW50ZXJJZDogdHJ1ZSxcbiAgICBwb2ludGVyVHlwZTogdHJ1ZSxcbiAgICBzY3JlZW5YOiB0cnVlLFxuICAgIHNjcmVlblk6IHRydWUsXG4gICAgdGFyZ2V0VG91Y2hlczogdHJ1ZSxcbiAgICB0b0VsZW1lbnQ6IHRydWUsXG4gICAgdG91Y2hlczogdHJ1ZSxcblxuICAgIHdoaWNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG4gICAgICB2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuXG4gICAgICAvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcbiAgICAgIGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCAmJiBya2V5RXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuICAgICAgICByZXR1cm4gZXZlbnQuY2hhckNvZGUgIT0gbnVsbCA/IGV2ZW50LmNoYXJDb2RlIDogZXZlbnQua2V5Q29kZTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuICAgICAgaWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgcm1vdXNlRXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuICAgICAgICBpZiAoIGJ1dHRvbiAmIDEgKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGJ1dHRvbiAmIDIgKSB7XG4gICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGJ1dHRvbiAmIDQgKSB7XG4gICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV2ZW50LndoaWNoO1xuICAgIH1cbiAgfSwgalF1ZXJ5LmV2ZW50LmFkZFByb3AgKTtcblxuICAvLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3NcbiAgLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cbiAgLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcbiAgLy9cbiAgLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxuICAvLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcbiAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XG4gIC8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXG4gIGpRdWVyeS5lYWNoKCB7XG4gICAgbW91c2VlbnRlcjogJ21vdXNlb3ZlcicsXG4gICAgbW91c2VsZWF2ZTogJ21vdXNlb3V0JyxcbiAgICBwb2ludGVyZW50ZXI6ICdwb2ludGVyb3ZlcicsXG4gICAgcG9pbnRlcmxlYXZlOiAncG9pbnRlcm91dCdcbiAgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcbiAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuICAgICAgZGVsZWdhdGVUeXBlOiBmaXgsXG4gICAgICBiaW5kVHlwZTogZml4LFxuXG4gICAgICBoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgICAgICAgdmFyIHJldCxcbiAgICAgICAgICB0YXJnZXQgPSB0aGlzLFxuICAgICAgICAgIHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuICAgICAgICAgIGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuICAgICAgICAvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuICAgICAgICAvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuICAgICAgICBpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG4gICAgICAgICAgZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcbiAgICAgICAgICByZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgICAgZXZlbnQudHlwZSA9IGZpeDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH07XG4gIH0gKTtcblxuICBqUXVlcnkuZm4uZXh0ZW5kKCB7XG5cbiAgICBvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG4gICAgICByZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcbiAgICB9LFxuICAgIG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG4gICAgICByZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcbiAgICB9LFxuICAgIG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG4gICAgICB2YXIgaGFuZGxlT2JqLCB0eXBlO1xuICAgICAgaWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cbiAgICAgICAgLy8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuICAgICAgICBoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG4gICAgICAgIGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG4gICAgICAgICAgaGFuZGxlT2JqLm5hbWVzcGFjZSA/XG4gICAgICAgICAgICBoYW5kbGVPYmoub3JpZ1R5cGUgKyAnLicgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDpcbiAgICAgICAgICAgIGhhbmRsZU9iai5vcmlnVHlwZSxcbiAgICAgICAgICBoYW5kbGVPYmouc2VsZWN0b3IsXG4gICAgICAgICAgaGFuZGxlT2JqLmhhbmRsZXJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAoIHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcgKSB7XG5cbiAgICAgICAgLy8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcbiAgICAgICAgZm9yICggdHlwZSBpbiB0eXBlcyApIHtcbiAgICAgICAgICB0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJyApIHtcblxuICAgICAgICAvLyAoIHR5cGVzIFssIGZuXSApXG4gICAgICAgIGZuID0gc2VsZWN0b3I7XG4gICAgICAgIHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKCBmbiA9PT0gZmFsc2UgKSB7XG4gICAgICAgIGZuID0gcmV0dXJuRmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcbiAgICAgICAgalF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuICAgICAgfSApO1xuICAgIH1cbiAgfSApO1xuXG5cbiAgdmFyXG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzMyMjlcbiAgICByeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopW14+XSopXFwvPi9naSxcblxuICAgIC8qIGVzbGludC1lbmFibGUgKi9cblxuICAgIC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSwgRWRnZSAxMiAtIDEzIG9ubHlcbiAgICAvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuICAgIC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG4gICAgcm5vSW5uZXJodG1sID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksXG5cbiAgICAvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcbiAgICByY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG4gICAgcmNsZWFuU2NyaXB0ID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nO1xuXG4gIC8vIFByZWZlciBhIHRib2R5IG92ZXIgaXRzIHBhcmVudCB0YWJsZSBmb3IgY29udGFpbmluZyBuZXcgcm93c1xuICBmdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG4gICAgaWYgKCBub2RlTmFtZSggZWxlbSwgJ3RhYmxlJyApICYmXG5cdFx0bm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgJ3RyJyApICkge1xuXG4gICAgICByZXR1cm4galF1ZXJ5KCBlbGVtICkuY2hpbGRyZW4oICd0Ym9keScgKVsgMCBdIHx8IGVsZW07XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW07XG4gIH1cblxuICAvLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG4gIGZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG4gICAgZWxlbS50eXBlID0gKCBlbGVtLmdldEF0dHJpYnV0ZSggJ3R5cGUnICkgIT09IG51bGwgKSArICcvJyArIGVsZW0udHlwZTtcbiAgICByZXR1cm4gZWxlbTtcbiAgfVxuICBmdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuICAgIGlmICggKCBlbGVtLnR5cGUgfHwgJycgKS5zbGljZSggMCwgNSApID09PSAndHJ1ZS8nICkge1xuICAgICAgZWxlbS50eXBlID0gZWxlbS50eXBlLnNsaWNlKCA1ICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKCAndHlwZScgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG4gICAgdmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCBwZGF0YUN1ciwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cbiAgICBpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cbiAgICBpZiAoIGRhdGFQcml2Lmhhc0RhdGEoIHNyYyApICkge1xuICAgICAgcGRhdGFPbGQgPSBkYXRhUHJpdi5hY2Nlc3MoIHNyYyApO1xuICAgICAgcGRhdGFDdXIgPSBkYXRhUHJpdi5zZXQoIGRlc3QsIHBkYXRhT2xkICk7XG4gICAgICBldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XG5cbiAgICAgIGlmICggZXZlbnRzICkge1xuICAgICAgICBkZWxldGUgcGRhdGFDdXIuaGFuZGxlO1xuICAgICAgICBwZGF0YUN1ci5ldmVudHMgPSB7fTtcblxuICAgICAgICBmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcbiAgICAgICAgICBmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcbiAgICAgICAgICAgIGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAyLiBDb3B5IHVzZXIgZGF0YVxuICAgIGlmICggZGF0YVVzZXIuaGFzRGF0YSggc3JjICkgKSB7XG4gICAgICB1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG4gICAgICB1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG4gICAgICBkYXRhVXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XG4gICAgfVxuICB9XG5cbiAgLy8gRml4IElFIGJ1Z3MsIHNlZSBzdXBwb3J0IHRlc3RzXG4gIGZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG4gICAgdmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXG4gICAgaWYgKCBub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xuICAgICAgZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cbiAgICAgIC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG4gICAgfSBlbHNlIGlmICggbm9kZU5hbWUgPT09ICdpbnB1dCcgfHwgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYScgKSB7XG4gICAgICBkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZG9tTWFuaXAoIGNvbGxlY3Rpb24sIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICkge1xuXG4gICAgLy8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuICAgIGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cbiAgICB2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG4gICAgICBpID0gMCxcbiAgICAgIGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgIGlOb0Nsb25lID0gbCAtIDEsXG4gICAgICB2YWx1ZSA9IGFyZ3NbIDAgXSxcbiAgICAgIHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIHZhbHVlICk7XG5cbiAgICAvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcbiAgICBpZiAoIHZhbHVlSXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG5cdFx0XHRcdCFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuICAgICAgICB2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG4gICAgICAgIGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuICAgICAgICAgIGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuICAgICAgICB9XG4gICAgICAgIGRvbU1hbmlwKCBzZWxmLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApO1xuICAgICAgfSApO1xuICAgIH1cblxuICAgIGlmICggbCApIHtcbiAgICAgIGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG4gICAgICBmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cbiAgICAgIGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XG4gICAgICAgIGZyYWdtZW50ID0gZmlyc3Q7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlcXVpcmUgZWl0aGVyIG5ldyBjb250ZW50IG9yIGFuIGludGVyZXN0IGluIGlnbm9yZWQgZWxlbWVudHMgdG8gaW52b2tlIHRoZSBjYWxsYmFja1xuICAgICAgaWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuICAgICAgICBzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgJ3NjcmlwdCcgKSwgZGlzYWJsZVNjcmlwdCApO1xuICAgICAgICBoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cbiAgICAgICAgLy8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbVxuICAgICAgICAvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcbiAgICAgICAgLy8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cbiAgICAgICAgZm9yICggOyBpIDwgbDsgaSsrICkge1xuICAgICAgICAgIG5vZGUgPSBmcmFnbWVudDtcblxuICAgICAgICAgIGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG4gICAgICAgICAgICBub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cbiAgICAgICAgICAgIC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cbiAgICAgICAgICAgIGlmICggaGFzU2NyaXB0cyApIHtcblxuICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcbiAgICAgICAgICAgICAgLy8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuICAgICAgICAgICAgICBqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgJ3NjcmlwdCcgKSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBoYXNTY3JpcHRzICkge1xuICAgICAgICAgIGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cbiAgICAgICAgICAvLyBSZWVuYWJsZSBzY3JpcHRzXG4gICAgICAgICAgalF1ZXJ5Lm1hcCggc2NyaXB0cywgcmVzdG9yZVNjcmlwdCApO1xuXG4gICAgICAgICAgLy8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkge1xuICAgICAgICAgICAgbm9kZSA9IHNjcmlwdHNbIGkgXTtcbiAgICAgICAgICAgIGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8ICcnICkgJiZcblx0XHRcdFx0XHRcdCFkYXRhUHJpdi5hY2Nlc3MoIG5vZGUsICdnbG9iYWxFdmFsJyApICYmXG5cdFx0XHRcdFx0XHRqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG4gICAgICAgICAgICAgIGlmICggbm9kZS5zcmMgJiYgKCBub2RlLnR5cGUgfHwgJycgKS50b0xvd2VyQ2FzZSgpICE9PSAnbW9kdWxlJyApIHtcblxuICAgICAgICAgICAgICAgIC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XG4gICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkuX2V2YWxVcmwgKSB7XG4gICAgICAgICAgICAgICAgICBqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIERPTUV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCAnJyApLCBkb2MsIG5vZGUgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlKCBlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEgKSB7XG4gICAgdmFyIG5vZGUsXG4gICAgICBub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXG4gICAgICBpID0gMDtcblxuICAgIGZvciAoIDsgKCBub2RlID0gbm9kZXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcbiAgICAgIGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG4gICAgICAgIGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggbm9kZSApICk7XG4gICAgICB9XG5cbiAgICAgIGlmICggbm9kZS5wYXJlbnROb2RlICkge1xuICAgICAgICBpZiAoIGtlZXBEYXRhICYmIGpRdWVyeS5jb250YWlucyggbm9kZS5vd25lckRvY3VtZW50LCBub2RlICkgKSB7XG4gICAgICAgICAgc2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBub2RlLCAnc2NyaXB0JyApICk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW07XG4gIH1cblxuICBqUXVlcnkuZXh0ZW5kKCB7XG4gICAgaHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG4gICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKCByeGh0bWxUYWcsICc8JDE+PC8kMj4nICk7XG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG4gICAgICB2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcbiAgICAgICAgY2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxuICAgICAgICBpblBhZ2UgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG4gICAgICAvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcbiAgICAgIGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcblx0XHRcdFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG4gICAgICAgIC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cHM6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxuICAgICAgICBkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG4gICAgICAgIHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cbiAgICAgICAgZm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG4gICAgICAgICAgZml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuICAgICAgaWYgKCBkYXRhQW5kRXZlbnRzICkge1xuICAgICAgICBpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuICAgICAgICAgIHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG4gICAgICAgICAgZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuICAgICAgICAgIGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuICAgICAgICAgICAgY2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3RvcnlcbiAgICAgIGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsICdzY3JpcHQnICk7XG4gICAgICBpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuICAgICAgICBzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCAnc2NyaXB0JyApICk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH0sXG5cbiAgICBjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgICAgIHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG4gICAgICAgIGkgPSAwO1xuXG4gICAgICBmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG4gICAgICAgIGlmICggYWNjZXB0RGF0YSggZWxlbSApICkge1xuICAgICAgICAgIGlmICggKCBkYXRhID0gZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdICkgKSB7XG4gICAgICAgICAgICBpZiAoIGRhdGEuZXZlbnRzICkge1xuICAgICAgICAgICAgICBmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuICAgICAgICAgICAgICAgIGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG4gICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcbiAgICAgICAgICAgIC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuICAgICAgICAgICAgZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSApIHtcblxuICAgICAgICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcbiAgICAgICAgICAgIC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuICAgICAgICAgICAgZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSApO1xuXG4gIGpRdWVyeS5mbi5leHRlbmQoIHtcbiAgICBkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcbiAgICAgIHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuICAgICAgcmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcbiAgICB9LFxuXG4gICAgdGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xuICAgICAgcmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgalF1ZXJ5LnRleHQoIHRoaXMgKSA6XG4gICAgICAgICAgdGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG4gICAgICAgICAgICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9ICk7XG4gICAgICB9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuICAgIH0sXG5cbiAgICBhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICBpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcbiAgICAgICAgICB2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG4gICAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XG4gICAgICAgIH1cbiAgICAgIH0gKTtcbiAgICB9LFxuXG4gICAgcHJlcGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgIGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuICAgICAgICAgIHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcbiAgICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuICAgICAgICB9XG4gICAgICB9ICk7XG4gICAgfSxcblxuICAgIGJlZm9yZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgIGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcbiAgICAgICAgfVxuICAgICAgfSApO1xuICAgIH0sXG5cbiAgICBhZnRlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgIGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcbiAgICAgICAgfVxuICAgICAgfSApO1xuICAgIH0sXG5cbiAgICBlbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZWxlbSxcbiAgICAgICAgaSA9IDA7XG5cbiAgICAgIGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuICAgICAgICBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cbiAgICAgICAgICAvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuICAgICAgICAgIGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXG4gICAgICAgICAgLy8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcbiAgICAgICAgICBlbGVtLnRleHRDb250ZW50ID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG4gICAgICBkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuICAgICAgZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG4gICAgICByZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xuICAgICAgfSApO1xuICAgIH0sXG5cbiAgICBodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG4gICAgICByZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG4gICAgICAgIHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgIGwgPSB0aGlzLmxlbmd0aDtcblxuICAgICAgICBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcbiAgICAgICAgICByZXR1cm4gZWxlbS5pbm5lckhUTUw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG4gICAgICAgIGlmICggdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbICcnLCAnJyBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG5cbiAgICAgICAgICB2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoIDsgaSA8IGw7IGkrKyApIHtcbiAgICAgICAgICAgICAgZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuICAgICAgICAgICAgICAvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3NcbiAgICAgICAgICAgICAgaWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuICAgICAgICAgICAgICAgIGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxlbSA9IDA7XG5cbiAgICAgICAgICAgIC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuICAgICAgICAgIH0gY2F0Y2ggKCBlICkge31cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZWxlbSApIHtcbiAgICAgICAgICB0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuICAgICAgICB9XG4gICAgICB9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuICAgIH0sXG5cbiAgICByZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaWdub3JlZCA9IFtdO1xuXG4gICAgICAvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcbiAgICAgIHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuICAgICAgICBpZiAoIGpRdWVyeS5pbkFycmF5KCB0aGlzLCBpZ25vcmVkICkgPCAwICkge1xuICAgICAgICAgIGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggdGhpcyApICk7XG4gICAgICAgICAgaWYgKCBwYXJlbnQgKSB7XG4gICAgICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9yY2UgY2FsbGJhY2sgaW52b2NhdGlvblxuICAgICAgfSwgaWdub3JlZCApO1xuICAgIH1cbiAgfSApO1xuXG4gIGpRdWVyeS5lYWNoKCB7XG4gICAgYXBwZW5kVG86ICdhcHBlbmQnLFxuICAgIHByZXBlbmRUbzogJ3ByZXBlbmQnLFxuICAgIGluc2VydEJlZm9yZTogJ2JlZm9yZScsXG4gICAgaW5zZXJ0QWZ0ZXI6ICdhZnRlcicsXG4gICAgcmVwbGFjZUFsbDogJ3JlcGxhY2VXaXRoJ1xuICB9LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG4gICAgalF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG4gICAgICB2YXIgZWxlbXMsXG4gICAgICAgIHJldCA9IFtdLFxuICAgICAgICBpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXG4gICAgICAgIGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcbiAgICAgICAgaSA9IDA7XG5cbiAgICAgIGZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7XG4gICAgICAgIGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG4gICAgICAgIGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcbiAgICAgICAgLy8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuICAgICAgICBwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG4gICAgfTtcbiAgfSApO1xuICB2YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggJ14oJyArIHBudW0gKyAnKSg/IXB4KVthLXolXSskJywgJ2knICk7XG5cbiAgdmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG4gICAgLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5LCBGaXJlZm94IDw9MzAgKCMxNTA5OCwgIzE0MTUwKVxuICAgIC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xuICAgIC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuICAgIHZhciB2aWV3ID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG4gICAgaWYgKCAhdmlldyB8fCAhdmlldy5vcGVuZXIgKSB7XG4gICAgICB2aWV3ID0gd2luZG93O1xuICAgIH1cblxuICAgIHJldHVybiB2aWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcbiAgfTtcblxuICB2YXIgcmJveFN0eWxlID0gbmV3IFJlZ0V4cCggY3NzRXhwYW5kLmpvaW4oICd8JyApLCAnaScgKTtcblxuXG5cbiAgKCBmdW5jdGlvbigpIHtcblxuICAgIC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxuICAgIC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG4gICAgZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG5cbiAgICAgIC8vIFRoaXMgaXMgYSBzaW5nbGV0b24sIHdlIG5lZWQgdG8gZXhlY3V0ZSBpdCBvbmx5IG9uY2VcbiAgICAgIGlmICggIWRpdiApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O3dpZHRoOjYwcHg7JyArXG5cdFx0XHQnbWFyZ2luLXRvcDoxcHg7cGFkZGluZzowO2JvcmRlcjowJztcbiAgICAgIGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdCdwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpzY3JvbGw7JyArXG5cdFx0XHQnbWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDsnICtcblx0XHRcdCd3aWR0aDo2MCU7dG9wOjElJztcbiAgICAgIGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG4gICAgICB2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2ICk7XG4gICAgICBwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSAnMSUnO1xuXG4gICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBGaXJlZm94IDw9MyAtIDQ0XG4gICAgICByZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLm1hcmdpbkxlZnQgKSA9PT0gMTI7XG5cbiAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIFNhZmFyaSA8PTkuMSAtIDEwLjEsIGlPUyA8PTcuMCAtIDkuM1xuICAgICAgLy8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG4gICAgICBkaXYuc3R5bGUucmlnaHQgPSAnNjAlJztcbiAgICAgIHBpeGVsQm94U3R5bGVzVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5yaWdodCApID09PSAzNjtcblxuICAgICAgLy8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcbiAgICAgIC8vIERldGVjdCBtaXNyZXBvcnRpbmcgb2YgY29udGVudCBkaW1lbnNpb25zIGZvciBib3gtc2l6aW5nOmJvcmRlci1ib3ggZWxlbWVudHNcbiAgICAgIGJveFNpemluZ1JlbGlhYmxlVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS53aWR0aCApID09PSAzNjtcblxuICAgICAgLy8gU3VwcG9ydDogSUUgOSBvbmx5XG4gICAgICAvLyBEZXRlY3Qgb3ZlcmZsb3c6c2Nyb2xsIHNjcmV3aW5lc3MgKGdoLTM2OTkpXG4gICAgICBkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgc2Nyb2xsYm94U2l6ZVZhbCA9IGRpdi5vZmZzZXRXaWR0aCA9PT0gMzYgfHwgJ2Fic29sdXRlJztcblxuICAgICAgZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuICAgICAgLy8gTnVsbGlmeSB0aGUgZGl2IHNvIGl0IHdvdWxkbid0IGJlIHN0b3JlZCBpbiB0aGUgbWVtb3J5IGFuZFxuICAgICAgLy8gaXQgd2lsbCBhbHNvIGJlIGEgc2lnbiB0aGF0IGNoZWNrcyBhbHJlYWR5IHBlcmZvcm1lZFxuICAgICAgZGl2ID0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByb3VuZFBpeGVsTWVhc3VyZXMoIG1lYXN1cmUgKSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCggcGFyc2VGbG9hdCggbWVhc3VyZSApICk7XG4gICAgfVxuXG4gICAgdmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLCBzY3JvbGxib3hTaXplVmFsLCBwaXhlbEJveFN0eWxlc1ZhbCxcbiAgICAgIHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcbiAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICksXG4gICAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuXG4gICAgLy8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcbiAgICBpZiAoICFkaXYuc3R5bGUgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuICAgIC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcbiAgICBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSAnY29udGVudC1ib3gnO1xuICAgIGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9ICcnO1xuICAgIHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSAnY29udGVudC1ib3gnO1xuXG4gICAgalF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuICAgICAgYm94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb21wdXRlU3R5bGVUZXN0cygpO1xuICAgICAgICByZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XG4gICAgICB9LFxuICAgICAgcGl4ZWxCb3hTdHlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb21wdXRlU3R5bGVUZXN0cygpO1xuICAgICAgICByZXR1cm4gcGl4ZWxCb3hTdHlsZXNWYWw7XG4gICAgICB9LFxuICAgICAgcGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbXB1dGVTdHlsZVRlc3RzKCk7XG4gICAgICAgIHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuICAgICAgfSxcbiAgICAgIHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbXB1dGVTdHlsZVRlc3RzKCk7XG4gICAgICAgIHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG4gICAgICB9LFxuICAgICAgc2Nyb2xsYm94U2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbXB1dGVTdHlsZVRlc3RzKCk7XG4gICAgICAgIHJldHVybiBzY3JvbGxib3hTaXplVmFsO1xuICAgICAgfVxuICAgIH0gKTtcbiAgfSApKCk7XG5cblxuICBmdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuICAgIHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXG5cbiAgICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3ggNTErXG4gICAgICAvLyBSZXRyaWV2aW5nIHN0eWxlIGJlZm9yZSBjb21wdXRlZCBzb21laG93XG4gICAgICAvLyBmaXhlcyBhbiBpc3N1ZSB3aXRoIGdldHRpbmcgd3JvbmcgdmFsdWVzXG4gICAgICAvLyBvbiBkZXRhY2hlZCBlbGVtZW50c1xuICAgICAgc3R5bGUgPSBlbGVtLnN0eWxlO1xuXG4gICAgY29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcblxuICAgIC8vIGdldFByb3BlcnR5VmFsdWUgaXMgbmVlZGVkIGZvcjpcbiAgICAvLyAgIC5jc3MoJ2ZpbHRlcicpIChJRSA5IG9ubHksICMxMjUzNylcbiAgICAvLyAgIC5jc3MoJy0tY3VzdG9tUHJvcGVydHkpICgjMzE0NClcbiAgICBpZiAoIGNvbXB1dGVkICkge1xuICAgICAgcmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cbiAgICAgIGlmICggcmV0ID09PSAnJyAmJiAhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSApIHtcbiAgICAgICAgcmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG4gICAgICB9XG5cbiAgICAgIC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcbiAgICAgIC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxuICAgICAgLy8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cbiAgICAgIC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcbiAgICAgIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG4gICAgICBpZiAoICFzdXBwb3J0LnBpeGVsQm94U3R5bGVzKCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJib3hTdHlsZS50ZXN0KCBuYW1lICkgKSB7XG5cbiAgICAgICAgLy8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuICAgICAgICB3aWR0aCA9IHN0eWxlLndpZHRoO1xuICAgICAgICBtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuICAgICAgICBtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG4gICAgICAgIC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcbiAgICAgICAgc3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuICAgICAgICByZXQgPSBjb21wdXRlZC53aWR0aDtcblxuICAgICAgICAvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG4gICAgICAgIHN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG4gICAgICAgIHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuICAgIC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcbiAgICAvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuICAgICAgcmV0ICsgJycgOlxuICAgICAgcmV0O1xuICB9XG5cblxuICBmdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cbiAgICAvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuICAgIHJldHVybiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIGNvbmRpdGlvbkZuKCkgKSB7XG5cbiAgICAgICAgICAvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcbiAgICAgICAgICAvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG4gICAgICAgICAgZGVsZXRlIHRoaXMuZ2V0O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxuICAgICAgICByZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cblxuICB2YXJcblxuICAgIC8vIFN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGVcbiAgICAvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcbiAgICAvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcbiAgICByZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG4gICAgcmN1c3RvbVByb3AgPSAvXi0tLyxcbiAgICBjc3NTaG93ID0geyBwb3NpdGlvbjogJ2Fic29sdXRlJywgdmlzaWJpbGl0eTogJ2hpZGRlbicsIGRpc3BsYXk6ICdibG9jaycgfSxcbiAgICBjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG4gICAgICBsZXR0ZXJTcGFjaW5nOiAnMCcsXG4gICAgICBmb250V2VpZ2h0OiAnNDAwJ1xuICAgIH0sXG5cbiAgICBjc3NQcmVmaXhlcyA9IFsgJ1dlYmtpdCcsICdNb3onLCAnbXMnIF0sXG4gICAgZW1wdHlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICkuc3R5bGU7XG5cbiAgLy8gUmV0dXJuIGEgY3NzIHByb3BlcnR5IG1hcHBlZCB0byBhIHBvdGVudGlhbGx5IHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuICBmdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuICAgIC8vIFNob3J0Y3V0IGZvciBuYW1lcyB0aGF0IGFyZSBub3QgdmVuZG9yIHByZWZpeGVkXG4gICAgaWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG4gICAgdmFyIGNhcE5hbWUgPSBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSxcbiAgICAgIGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgIG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcbiAgICAgIGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm4gYSBwcm9wZXJ0eSBtYXBwZWQgYWxvbmcgd2hhdCBqUXVlcnkuY3NzUHJvcHMgc3VnZ2VzdHMgb3IgdG9cbiAgLy8gYSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHkuXG4gIGZ1bmN0aW9uIGZpbmFsUHJvcE5hbWUoIG5hbWUgKSB7XG4gICAgdmFyIHJldCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdO1xuICAgIGlmICggIXJldCApIHtcbiAgICAgIHJldCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB8fCBuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcblxuICAgIC8vIEFueSByZWxhdGl2ZSAoKy8tKSB2YWx1ZXMgaGF2ZSBhbHJlYWR5IGJlZW5cbiAgICAvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcbiAgICB2YXIgbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKTtcbiAgICByZXR1cm4gbWF0Y2hlcyA/XG5cbiAgICAvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuICAgICAgTWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCAncHgnICkgOlxuICAgICAgdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgYm94LCBpc0JvcmRlckJveCwgc3R5bGVzLCBjb21wdXRlZFZhbCApIHtcbiAgICB2YXIgaSA9IGRpbWVuc2lvbiA9PT0gJ3dpZHRoJyA/IDEgOiAwLFxuICAgICAgZXh0cmEgPSAwLFxuICAgICAgZGVsdGEgPSAwO1xuXG4gICAgLy8gQWRqdXN0bWVudCBtYXkgbm90IGJlIG5lY2Vzc2FyeVxuICAgIGlmICggYm94ID09PSAoIGlzQm9yZGVyQm94ID8gJ2JvcmRlcicgOiAnY29udGVudCcgKSApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcblxuICAgICAgLy8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luXG4gICAgICBpZiAoIGJveCA9PT0gJ21hcmdpbicgKSB7XG4gICAgICAgIGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIGJveCArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUgd2l0aCBhIGNvbnRlbnQtYm94LCB3ZSdyZSBzZWVraW5nIFwicGFkZGluZ1wiIG9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIlxuICAgICAgaWYgKCAhaXNCb3JkZXJCb3ggKSB7XG5cbiAgICAgICAgLy8gQWRkIHBhZGRpbmdcbiAgICAgICAgZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgJ3BhZGRpbmcnICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG4gICAgICAgIC8vIEZvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCIsIGFkZCBib3JkZXJcbiAgICAgICAgaWYgKCBib3ggIT09ICdwYWRkaW5nJyApIHtcbiAgICAgICAgICBkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCAnYm9yZGVyJyArIGNzc0V4cGFuZFsgaSBdICsgJ1dpZHRoJywgdHJ1ZSwgc3R5bGVzICk7XG5cbiAgICAgICAgICAvLyBCdXQgc3RpbGwga2VlcCB0cmFjayBvZiBpdCBvdGhlcndpc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHRyYSArPSBqUXVlcnkuY3NzKCBlbGVtLCAnYm9yZGVyJyArIGNzc0V4cGFuZFsgaSBdICsgJ1dpZHRoJywgdHJ1ZSwgc3R5bGVzICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgYm9yZGVyLWJveCAoY29udGVudCArIHBhZGRpbmcgKyBib3JkZXIpLCB3ZSdyZSBzZWVraW5nIFwiY29udGVudFwiIG9yXG4gICAgICAgIC8vIFwicGFkZGluZ1wiIG9yIFwibWFyZ2luXCJcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gRm9yIFwiY29udGVudFwiLCBzdWJ0cmFjdCBwYWRkaW5nXG4gICAgICAgIGlmICggYm94ID09PSAnY29udGVudCcgKSB7XG4gICAgICAgICAgZGVsdGEgLT0galF1ZXJ5LmNzcyggZWxlbSwgJ3BhZGRpbmcnICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9yIFwiY29udGVudFwiIG9yIFwicGFkZGluZ1wiLCBzdWJ0cmFjdCBib3JkZXJcbiAgICAgICAgaWYgKCBib3ggIT09ICdtYXJnaW4nICkge1xuICAgICAgICAgIGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sICdib3JkZXInICsgY3NzRXhwYW5kWyBpIF0gKyAnV2lkdGgnLCB0cnVlLCBzdHlsZXMgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFjY291bnQgZm9yIHBvc2l0aXZlIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXIgd2hlbiByZXF1ZXN0ZWQgYnkgcHJvdmlkaW5nIGNvbXB1dGVkVmFsXG4gICAgaWYgKCAhaXNCb3JkZXJCb3ggJiYgY29tcHV0ZWRWYWwgPj0gMCApIHtcblxuICAgICAgLy8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGlzIGEgcm91bmRlZCBzdW0gb2YgY29udGVudCwgcGFkZGluZywgc2Nyb2xsIGd1dHRlciwgYW5kIGJvcmRlclxuICAgICAgLy8gQXNzdW1pbmcgaW50ZWdlciBzY3JvbGwgZ3V0dGVyLCBzdWJ0cmFjdCB0aGUgcmVzdCBhbmQgcm91bmQgZG93blxuICAgICAgZGVsdGEgKz0gTWF0aC5tYXgoIDAsIE1hdGguY2VpbChcbiAgICAgICAgZWxlbVsgJ29mZnNldCcgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRjb21wdXRlZFZhbCAtXG5cdFx0XHRkZWx0YSAtXG5cdFx0XHRleHRyYSAtXG5cdFx0XHQwLjVcbiAgICAgICkgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVsdGE7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICkge1xuXG4gICAgLy8gU3RhcnQgd2l0aCBjb21wdXRlZCBzdHlsZVxuICAgIHZhciBzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcbiAgICAgIHZhbCA9IGN1ckNTUyggZWxlbSwgZGltZW5zaW9uLCBzdHlsZXMgKSxcbiAgICAgIGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgJ2JveFNpemluZycsIGZhbHNlLCBzdHlsZXMgKSA9PT0gJ2JvcmRlci1ib3gnLFxuICAgICAgdmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94O1xuXG4gICAgLy8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG4gICAgLy8gUmV0dXJuIGEgY29uZm91bmRpbmcgbm9uLXBpeGVsIHZhbHVlIG9yIGZlaWduIGlnbm9yYW5jZSwgYXMgYXBwcm9wcmlhdGUuXG4gICAgaWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG4gICAgICBpZiAoICFleHRyYSApIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH1cbiAgICAgIHZhbCA9ICdhdXRvJztcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3Igc3R5bGUgaW4gY2FzZSBhIGJyb3dzZXIgd2hpY2ggcmV0dXJucyB1bnJlbGlhYmxlIHZhbHVlc1xuICAgIC8vIGZvciBnZXRDb21wdXRlZFN0eWxlIHNpbGVudGx5IGZhbGxzIGJhY2sgdG8gdGhlIHJlbGlhYmxlIGVsZW0uc3R5bGVcbiAgICB2YWx1ZUlzQm9yZGVyQm94ID0gdmFsdWVJc0JvcmRlckJveCAmJlxuXHRcdCggc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IHZhbCA9PT0gZWxlbS5zdHlsZVsgZGltZW5zaW9uIF0gKTtcblxuICAgIC8vIEZhbGwgYmFjayB0byBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgd2hlbiB2YWx1ZSBpcyBcImF1dG9cIlxuICAgIC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcbiAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIC0gNC4zIG9ubHlcbiAgICAvLyBBbHNvIHVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIG1pc3JlcG9ydGVkIGlubGluZSBkaW1lbnNpb25zIChnaC0zNjAyKVxuICAgIGlmICggdmFsID09PSAnYXV0bycgfHxcblx0XHQhcGFyc2VGbG9hdCggdmFsICkgJiYgalF1ZXJ5LmNzcyggZWxlbSwgJ2Rpc3BsYXknLCBmYWxzZSwgc3R5bGVzICkgPT09ICdpbmxpbmUnICkge1xuXG4gICAgICB2YWwgPSBlbGVtWyAnb2Zmc2V0JyArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdO1xuXG4gICAgICAvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgcHJvdmlkZSBib3JkZXItYm94IHZhbHVlc1xuICAgICAgdmFsdWVJc0JvcmRlckJveCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gTm9ybWFsaXplIFwiXCIgYW5kIGF1dG9cbiAgICB2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXG4gICAgLy8gQWRqdXN0IGZvciB0aGUgZWxlbWVudCdzIGJveCBtb2RlbFxuICAgIHJldHVybiAoIHZhbCArXG5cdFx0Ym94TW9kZWxBZGp1c3RtZW50KFxuXHRcdCAgZWxlbSxcblx0XHQgIGRpbWVuc2lvbixcblx0XHQgIGV4dHJhIHx8ICggaXNCb3JkZXJCb3ggPyAnYm9yZGVyJyA6ICdjb250ZW50JyApLFxuXHRcdCAgdmFsdWVJc0JvcmRlckJveCxcblx0XHQgIHN0eWxlcyxcblxuXHRcdCAgLy8gUHJvdmlkZSB0aGUgY3VycmVudCBjb21wdXRlZCBzaXplIHRvIHJlcXVlc3Qgc2Nyb2xsIGd1dHRlciBjYWxjdWxhdGlvbiAoZ2gtMzU4OSlcblx0XHQgIHZhbFxuXHRcdClcbiAgICApICsgJ3B4JztcbiAgfVxuXG4gIGpRdWVyeS5leHRlbmQoIHtcblxuICAgIC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuICAgIC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuICAgIGNzc0hvb2tzOiB7XG4gICAgICBvcGFjaXR5OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuICAgICAgICAgIGlmICggY29tcHV0ZWQgKSB7XG5cbiAgICAgICAgICAgIC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG4gICAgICAgICAgICB2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCAnb3BhY2l0eScgKTtcbiAgICAgICAgICAgIHJldHVybiByZXQgPT09ICcnID8gJzEnIDogcmV0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuICAgIGNzc051bWJlcjoge1xuICAgICAgJ2FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50JzogdHJ1ZSxcbiAgICAgICdjb2x1bW5Db3VudCc6IHRydWUsXG4gICAgICAnZmlsbE9wYWNpdHknOiB0cnVlLFxuICAgICAgJ2ZsZXhHcm93JzogdHJ1ZSxcbiAgICAgICdmbGV4U2hyaW5rJzogdHJ1ZSxcbiAgICAgICdmb250V2VpZ2h0JzogdHJ1ZSxcbiAgICAgICdsaW5lSGVpZ2h0JzogdHJ1ZSxcbiAgICAgICdvcGFjaXR5JzogdHJ1ZSxcbiAgICAgICdvcmRlcic6IHRydWUsXG4gICAgICAnb3JwaGFucyc6IHRydWUsXG4gICAgICAnd2lkb3dzJzogdHJ1ZSxcbiAgICAgICd6SW5kZXgnOiB0cnVlLFxuICAgICAgJ3pvb20nOiB0cnVlXG4gICAgfSxcblxuICAgIC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcbiAgICAvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG4gICAgY3NzUHJvcHM6IHt9LFxuXG4gICAgLy8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcbiAgICBzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuICAgICAgLy8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG4gICAgICBpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcbiAgICAgIHZhciByZXQsIHR5cGUsIGhvb2tzLFxuICAgICAgICBvcmlnTmFtZSA9IGNhbWVsQ2FzZSggbmFtZSApLFxuICAgICAgICBpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG4gICAgICAgIHN0eWxlID0gZWxlbS5zdHlsZTtcblxuICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuICAgICAgLy8gd2FudCB0byBxdWVyeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG4gICAgICAvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG4gICAgICBpZiAoICFpc0N1c3RvbVByb3AgKSB7XG4gICAgICAgIG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxuICAgICAgaG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cbiAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuICAgICAgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gICAgICAgIC8vIENvbnZlcnQgXCIrPVwiIG9yIFwiLT1cIiB0byByZWxhdGl2ZSBudW1iZXJzICgjNzM0NSlcbiAgICAgICAgaWYgKCB0eXBlID09PSAnc3RyaW5nJyAmJiAoIHJldCA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmIHJldFsgMSBdICkge1xuICAgICAgICAgIHZhbHVlID0gYWRqdXN0Q1NTKCBlbGVtLCBuYW1lLCByZXQgKTtcblxuICAgICAgICAgIC8vIEZpeGVzIGJ1ZyAjOTIzN1xuICAgICAgICAgIHR5cGUgPSAnbnVtYmVyJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAoIzcxMTYpXG4gICAgICAgIGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG4gICAgICAgIGlmICggdHlwZSA9PT0gJ251bWJlcicgKSB7XG4gICAgICAgICAgdmFsdWUgKz0gcmV0ICYmIHJldFsgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgb3JpZ05hbWUgXSA/ICcnIDogJ3B4JyApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmFja2dyb3VuZC0qIHByb3BzIGFmZmVjdCBvcmlnaW5hbCBjbG9uZSdzIHZhbHVlc1xuICAgICAgICBpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gJycgJiYgbmFtZS5pbmRleE9mKCAnYmFja2dyb3VuZCcgKSA9PT0gMCApIHtcbiAgICAgICAgICBzdHlsZVsgbmFtZSBdID0gJ2luaGVyaXQnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG4gICAgICAgIGlmICggIWhvb2tzIHx8ICEoICdzZXQnIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgaWYgKCBpc0N1c3RvbVByb3AgKSB7XG4gICAgICAgICAgICBzdHlsZS5zZXRQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuICAgICAgICBpZiAoIGhvb2tzICYmICdnZXQnIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3RcbiAgICAgICAgcmV0dXJuIHN0eWxlWyBuYW1lIF07XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG4gICAgICB2YXIgdmFsLCBudW0sIGhvb2tzLFxuICAgICAgICBvcmlnTmFtZSA9IGNhbWVsQ2FzZSggbmFtZSApLFxuICAgICAgICBpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICk7XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3RcbiAgICAgIC8vIHdhbnQgdG8gbW9kaWZ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcbiAgICAgIC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cbiAgICAgIGlmICggIWlzQ3VzdG9tUHJvcCApIHtcbiAgICAgICAgbmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcbiAgICAgIGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG4gICAgICAvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuICAgICAgaWYgKCBob29rcyAmJiAnZ2V0JyBpbiBob29rcyApIHtcbiAgICAgICAgdmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuICAgICAgfVxuXG4gICAgICAvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuICAgICAgaWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgdmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG4gICAgICBpZiAoIHZhbCA9PT0gJ25vcm1hbCcgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG4gICAgICAgIHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xuICAgICAgfVxuXG4gICAgICAvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcbiAgICAgIGlmICggZXh0cmEgPT09ICcnIHx8IGV4dHJhICkge1xuICAgICAgICBudW0gPSBwYXJzZUZsb2F0KCB2YWwgKTtcbiAgICAgICAgcmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfSApO1xuXG4gIGpRdWVyeS5lYWNoKCBbICdoZWlnaHQnLCAnd2lkdGgnIF0sIGZ1bmN0aW9uKCBpLCBkaW1lbnNpb24gKSB7XG4gICAgalF1ZXJ5LmNzc0hvb2tzWyBkaW1lbnNpb24gXSA9IHtcbiAgICAgIGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcbiAgICAgICAgaWYgKCBjb21wdXRlZCApIHtcblxuICAgICAgICAgIC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuICAgICAgICAgIC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XG4gICAgICAgICAgcmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCAnZGlzcGxheScgKSApICYmXG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCtcblx0XHRcdFx0XHQvLyBUYWJsZSBjb2x1bW5zIGluIFNhZmFyaSBoYXZlIG5vbi16ZXJvIG9mZnNldFdpZHRoICYgemVyb1xuXHRcdFx0XHRcdC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHVubGVzcyBkaXNwbGF5IGlzIGNoYW5nZWQuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0XHRcdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuXHRcdFx0XHRcdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cblx0XHRcdFx0XHQoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoIHx8ICFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICkgP1xuICAgICAgICAgICAgc3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG4gICAgICAgICAgICB9ICkgOlxuICAgICAgICAgICAgZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG4gICAgICAgIHZhciBtYXRjaGVzLFxuICAgICAgICAgIHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuICAgICAgICAgIGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgJ2JveFNpemluZycsIGZhbHNlLCBzdHlsZXMgKSA9PT0gJ2JvcmRlci1ib3gnLFxuICAgICAgICAgIHN1YnRyYWN0ID0gZXh0cmEgJiYgYm94TW9kZWxBZGp1c3RtZW50KFxuICAgICAgICAgICAgZWxlbSxcbiAgICAgICAgICAgIGRpbWVuc2lvbixcbiAgICAgICAgICAgIGV4dHJhLFxuICAgICAgICAgICAgaXNCb3JkZXJCb3gsXG4gICAgICAgICAgICBzdHlsZXNcbiAgICAgICAgICApO1xuXG4gICAgICAgIC8vIEFjY291bnQgZm9yIHVucmVsaWFibGUgYm9yZGVyLWJveCBkaW1lbnNpb25zIGJ5IGNvbXBhcmluZyBvZmZzZXQqIHRvIGNvbXB1dGVkIGFuZFxuICAgICAgICAvLyBmYWtpbmcgYSBjb250ZW50LWJveCB0byBnZXQgYm9yZGVyIGFuZCBwYWRkaW5nIChnaC0zNjk5KVxuICAgICAgICBpZiAoIGlzQm9yZGVyQm94ICYmIHN1cHBvcnQuc2Nyb2xsYm94U2l6ZSgpID09PSBzdHlsZXMucG9zaXRpb24gKSB7XG4gICAgICAgICAgc3VidHJhY3QgLT0gTWF0aC5jZWlsKFxuICAgICAgICAgICAgZWxlbVsgJ29mZnNldCcgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRcdFx0cGFyc2VGbG9hdCggc3R5bGVzWyBkaW1lbnNpb24gXSApIC1cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgJ2JvcmRlcicsIGZhbHNlLCBzdHlsZXMgKSAtXG5cdFx0XHRcdFx0MC41XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIHZhbHVlIGFkanVzdG1lbnQgaXMgbmVlZGVkXG4gICAgICAgIGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcblx0XHRcdFx0KCBtYXRjaGVzWyAzIF0gfHwgJ3B4JyApICE9PSAncHgnICkge1xuXG4gICAgICAgICAgZWxlbS5zdHlsZVsgZGltZW5zaW9uIF0gPSB2YWx1ZTtcbiAgICAgICAgICB2YWx1ZSA9IGpRdWVyeS5jc3MoIGVsZW0sIGRpbWVuc2lvbiApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKTtcbiAgICAgIH1cbiAgICB9O1xuICB9ICk7XG5cbiAgalF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuICAgIGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcbiAgICAgIGlmICggY29tcHV0ZWQgKSB7XG4gICAgICAgIHJldHVybiAoIHBhcnNlRmxvYXQoIGN1ckNTUyggZWxlbSwgJ21hcmdpbkxlZnQnICkgKSB8fFxuXHRcdFx0XHRlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxuXHRcdFx0XHRcdHN3YXAoIGVsZW0sIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQgIHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG5cdFx0XHRcdFx0fSApXG4gICAgICAgICkgKyAncHgnO1xuICAgICAgfVxuICAgIH1cbiAgKTtcblxuICAvLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG4gIGpRdWVyeS5lYWNoKCB7XG4gICAgbWFyZ2luOiAnJyxcbiAgICBwYWRkaW5nOiAnJyxcbiAgICBib3JkZXI6ICdXaWR0aCdcbiAgfSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuICAgIGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XG4gICAgICBleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgIGV4cGFuZGVkID0ge30sXG5cbiAgICAgICAgICAvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcbiAgICAgICAgICBwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZS5zcGxpdCggJyAnICkgOiBbIHZhbHVlIF07XG5cbiAgICAgICAgZm9yICggOyBpIDwgNDsgaSsrICkge1xuICAgICAgICAgIGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwYW5kZWQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICggcHJlZml4ICE9PSAnbWFyZ2luJyApIHtcbiAgICAgIGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG4gICAgfVxuICB9ICk7XG5cbiAgalF1ZXJ5LmZuLmV4dGVuZCgge1xuICAgIGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuICAgICAgcmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuICAgICAgICB2YXIgc3R5bGVzLCBsZW4sXG4gICAgICAgICAgbWFwID0ge30sXG4gICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KCBuYW1lICkgKSB7XG4gICAgICAgICAgc3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG4gICAgICAgICAgbGVuID0gbmFtZS5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgICAgIG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgIGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG4gICAgICAgICAgalF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuICAgICAgfSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG4gICAgfVxuICB9ICk7XG5cblxuICBmdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG4gICAgcmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcbiAgfVxuICBqUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuICBUd2Vlbi5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IFR3ZWVuLFxuICAgIGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcbiAgICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgICB0aGlzLnByb3AgPSBwcm9wO1xuICAgICAgdGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICB0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gJycgOiAncHgnICk7XG4gICAgfSxcbiAgICBjdXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuICAgICAgcmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG4gICAgICAgIGhvb2tzLmdldCggdGhpcyApIDpcbiAgICAgICAgVHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuICAgIH0sXG4gICAgcnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcbiAgICAgIHZhciBlYXNlZCxcbiAgICAgICAgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG4gICAgICBpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcbiAgICAgICAgdGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG4gICAgICAgICAgcGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcbiAgICAgIH1cbiAgICAgIHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuICAgICAgaWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcbiAgICAgICAgaG9va3Muc2V0KCB0aGlzICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG5cbiAgVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG4gIFR3ZWVuLnByb3BIb29rcyA9IHtcbiAgICBfZGVmYXVsdDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgLy8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcbiAgICAgICAgLy8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cbiAgICAgICAgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICE9PSAxIHx8XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmIHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsICkge1xuICAgICAgICAgIHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgLy8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cbiAgICAgICAgLy8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG4gICAgICAgIC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG4gICAgICAgIHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsICcnICk7XG5cbiAgICAgICAgLy8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG4gICAgICAgIHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gJ2F1dG8nID8gMCA6IHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblxuICAgICAgICAvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cbiAgICAgICAgLy8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuICAgICAgICAvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxuICAgICAgICBpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG4gICAgICAgICAgalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcbiAgICAgICAgfSBlbHNlIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIHR3ZWVuLmVsZW0uc3R5bGVbIGpRdWVyeS5jc3NQcm9wc1sgdHdlZW4ucHJvcCBdIF0gIT0gbnVsbCB8fFxuXHRcdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdICkgKSB7XG4gICAgICAgICAgalF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4gIC8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuICBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG4gICAgc2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG4gICAgICBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlICkge1xuICAgICAgICB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGpRdWVyeS5lYXNpbmcgPSB7XG4gICAgbGluZWFyOiBmdW5jdGlvbiggcCApIHtcbiAgICAgIHJldHVybiBwO1xuICAgIH0sXG4gICAgc3dpbmc6IGZ1bmN0aW9uKCBwICkge1xuICAgICAgcmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcbiAgICB9LFxuICAgIF9kZWZhdWx0OiAnc3dpbmcnXG4gIH07XG5cbiAgalF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbiAgLy8gQmFjayBjb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbiAgalF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcblxuXG5cblxuICB2YXJcbiAgICBmeE5vdywgaW5Qcm9ncmVzcyxcbiAgICByZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcbiAgICBycnVuID0gL3F1ZXVlSG9va3MkLztcblxuICBmdW5jdGlvbiBzY2hlZHVsZSgpIHtcbiAgICBpZiAoIGluUHJvZ3Jlc3MgKSB7XG4gICAgICBpZiAoIGRvY3VtZW50LmhpZGRlbiA9PT0gZmFsc2UgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSApIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggc2NoZWR1bGUgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCBzY2hlZHVsZSwgalF1ZXJ5LmZ4LmludGVydmFsICk7XG4gICAgICB9XG5cbiAgICAgIGpRdWVyeS5meC50aWNrKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuICBmdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcbiAgICB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG4gICAgICBmeE5vdyA9IHVuZGVmaW5lZDtcbiAgICB9ICk7XG4gICAgcmV0dXJuICggZnhOb3cgPSBEYXRlLm5vdygpICk7XG4gIH1cblxuICAvLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuICBmdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuICAgIHZhciB3aGljaCxcbiAgICAgIGkgPSAwLFxuICAgICAgYXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG4gICAgLy8gSWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxuICAgIC8vIG90aGVyd2lzZSBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XG4gICAgaW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG4gICAgZm9yICggOyBpIDwgNDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoICkge1xuICAgICAgd2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcbiAgICAgIGF0dHJzWyAnbWFyZ2luJyArIHdoaWNoIF0gPSBhdHRyc1sgJ3BhZGRpbmcnICsgd2hpY2ggXSA9IHR5cGU7XG4gICAgfVxuXG4gICAgaWYgKCBpbmNsdWRlV2lkdGggKSB7XG4gICAgICBhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuICAgIH1cblxuICAgIHJldHVybiBhdHRycztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuICAgIHZhciB0d2VlbixcbiAgICAgIGNvbGxlY3Rpb24gPSAoIEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCBBbmltYXRpb24udHdlZW5lcnNbICcqJyBdICksXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICBmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuICAgICAgaWYgKCAoIHR3ZWVuID0gY29sbGVjdGlvblsgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIHByb3AsIHZhbHVlICkgKSApIHtcblxuICAgICAgICAvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuICAgICAgICByZXR1cm4gdHdlZW47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlciggZWxlbSwgcHJvcHMsIG9wdHMgKSB7XG4gICAgdmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIGhvb2tzLCBvbGRmaXJlLCBwcm9wVHdlZW4sIHJlc3RvcmVEaXNwbGF5LCBkaXNwbGF5LFxuICAgICAgaXNCb3ggPSAnd2lkdGgnIGluIHByb3BzIHx8ICdoZWlnaHQnIGluIHByb3BzLFxuICAgICAgYW5pbSA9IHRoaXMsXG4gICAgICBvcmlnID0ge30sXG4gICAgICBzdHlsZSA9IGVsZW0uc3R5bGUsXG4gICAgICBoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApLFxuICAgICAgZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sICdmeHNob3cnICk7XG5cbiAgICAvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3NcbiAgICBpZiAoICFvcHRzLnF1ZXVlICkge1xuICAgICAgaG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sICdmeCcgKTtcbiAgICAgIGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcbiAgICAgICAgaG9va3MudW5xdWV1ZWQgPSAwO1xuICAgICAgICBvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcbiAgICAgICAgaG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICggIWhvb2tzLnVucXVldWVkICkge1xuICAgICAgICAgICAgb2xkZmlyZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGhvb2tzLnVucXVldWVkKys7XG5cbiAgICAgIGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBFbnN1cmUgdGhlIGNvbXBsZXRlIGhhbmRsZXIgaXMgY2FsbGVkIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xuICAgICAgICBhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaG9va3MudW5xdWV1ZWQtLTtcbiAgICAgICAgICBpZiAoICFqUXVlcnkucXVldWUoIGVsZW0sICdmeCcgKS5sZW5ndGggKSB7XG4gICAgICAgICAgICBob29rcy5lbXB0eS5maXJlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9ICk7XG4gICAgICB9ICk7XG4gICAgfVxuXG4gICAgLy8gRGV0ZWN0IHNob3cvaGlkZSBhbmltYXRpb25zXG4gICAgZm9yICggcHJvcCBpbiBwcm9wcyApIHtcbiAgICAgIHZhbHVlID0gcHJvcHNbIHByb3AgXTtcbiAgICAgIGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcbiAgICAgICAgZGVsZXRlIHByb3BzWyBwcm9wIF07XG4gICAgICAgIHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gJ3RvZ2dsZSc7XG4gICAgICAgIGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gJ2hpZGUnIDogJ3Nob3cnICkgKSB7XG5cbiAgICAgICAgICAvLyBQcmV0ZW5kIHRvIGJlIGhpZGRlbiBpZiB0aGlzIGlzIGEgXCJzaG93XCIgYW5kXG4gICAgICAgICAgLy8gdGhlcmUgaXMgc3RpbGwgZGF0YSBmcm9tIGEgc3RvcHBlZCBzaG93L2hpZGVcbiAgICAgICAgICBpZiAoIHZhbHVlID09PSAnc2hvdycgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgaGlkZGVuID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gSWdub3JlIGFsbCBvdGhlciBuby1vcCBzaG93L2hpZGUgZGF0YVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBCYWlsIG91dCBpZiB0aGlzIGlzIGEgbm8tb3AgbGlrZSAuaGlkZSgpLmhpZGUoKVxuICAgIHByb3BUd2VlbiA9ICFqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcHMgKTtcbiAgICBpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcbiAgICBpZiAoIGlzQm94ICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cbiAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcbiAgICAgIC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxuICAgICAgLy8gZnJvbSBpZGVudGljYWxseS12YWx1ZWQgb3ZlcmZsb3dYIGFuZCBvdmVyZmxvd1kgYW5kIEVkZ2UganVzdCBtaXJyb3JzXG4gICAgICAvLyB0aGUgb3ZlcmZsb3dYIHZhbHVlIHRoZXJlLlxuICAgICAgb3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cbiAgICAgIC8vIElkZW50aWZ5IGEgZGlzcGxheSB0eXBlLCBwcmVmZXJyaW5nIG9sZCBzaG93L2hpZGUgZGF0YSBvdmVyIHRoZSBDU1MgY2FzY2FkZVxuICAgICAgcmVzdG9yZURpc3BsYXkgPSBkYXRhU2hvdyAmJiBkYXRhU2hvdy5kaXNwbGF5O1xuICAgICAgaWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuICAgICAgICByZXN0b3JlRGlzcGxheSA9IGRhdGFQcml2LmdldCggZWxlbSwgJ2Rpc3BsYXknICk7XG4gICAgICB9XG4gICAgICBkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgJ2Rpc3BsYXknICk7XG4gICAgICBpZiAoIGRpc3BsYXkgPT09ICdub25lJyApIHtcbiAgICAgICAgaWYgKCByZXN0b3JlRGlzcGxheSApIHtcbiAgICAgICAgICBkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAvLyBHZXQgbm9uZW1wdHkgdmFsdWUocykgYnkgdGVtcG9yYXJpbHkgZm9yY2luZyB2aXNpYmlsaXR5XG4gICAgICAgICAgc2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG4gICAgICAgICAgcmVzdG9yZURpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXkgfHwgcmVzdG9yZURpc3BsYXk7XG4gICAgICAgICAgZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sICdkaXNwbGF5JyApO1xuICAgICAgICAgIHNob3dIaWRlKCBbIGVsZW0gXSApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFuaW1hdGUgaW5saW5lIGVsZW1lbnRzIGFzIGlubGluZS1ibG9ja1xuICAgICAgaWYgKCBkaXNwbGF5ID09PSAnaW5saW5lJyB8fCBkaXNwbGF5ID09PSAnaW5saW5lLWJsb2NrJyAmJiByZXN0b3JlRGlzcGxheSAhPSBudWxsICkge1xuICAgICAgICBpZiAoIGpRdWVyeS5jc3MoIGVsZW0sICdmbG9hdCcgKSA9PT0gJ25vbmUnICkge1xuXG4gICAgICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZSBhdCB0aGUgZW5kIG9mIHB1cmUgc2hvdy9oaWRlIGFuaW1hdGlvbnNcbiAgICAgICAgICBpZiAoICFwcm9wVHdlZW4gKSB7XG4gICAgICAgICAgICBhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBzdHlsZS5kaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICBpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG4gICAgICAgICAgICAgIGRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5O1xuICAgICAgICAgICAgICByZXN0b3JlRGlzcGxheSA9IGRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZGlzcGxheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCBvcHRzLm92ZXJmbG93ICkge1xuICAgICAgc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgIGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcbiAgICAgICAgc3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG4gICAgICAgIHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcbiAgICAgICAgc3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xuICAgICAgfSApO1xuICAgIH1cblxuICAgIC8vIEltcGxlbWVudCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuICAgIHByb3BUd2VlbiA9IGZhbHNlO1xuICAgIGZvciAoIHByb3AgaW4gb3JpZyApIHtcblxuICAgICAgLy8gR2VuZXJhbCBzaG93L2hpZGUgc2V0dXAgZm9yIHRoaXMgZWxlbWVudCBhbmltYXRpb25cbiAgICAgIGlmICggIXByb3BUd2VlbiApIHtcbiAgICAgICAgaWYgKCBkYXRhU2hvdyApIHtcbiAgICAgICAgICBpZiAoICdoaWRkZW4nIGluIGRhdGFTaG93ICkge1xuICAgICAgICAgICAgaGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhU2hvdyA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgJ2Z4c2hvdycsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RvcmUgaGlkZGVuL3Zpc2libGUgZm9yIHRvZ2dsZSBzbyBgLnN0b3AoKS50b2dnbGUoKWAgXCJyZXZlcnNlc1wiXG4gICAgICAgIGlmICggdG9nZ2xlICkge1xuICAgICAgICAgIGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxuICAgICAgICBpZiAoIGhpZGRlbiApIHtcbiAgICAgICAgICBzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG4gICAgICAgIGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG4gICAgICAgICAgLy8gVGhlIGZpbmFsIHN0ZXAgb2YgYSBcImhpZGVcIiBhbmltYXRpb24gaXMgYWN0dWFsbHkgaGlkaW5nIHRoZSBlbGVtZW50XG4gICAgICAgICAgaWYgKCAhaGlkZGVuICkge1xuICAgICAgICAgICAgc2hvd0hpZGUoIFsgZWxlbSBdICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFQcml2LnJlbW92ZSggZWxlbSwgJ2Z4c2hvdycgKTtcbiAgICAgICAgICBmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG4gICAgICAgICAgICBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSApO1xuICAgICAgfVxuXG4gICAgICAvLyBQZXItcHJvcGVydHkgc2V0dXBcbiAgICAgIHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuICAgICAgaWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG4gICAgICAgIGRhdGFTaG93WyBwcm9wIF0gPSBwcm9wVHdlZW4uc3RhcnQ7XG4gICAgICAgIGlmICggaGlkZGVuICkge1xuICAgICAgICAgIHByb3BUd2Vlbi5lbmQgPSBwcm9wVHdlZW4uc3RhcnQ7XG4gICAgICAgICAgcHJvcFR3ZWVuLnN0YXJ0ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuICAgIHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cbiAgICAvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3NcbiAgICBmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcbiAgICAgIG5hbWUgPSBjYW1lbENhc2UoIGluZGV4ICk7XG4gICAgICBlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG4gICAgICB2YWx1ZSA9IHByb3BzWyBpbmRleCBdO1xuICAgICAgaWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuICAgICAgICBlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuICAgICAgICB2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCBpbmRleCAhPT0gbmFtZSApIHtcbiAgICAgICAgcHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuICAgICAgICBkZWxldGUgcHJvcHNbIGluZGV4IF07XG4gICAgICB9XG5cbiAgICAgIGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG4gICAgICBpZiAoIGhvb2tzICYmICdleHBhbmQnIGluIGhvb2tzICkge1xuICAgICAgICB2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcbiAgICAgICAgZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cbiAgICAgICAgLy8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuICAgICAgICAvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG4gICAgICAgIGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuICAgICAgICAgIGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcbiAgICAgICAgICAgIHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG4gICAgICAgICAgICBzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcbiAgICB2YXIgcmVzdWx0LFxuICAgICAgc3RvcHBlZCxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcbiAgICAgIGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3JcbiAgICAgICAgZGVsZXRlIHRpY2suZWxlbTtcbiAgICAgIH0gKSxcbiAgICAgIHRpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCBzdG9wcGVkICkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuICAgICAgICAgIHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblxuICAgICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zIG9ubHlcbiAgICAgICAgICAvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG4gICAgICAgICAgdGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuICAgICAgICAgIHBlcmNlbnQgPSAxIC0gdGVtcCxcbiAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcbiAgICAgICAgICBhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cbiAgICAgICAgLy8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxuICAgICAgICBpZiAoIHBlcmNlbnQgPCAxICYmIGxlbmd0aCApIHtcbiAgICAgICAgICByZXR1cm4gcmVtYWluaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhpcyB3YXMgYW4gZW1wdHkgYW5pbWF0aW9uLCBzeW50aGVzaXplIGEgZmluYWwgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uXG4gICAgICAgIGlmICggIWxlbmd0aCApIHtcbiAgICAgICAgICBkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNvbHZlIHRoZSBhbmltYXRpb24gYW5kIHJlcG9ydCBpdHMgY29uY2x1c2lvblxuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgYW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuICAgICAgICBlbGVtOiBlbGVtLFxuICAgICAgICBwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcbiAgICAgICAgb3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuICAgICAgICAgIHNwZWNpYWxFYXNpbmc6IHt9LFxuICAgICAgICAgIGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxuICAgICAgICB9LCBvcHRpb25zICksXG4gICAgICAgIG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcbiAgICAgICAgb3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuICAgICAgICBzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG4gICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuICAgICAgICB0d2VlbnM6IFtdLFxuICAgICAgICBjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcbiAgICAgICAgICB2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG4gICAgICAgICAgICBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG4gICAgICAgICAgYW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuICAgICAgICAgIHJldHVybiB0d2VlbjtcbiAgICAgICAgfSxcbiAgICAgICAgc3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gMCxcblxuICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcbiAgICAgICAgICAgIGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG4gICAgICAgICAgaWYgKCBzdG9wcGVkICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgIGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG4gICAgICAgICAgICBhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG4gICAgICAgICAgaWYgKCBnb3RvRW5kICkge1xuICAgICAgICAgICAgZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfSApLFxuICAgICAgcHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cbiAgICBwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApO1xuXG4gICAgZm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcbiAgICAgIHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG4gICAgICBpZiAoIHJlc3VsdCApIHtcbiAgICAgICAgaWYgKCBpc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xuICAgICAgICAgIGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG5cdFx0XHRcdFx0cmVzdWx0LnN0b3AuYmluZCggcmVzdWx0ICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG4gICAgaWYgKCBpc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuICAgICAgYW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG4gICAgfVxuXG4gICAgLy8gQXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcbiAgICBhbmltYXRpb25cbiAgICAgIC5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuICAgICAgLmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcbiAgICAgIC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcbiAgICAgIC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xuXG4gICAgalF1ZXJ5LmZ4LnRpbWVyKFxuICAgICAgalF1ZXJ5LmV4dGVuZCggdGljaywge1xuICAgICAgICBlbGVtOiBlbGVtLFxuICAgICAgICBhbmltOiBhbmltYXRpb24sXG4gICAgICAgIHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuICAgICAgfSApXG4gICAgKTtcblxuICAgIHJldHVybiBhbmltYXRpb247XG4gIH1cblxuICBqUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cbiAgICB0d2VlbmVyczoge1xuICAgICAgJyonOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcbiAgICAgICAgdmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcbiAgICAgICAgYWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XG4gICAgICAgIHJldHVybiB0d2VlbjtcbiAgICAgIH0gXVxuICAgIH0sXG5cbiAgICB0d2VlbmVyOiBmdW5jdGlvbiggcHJvcHMsIGNhbGxiYWNrICkge1xuICAgICAgaWYgKCBpc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuICAgICAgICBjYWxsYmFjayA9IHByb3BzO1xuICAgICAgICBwcm9wcyA9IFsgJyonIF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wLFxuICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgZm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcbiAgICAgICAgcHJvcCA9IHByb3BzWyBpbmRleCBdO1xuICAgICAgICBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSA9IEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuICAgICAgICBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBwcmVmaWx0ZXJzOiBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblxuICAgIHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuICAgICAgaWYgKCBwcmVwZW5kICkge1xuICAgICAgICBBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gKTtcblxuICBqUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG4gICAgdmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gJ29iamVjdCcgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcbiAgICAgIGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRpc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuICAgICAgZHVyYXRpb246IHNwZWVkLFxuICAgICAgZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFpc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcbiAgICB9O1xuXG4gICAgLy8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmXG4gICAgaWYgKCBqUXVlcnkuZngub2ZmICkge1xuICAgICAgb3B0LmR1cmF0aW9uID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIHR5cGVvZiBvcHQuZHVyYXRpb24gIT09ICdudW1iZXInICkge1xuICAgICAgICBpZiAoIG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzICkge1xuICAgICAgICAgIG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuICAgIGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuICAgICAgb3B0LnF1ZXVlID0gJ2Z4JztcbiAgICB9XG5cbiAgICAvLyBRdWV1ZWluZ1xuICAgIG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cbiAgICBvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICggaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuICAgICAgICBvcHQub2xkLmNhbGwoIHRoaXMgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCBvcHQucXVldWUgKSB7XG4gICAgICAgIGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIG9wdDtcbiAgfTtcblxuICBqUXVlcnkuZm4uZXh0ZW5kKCB7XG4gICAgZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG4gICAgICAvLyBTaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW5XaXRoaW5UcmVlICkuY3NzKCAnb3BhY2l0eScsIDAgKS5zaG93KClcblxuICAgICAgLy8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG4gICAgICAgIC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG4gICAgfSxcbiAgICBhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG4gICAgICB2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuICAgICAgICBvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG4gICAgICAgIGRvQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuICAgICAgICAgIHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuICAgICAgICAgIC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuICAgICAgICAgIGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCAnZmluaXNoJyApICkge1xuICAgICAgICAgICAgYW5pbS5zdG9wKCB0cnVlICk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XG5cbiAgICAgIHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cbiAgICAgICAgdGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcbiAgICAgICAgdGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuICAgIH0sXG4gICAgc3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG4gICAgICB2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkge1xuICAgICAgICB2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG4gICAgICAgIGRlbGV0ZSBob29rcy5zdG9wO1xuICAgICAgICBzdG9wKCBnb3RvRW5kICk7XG4gICAgICB9O1xuXG4gICAgICBpZiAoIHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJyApIHtcbiAgICAgICAgZ290b0VuZCA9IGNsZWFyUXVldWU7XG4gICAgICAgIGNsZWFyUXVldWUgPSB0eXBlO1xuICAgICAgICB0eXBlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKCBjbGVhclF1ZXVlICYmIHR5cGUgIT09IGZhbHNlICkge1xuICAgICAgICB0aGlzLnF1ZXVlKCB0eXBlIHx8ICdmeCcsIFtdICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGVxdWV1ZSA9IHRydWUsXG4gICAgICAgICAgaW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArICdxdWV1ZUhvb2tzJyxcbiAgICAgICAgICB0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuICAgICAgICAgIGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcblxuICAgICAgICBpZiAoIGluZGV4ICkge1xuICAgICAgICAgIGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG4gICAgICAgICAgICBzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICggaW5kZXggaW4gZGF0YSApIHtcbiAgICAgICAgICAgIGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgcnJ1bi50ZXN0KCBpbmRleCApICkge1xuICAgICAgICAgICAgICBzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuICAgICAgICAgIGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiZcblx0XHRcdFx0XHQoIHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSApIHtcblxuICAgICAgICAgICAgdGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuICAgICAgICAgICAgZGVxdWV1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkLlxuICAgICAgICAvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG4gICAgICAgIC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cbiAgICAgICAgaWYgKCBkZXF1ZXVlIHx8ICFnb3RvRW5kICkge1xuICAgICAgICAgIGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG4gICAgICAgIH1cbiAgICAgIH0gKTtcbiAgICB9LFxuICAgIGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG4gICAgICBpZiAoIHR5cGUgIT09IGZhbHNlICkge1xuICAgICAgICB0eXBlID0gdHlwZSB8fCAnZngnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbmRleCxcbiAgICAgICAgICBkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG4gICAgICAgICAgcXVldWUgPSBkYXRhWyB0eXBlICsgJ3F1ZXVlJyBdLFxuICAgICAgICAgIGhvb2tzID0gZGF0YVsgdHlwZSArICdxdWV1ZUhvb2tzJyBdLFxuICAgICAgICAgIHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG4gICAgICAgICAgbGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG4gICAgICAgIC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcbiAgICAgICAgZGF0YS5maW5pc2ggPSB0cnVlO1xuXG4gICAgICAgIC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuICAgICAgICBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cbiAgICAgICAgaWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuICAgICAgICAgIGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cbiAgICAgICAgZm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcbiAgICAgICAgICBpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcbiAgICAgICAgICAgIHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcbiAgICAgICAgICAgIHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cbiAgICAgICAgZm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcbiAgICAgICAgICBpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcbiAgICAgICAgICAgIHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHVybiBvZmYgZmluaXNoaW5nIGZsYWdcbiAgICAgICAgZGVsZXRlIGRhdGEuZmluaXNoO1xuICAgICAgfSApO1xuICAgIH1cbiAgfSApO1xuXG4gIGpRdWVyeS5lYWNoKCBbICd0b2dnbGUnLCAnc2hvdycsICdoaWRlJyBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcbiAgICB2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcbiAgICBqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcbiAgICAgIHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gJ2Jvb2xlYW4nID9cbiAgICAgICAgY3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcbiAgICAgICAgdGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuICAgIH07XG4gIH0gKTtcblxuICAvLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG4gIGpRdWVyeS5lYWNoKCB7XG4gICAgc2xpZGVEb3duOiBnZW5GeCggJ3Nob3cnICksXG4gICAgc2xpZGVVcDogZ2VuRngoICdoaWRlJyApLFxuICAgIHNsaWRlVG9nZ2xlOiBnZW5GeCggJ3RvZ2dsZScgKSxcbiAgICBmYWRlSW46IHsgb3BhY2l0eTogJ3Nob3cnIH0sXG4gICAgZmFkZU91dDogeyBvcGFjaXR5OiAnaGlkZScgfSxcbiAgICBmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6ICd0b2dnbGUnIH1cbiAgfSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuICAgIGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG4gICAgfTtcbiAgfSApO1xuXG4gIGpRdWVyeS50aW1lcnMgPSBbXTtcbiAgalF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGltZXIsXG4gICAgICBpID0gMCxcbiAgICAgIHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cbiAgICBmeE5vdyA9IERhdGUubm93KCk7XG5cbiAgICBmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG4gICAgICB0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG4gICAgICAvLyBSdW4gdGhlIHRpbWVyIGFuZCBzYWZlbHkgcmVtb3ZlIGl0IHdoZW4gZG9uZSAoYWxsb3dpbmcgZm9yIGV4dGVybmFsIHJlbW92YWwpXG4gICAgICBpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcbiAgICAgICAgdGltZXJzLnNwbGljZSggaS0tLCAxICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCAhdGltZXJzLmxlbmd0aCApIHtcbiAgICAgIGpRdWVyeS5meC5zdG9wKCk7XG4gICAgfVxuICAgIGZ4Tm93ID0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIGpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcbiAgICBqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG4gICAgalF1ZXJ5LmZ4LnN0YXJ0KCk7XG4gIH07XG5cbiAgalF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG4gIGpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICggaW5Qcm9ncmVzcyApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpblByb2dyZXNzID0gdHJ1ZTtcbiAgICBzY2hlZHVsZSgpO1xuICB9O1xuXG4gIGpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgaW5Qcm9ncmVzcyA9IG51bGw7XG4gIH07XG5cbiAgalF1ZXJ5LmZ4LnNwZWVkcyA9IHtcbiAgICBzbG93OiA2MDAsXG4gICAgZmFzdDogMjAwLFxuXG4gICAgLy8gRGVmYXVsdCBzcGVlZFxuICAgIF9kZWZhdWx0OiA0MDBcbiAgfTtcblxuXG4gIC8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cbiAgLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbiAgalF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG4gICAgdGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcbiAgICB0eXBlID0gdHlwZSB8fCAnZngnO1xuXG4gICAgcmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcbiAgICAgIHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcbiAgICAgIGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuICAgICAgfTtcbiAgICB9ICk7XG4gIH07XG5cblxuICAoIGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdpbnB1dCcgKSxcbiAgICAgIHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdzZWxlY3QnICksXG4gICAgICBvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdvcHRpb24nICkgKTtcblxuICAgIGlucHV0LnR5cGUgPSAnY2hlY2tib3gnO1xuXG4gICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMyBvbmx5XG4gICAgLy8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG4gICAgc3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09ICcnO1xuXG4gICAgLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4gICAgLy8gTXVzdCBhY2Nlc3Mgc2VsZWN0ZWRJbmRleCB0byBtYWtlIGRlZmF1bHQgb3B0aW9ucyBzZWxlY3RcbiAgICBzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG4gICAgLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4gICAgLy8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cbiAgICBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdpbnB1dCcgKTtcbiAgICBpbnB1dC52YWx1ZSA9ICd0JztcbiAgICBpbnB1dC50eXBlID0gJ3JhZGlvJztcbiAgICBzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gJ3QnO1xuICB9ICkoKTtcblxuXG4gIHZhciBib29sSG9vayxcbiAgICBhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxuICBqUXVlcnkuZm4uZXh0ZW5kKCB7XG4gICAgYXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuICAgICAgcmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuICAgIH0sXG5cbiAgICByZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuICAgICAgICBqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuICAgICAgfSApO1xuICAgIH1cbiAgfSApO1xuXG4gIGpRdWVyeS5leHRlbmQoIHtcbiAgICBhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG4gICAgICB2YXIgcmV0LCBob29rcyxcbiAgICAgICAgblR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG4gICAgICAvLyBEb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG4gICAgICBpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG4gICAgICBpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICAgIHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcbiAgICAgIH1cblxuICAgICAgLy8gQXR0cmlidXRlIGhvb2tzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuICAgICAgLy8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuICAgICAgaWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG4gICAgICAgIGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogdW5kZWZpbmVkICk7XG4gICAgICB9XG5cbiAgICAgIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgaWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcbiAgICAgICAgICBqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggaG9va3MgJiYgJ3NldCcgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyAnJyApO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICggaG9va3MgJiYgJ2dldCcgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuXG4gICAgICByZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cbiAgICAgIC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG4gICAgICByZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG4gICAgfSxcblxuICAgIGF0dHJIb29rczoge1xuICAgICAgdHlwZToge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcbiAgICAgICAgICBpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09ICdyYWRpbycgJiZcblx0XHRcdFx0XHRub2RlTmFtZSggZWxlbSwgJ2lucHV0JyApICkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGVsZW0udmFsdWU7XG4gICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSggJ3R5cGUnLCB2YWx1ZSApO1xuICAgICAgICAgICAgaWYgKCB2YWwgKSB7XG4gICAgICAgICAgICAgIGVsZW0udmFsdWUgPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcbiAgICAgIHZhciBuYW1lLFxuICAgICAgICBpID0gMCxcblxuICAgICAgICAvLyBBdHRyaWJ1dGUgbmFtZXMgY2FuIGNvbnRhaW4gbm9uLUhUTUwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG4gICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuICAgICAgICBhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXG4gICAgICBpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuICAgICAgICB3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcbiAgICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9ICk7XG5cbiAgLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuICBib29sSG9vayA9IHtcbiAgICBzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcbiAgICAgIGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG4gICAgICAgIC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2VcbiAgICAgICAgalF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gIH07XG5cbiAgalF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuICAgIHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuICAgIGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcbiAgICAgIHZhciByZXQsIGhhbmRsZSxcbiAgICAgICAgbG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgaWYgKCAhaXNYTUwgKSB7XG5cbiAgICAgICAgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuICAgICAgICBoYW5kbGUgPSBhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF07XG4gICAgICAgIGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IHJldDtcbiAgICAgICAgcmV0ID0gZ2V0dGVyKCBlbGVtLCBuYW1lLCBpc1hNTCApICE9IG51bGwgP1xuICAgICAgICAgIGxvd2VyY2FzZU5hbWUgOlxuICAgICAgICAgIG51bGw7XG4gICAgICAgIGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IGhhbmRsZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgfSApO1xuXG5cblxuXG4gIHZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcbiAgICByY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pO1xuXG4gIGpRdWVyeS5mbi5leHRlbmQoIHtcbiAgICBwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG4gICAgICByZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG4gICAgfSxcblxuICAgIHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcbiAgICAgIH0gKTtcbiAgICB9XG4gIH0gKTtcblxuICBqUXVlcnkuZXh0ZW5kKCB7XG4gICAgcHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuICAgICAgdmFyIHJldCwgaG9va3MsXG4gICAgICAgIG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuICAgICAgLy8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuICAgICAgaWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuICAgICAgICAvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG4gICAgICAgIG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG4gICAgICAgIGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIGlmICggaG9va3MgJiYgJ3NldCcgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIGhvb2tzICYmICdnZXQnIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsZW1bIG5hbWUgXTtcbiAgICB9LFxuXG4gICAgcHJvcEhvb2tzOiB7XG4gICAgICB0YWJJbmRleDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG4gICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuICAgICAgICAgIC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuICAgICAgICAgIC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuICAgICAgICAgIC8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDE0MTExNjIzMzM0Ny9odHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuICAgICAgICAgIC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXG4gICAgICAgICAgdmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgJ3RhYmluZGV4JyApO1xuXG4gICAgICAgICAgaWYgKCB0YWJpbmRleCApIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludCggdGFiaW5kZXgsIDEwICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHxcblx0XHRcdFx0XHRyY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJlxuXHRcdFx0XHRcdGVsZW0uaHJlZlxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHByb3BGaXg6IHtcbiAgICAgICdmb3InOiAnaHRtbEZvcicsXG4gICAgICAnY2xhc3MnOiAnY2xhc3NOYW1lJ1xuICAgIH1cbiAgfSApO1xuXG4gIC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuICAvLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbiAgLy8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxuICAvLyBvbiB0aGUgb3B0aW9uXG4gIC8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4gIC8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcbiAgLy8gZXNsaW50IHJ1bGUgXCJuby11bnVzZWQtZXhwcmVzc2lvbnNcIiBpcyBkaXNhYmxlZCBmb3IgdGhpcyBjb2RlXG4gIC8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxuICBpZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuICAgIGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG4gICAgICAgIC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuICAgICAgICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcbiAgICAgICAgICBwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cbiAgICAgICAgLyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG4gICAgICAgIHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICggcGFyZW50ICkge1xuICAgICAgICAgIHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG4gICAgICAgICAgaWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcbiAgICAgICAgICAgIHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGpRdWVyeS5lYWNoKCBbXG4gICAgJ3RhYkluZGV4JyxcbiAgICAncmVhZE9ubHknLFxuICAgICdtYXhMZW5ndGgnLFxuICAgICdjZWxsU3BhY2luZycsXG4gICAgJ2NlbGxQYWRkaW5nJyxcbiAgICAncm93U3BhbicsXG4gICAgJ2NvbFNwYW4nLFxuICAgICd1c2VNYXAnLFxuICAgICdmcmFtZUJvcmRlcicsXG4gICAgJ2NvbnRlbnRFZGl0YWJsZSdcbiAgXSwgZnVuY3Rpb24oKSB7XG4gICAgalF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcbiAgfSApO1xuXG5cblxuXG4gIC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlIGFjY29yZGluZyB0byBIVE1MIHNwZWNcbiAgLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS1hc2NpaS13aGl0ZXNwYWNlXG4gIGZ1bmN0aW9uIHN0cmlwQW5kQ29sbGFwc2UoIHZhbHVlICkge1xuICAgIHZhciB0b2tlbnMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuICAgIHJldHVybiB0b2tlbnMuam9pbiggJyAnICk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGdldENsYXNzKCBlbGVtICkge1xuICAgIHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggJ2NsYXNzJyApIHx8ICcnO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICkge1xuICAgIGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICkge1xuICAgICAgcmV0dXJuIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGpRdWVyeS5mbi5leHRlbmQoIHtcbiAgICBhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuICAgICAgdmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuICAgICAgICBpID0gMDtcblxuICAgICAgaWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcbiAgICAgICAgICBqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG4gICAgICAgIH0gKTtcbiAgICAgIH1cblxuICAgICAgY2xhc3NlcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG4gICAgICBpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xuICAgICAgICB3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG4gICAgICAgICAgY3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuICAgICAgICAgIGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCAnICcgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgJyAnICk7XG5cbiAgICAgICAgICBpZiAoIGN1ciApIHtcbiAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgd2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcbiAgICAgICAgICAgICAgaWYgKCBjdXIuaW5kZXhPZiggJyAnICsgY2xhenogKyAnICcgKSA8IDAgKSB7XG4gICAgICAgICAgICAgICAgY3VyICs9IGNsYXp6ICsgJyAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG4gICAgICAgICAgICBmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG4gICAgICAgICAgICBpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSggJ2NsYXNzJywgZmluYWxWYWx1ZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgIHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcbiAgICAgICAgaSA9IDA7XG5cbiAgICAgIGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG4gICAgICAgICAgalF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuICAgICAgICB9ICk7XG4gICAgICB9XG5cbiAgICAgIGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoICdjbGFzcycsICcnICk7XG4gICAgICB9XG5cbiAgICAgIGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuICAgICAgaWYgKCBjbGFzc2VzLmxlbmd0aCApIHtcbiAgICAgICAgd2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuICAgICAgICAgIGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuICAgICAgICAgIC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXG4gICAgICAgICAgY3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoICcgJyArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyAnICcgKTtcblxuICAgICAgICAgIGlmICggY3VyICkge1xuICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXG4gICAgICAgICAgICAgIC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcbiAgICAgICAgICAgICAgd2hpbGUgKCBjdXIuaW5kZXhPZiggJyAnICsgY2xhenogKyAnICcgKSA+IC0xICkge1xuICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKCAnICcgKyBjbGF6eiArICcgJywgJyAnICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cbiAgICAgICAgICAgIGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcbiAgICAgICAgICAgIGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG4gICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCAnY2xhc3MnLCBmaW5hbFZhbHVlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlLFxuICAgICAgICBpc1ZhbGlkVmFsdWUgPSB0eXBlID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KCB2YWx1ZSApO1xuXG4gICAgICBpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gJ2Jvb2xlYW4nICYmIGlzVmFsaWRWYWx1ZSApIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG4gICAgICB9XG5cbiAgICAgIGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG4gICAgICAgICAgalF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoXG4gICAgICAgICAgICB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBnZXRDbGFzcyggdGhpcyApLCBzdGF0ZVZhbCApLFxuICAgICAgICAgICAgc3RhdGVWYWxcbiAgICAgICAgICApO1xuICAgICAgICB9ICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2xhc3NOYW1lLCBpLCBzZWxmLCBjbGFzc05hbWVzO1xuXG4gICAgICAgIGlmICggaXNWYWxpZFZhbHVlICkge1xuXG4gICAgICAgICAgLy8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgICBzZWxmID0galF1ZXJ5KCB0aGlzICk7XG4gICAgICAgICAgY2xhc3NOYW1lcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG4gICAgICAgICAgd2hpbGUgKCAoIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdICkgKSB7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuICAgICAgICAgICAgaWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcbiAgICAgICAgICAgICAgc2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuICAgICAgICB9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09ICdib29sZWFuJyApIHtcbiAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuICAgICAgICAgIGlmICggY2xhc3NOYW1lICkge1xuXG4gICAgICAgICAgICAvLyBTdG9yZSBjbGFzc05hbWUgaWYgc2V0XG4gICAgICAgICAgICBkYXRhUHJpdi5zZXQoIHRoaXMsICdfX2NsYXNzTmFtZV9fJywgY2xhc3NOYW1lICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcbiAgICAgICAgICAvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuICAgICAgICAgIC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG4gICAgICAgICAgLy8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuICAgICAgICAgIGlmICggdGhpcy5zZXRBdHRyaWJ1dGUgKSB7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSggJ2NsYXNzJyxcbiAgICAgICAgICAgICAgY2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG4gICAgICAgICAgICAgICAgJycgOlxuICAgICAgICAgICAgICAgIGRhdGFQcml2LmdldCggdGhpcywgJ19fY2xhc3NOYW1lX18nICkgfHwgJydcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9ICk7XG4gICAgfSxcblxuICAgIGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG4gICAgICB2YXIgY2xhc3NOYW1lLCBlbGVtLFxuICAgICAgICBpID0gMDtcblxuICAgICAgY2xhc3NOYW1lID0gJyAnICsgc2VsZWN0b3IgKyAnICc7XG4gICAgICB3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG4gICAgICAgIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoICcgJyArIHN0cmlwQW5kQ29sbGFwc2UoIGdldENsYXNzKCBlbGVtICkgKSArICcgJyApLmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTEgKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSApO1xuXG5cblxuXG4gIHZhciBycmV0dXJuID0gL1xcci9nO1xuXG4gIGpRdWVyeS5mbi5leHRlbmQoIHtcbiAgICB2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgIHZhciBob29rcywgcmV0LCB2YWx1ZUlzRnVuY3Rpb24sXG4gICAgICAgIGVsZW0gPSB0aGlzWyAwIF07XG5cbiAgICAgIGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG4gICAgICAgIGlmICggZWxlbSApIHtcbiAgICAgICAgICBob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcblx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG4gICAgICAgICAgaWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdCdnZXQnIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sICd2YWx1ZScgKSApICE9PSB1bmRlZmluZWRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0ID0gZWxlbS52YWx1ZTtcblxuICAgICAgICAgIC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcbiAgICAgICAgICBpZiAoIHR5cGVvZiByZXQgPT09ICdzdHJpbmcnICkge1xuICAgICAgICAgICAgcmV0dXJuIHJldC5yZXBsYWNlKCBycmV0dXJuLCAnJyApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuICAgICAgICAgIHJldHVybiByZXQgPT0gbnVsbCA/ICcnIDogcmV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcbiAgICAgICAgdmFyIHZhbDtcblxuICAgICAgICBpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG4gICAgICAgICAgdmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcbiAgICAgICAgaWYgKCB2YWwgPT0gbnVsbCApIHtcbiAgICAgICAgICB2YWwgPSAnJztcblxuICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyApIHtcbiAgICAgICAgICB2YWwgKz0gJyc7XG5cbiAgICAgICAgfSBlbHNlIGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG4gICAgICAgICAgdmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWUgKyAnJztcbiAgICAgICAgICB9ICk7XG4gICAgICAgIH1cblxuICAgICAgICBob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuICAgICAgICAvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuICAgICAgICBpZiAoICFob29rcyB8fCAhKCAnc2V0JyBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCAndmFsdWUnICkgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9ICk7XG4gICAgfVxuICB9ICk7XG5cbiAgalF1ZXJ5LmV4dGVuZCgge1xuICAgIHZhbEhvb2tzOiB7XG4gICAgICBvcHRpb246IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuICAgICAgICAgIHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCAndmFsdWUnICk7XG4gICAgICAgICAgcmV0dXJuIHZhbCAhPSBudWxsID9cbiAgICAgICAgICAgIHZhbCA6XG5cbiAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxuICAgICAgICAgIC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcbiAgICAgICAgICAvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG4gICAgICAgICAgICBzdHJpcEFuZENvbGxhcHNlKCBqUXVlcnkudGV4dCggZWxlbSApICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZWxlY3Q6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICB2YXIgdmFsdWUsIG9wdGlvbiwgaSxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG4gICAgICAgICAgICBpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcbiAgICAgICAgICAgIG9uZSA9IGVsZW0udHlwZSA9PT0gJ3NlbGVjdC1vbmUnLFxuICAgICAgICAgICAgdmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuICAgICAgICAgICAgbWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAoIGluZGV4IDwgMCApIHtcbiAgICAgICAgICAgIGkgPSBtYXg7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaSA9IG9uZSA/IGluZGV4IDogMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG4gICAgICAgICAgZm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG4gICAgICAgICAgICBvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4gICAgICAgICAgICAvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcbiAgICAgICAgICAgIGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0IW9wdGlvbi5kaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxuXHRcdFx0XHRcdFx0XHRcdCFub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsICdvcHRncm91cCcgKSApICkge1xuXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cbiAgICAgICAgICAgICAgdmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG4gICAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG4gICAgICAgICAgICAgIGlmICggb25lICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG4gICAgICAgICAgICAgIHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG4gICAgICAgICAgdmFyIG9wdGlvblNldCwgb3B0aW9uLFxuICAgICAgICAgICAgb3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcbiAgICAgICAgICAgIHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG4gICAgICAgICAgICBpID0gb3B0aW9ucy5sZW5ndGg7XG5cbiAgICAgICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgICAgIG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cblxuICAgICAgICAgICAgaWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIG9wdGlvblNldCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuICAgICAgICAgIGlmICggIW9wdGlvblNldCApIHtcbiAgICAgICAgICAgIGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9ICk7XG5cbiAgLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbiAgalF1ZXJ5LmVhY2goIFsgJ3JhZGlvJywgJ2NoZWNrYm94JyBdLCBmdW5jdGlvbigpIHtcbiAgICBqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcbiAgICAgIHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG4gICAgICAgICAgcmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgaWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuICAgICAgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgIHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApID09PSBudWxsID8gJ29uJyA6IGVsZW0udmFsdWU7XG4gICAgICB9O1xuICAgIH1cbiAgfSApO1xuXG5cblxuXG4gIC8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cblxuXG4gIHN1cHBvcnQuZm9jdXNpbiA9ICdvbmZvY3VzaW4nIGluIHdpbmRvdztcblxuXG4gIHZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxcbiAgICBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayA9IGZ1bmN0aW9uKCBlICkge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9O1xuXG4gIGpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG4gICAgdHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XG5cbiAgICAgIHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsIGxhc3RFbGVtZW50LFxuICAgICAgICBldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcbiAgICAgICAgdHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgJ3R5cGUnICkgPyBldmVudC50eXBlIDogZXZlbnQsXG4gICAgICAgIG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsICduYW1lc3BhY2UnICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoICcuJyApIDogW107XG5cbiAgICAgIGN1ciA9IGxhc3RFbGVtZW50ID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cbiAgICAgIC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG4gICAgICBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcbiAgICAgIGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIHR5cGUuaW5kZXhPZiggJy4nICkgPiAtMSApIHtcblxuICAgICAgICAvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG4gICAgICAgIG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KCAnLicgKTtcbiAgICAgICAgdHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcbiAgICAgICAgbmFtZXNwYWNlcy5zb3J0KCk7XG4gICAgICB9XG4gICAgICBvbnR5cGUgPSB0eXBlLmluZGV4T2YoICc6JyApIDwgMCAmJiAnb24nICsgdHlwZTtcblxuICAgICAgLy8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG4gICAgICBldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cbiAgICAgICAgZXZlbnQgOlxuICAgICAgICBuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09ICdvYmplY3QnICYmIGV2ZW50ICk7XG5cbiAgICAgIC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcbiAgICAgIGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuICAgICAgZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCAnLicgKTtcbiAgICAgIGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuICAgICAgICBuZXcgUmVnRXhwKCAnKF58XFxcXC4pJyArIG5hbWVzcGFjZXMuam9pbiggJ1xcXFwuKD86LipcXFxcLnwpJyApICsgJyhcXFxcLnwkKScgKSA6XG4gICAgICAgIG51bGw7XG5cbiAgICAgIC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuICAgICAgZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuICAgICAgICBldmVudC50YXJnZXQgPSBlbGVtO1xuICAgICAgfVxuXG4gICAgICAvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XG4gICAgICBkYXRhID0gZGF0YSA9PSBudWxsID9cbiAgICAgICAgWyBldmVudCBdIDpcbiAgICAgICAgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7XG5cbiAgICAgIC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcbiAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuICAgICAgaWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXG4gICAgICAvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuICAgICAgaWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG4gICAgICAgIGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xuICAgICAgICBpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcbiAgICAgICAgICBldmVudFBhdGgucHVzaCggY3VyICk7XG4gICAgICAgICAgdG1wID0gY3VyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG4gICAgICAgIGlmICggdG1wID09PSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApICkge1xuICAgICAgICAgIGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG4gICAgICBpID0gMDtcbiAgICAgIHdoaWxlICggKCBjdXIgPSBldmVudFBhdGhbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG4gICAgICAgIGxhc3RFbGVtZW50ID0gY3VyO1xuICAgICAgICBldmVudC50eXBlID0gaSA+IDEgP1xuICAgICAgICAgIGJ1YmJsZVR5cGUgOlxuICAgICAgICAgIHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuICAgICAgICAvLyBqUXVlcnkgaGFuZGxlclxuICAgICAgICBoYW5kbGUgPSAoIGRhdGFQcml2LmdldCggY3VyLCAnZXZlbnRzJyApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSAmJlxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgJ2hhbmRsZScgKTtcbiAgICAgICAgaWYgKCBoYW5kbGUgKSB7XG4gICAgICAgICAgaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5hdGl2ZSBoYW5kbGVyXG4gICAgICAgIGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbIG9udHlwZSBdO1xuICAgICAgICBpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG4gICAgICAgICAgZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcbiAgICAgICAgICBpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZXZlbnQudHlwZSA9IHR5cGU7XG5cbiAgICAgIC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcbiAgICAgIGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cbiAgICAgICAgaWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG5cdFx0XHRcdHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG5cdFx0XHRcdGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuICAgICAgICAgIC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBhcyB0aGUgZXZlbnQuXG4gICAgICAgICAgLy8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuICAgICAgICAgIGlmICggb250eXBlICYmIGlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG4gICAgICAgICAgICAvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG4gICAgICAgICAgICB0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuICAgICAgICAgICAgaWYgKCB0bXAgKSB7XG4gICAgICAgICAgICAgIGVsZW1bIG9udHlwZSBdID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcbiAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXG4gICAgICAgICAgICBpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG4gICAgICAgICAgICAgIGxhc3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsZW1bIHR5cGUgXSgpO1xuXG4gICAgICAgICAgICBpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG4gICAgICAgICAgICAgIGxhc3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIGlmICggdG1wICkge1xuICAgICAgICAgICAgICBlbGVtWyBvbnR5cGUgXSA9IHRtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV2ZW50LnJlc3VsdDtcbiAgICB9LFxuXG4gICAgLy8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG4gICAgLy8gVXNlZCBvbmx5IGZvciBgZm9jdXMoaW4gfCBvdXQpYCBldmVudHNcbiAgICBzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuICAgICAgdmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuICAgICAgICBuZXcgalF1ZXJ5LkV2ZW50KCksXG4gICAgICAgIGV2ZW50LFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICBpc1NpbXVsYXRlZDogdHJ1ZVxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuICAgIH1cblxuICB9ICk7XG5cbiAgalF1ZXJ5LmZuLmV4dGVuZCgge1xuXG4gICAgdHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcbiAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcbiAgICAgIH0gKTtcbiAgICB9LFxuICAgIHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcbiAgICAgIHZhciBlbGVtID0gdGhpc1sgMCBdO1xuICAgICAgaWYgKCBlbGVtICkge1xuICAgICAgICByZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gKTtcblxuXG4gIC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxuICAvLyBGaXJlZm94IGRvZXNuJ3QgaGF2ZSBmb2N1cyhpbiB8IG91dCkgZXZlbnRzXG4gIC8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG4gIC8vXG4gIC8vIFN1cHBvcnQ6IENocm9tZSA8PTQ4IC0gNDksIFNhZmFyaSA8PTkuMCAtIDkuMVxuICAvLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcbiAgLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG4gIC8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ5ODU3XG4gIGlmICggIXN1cHBvcnQuZm9jdXNpbiApIHtcbiAgICBqUXVlcnkuZWFjaCggeyBmb2N1czogJ2ZvY3VzaW4nLCBibHVyOiAnZm9jdXNvdXQnIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cbiAgICAgIC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG4gICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgICAgICAgalF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSApO1xuICAgICAgfTtcblxuICAgICAgalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuICAgICAgICBzZXR1cDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuICAgICAgICAgICAgYXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cbiAgICAgICAgICBpZiAoICFhdHRhY2hlcyApIHtcbiAgICAgICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xuICAgICAgICB9LFxuICAgICAgICB0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuICAgICAgICAgICAgYXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICkgLSAxO1xuXG4gICAgICAgICAgaWYgKCAhYXR0YWNoZXMgKSB7XG4gICAgICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuICAgICAgICAgICAgZGF0YVByaXYucmVtb3ZlKCBkb2MsIGZpeCApO1xuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsIGF0dGFjaGVzICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gKTtcbiAgfVxuICB2YXIgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG5cbiAgdmFyIG5vbmNlID0gRGF0ZS5ub3coKTtcblxuICB2YXIgcnF1ZXJ5ID0gKCAvXFw/LyApO1xuXG5cblxuICAvLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG4gIGpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuICAgIHZhciB4bWw7XG4gICAgaWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycgKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuICAgIC8vIElFIHRocm93cyBvbiBwYXJzZUZyb21TdHJpbmcgd2l0aCBpbnZhbGlkIGlucHV0LlxuICAgIHRyeSB7XG4gICAgICB4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGRhdGEsICd0ZXh0L3htbCcgKTtcbiAgICB9IGNhdGNoICggZSApIHtcbiAgICAgIHhtbCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoICF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCAncGFyc2VyZXJyb3InICkubGVuZ3RoICkge1xuICAgICAgalF1ZXJ5LmVycm9yKCAnSW52YWxpZCBYTUw6ICcgKyBkYXRhICk7XG4gICAgfVxuICAgIHJldHVybiB4bWw7XG4gIH07XG5cblxuICB2YXJcbiAgICByYnJhY2tldCA9IC9cXFtcXF0kLyxcbiAgICByQ1JMRiA9IC9cXHI/XFxuL2csXG4gICAgcnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuICAgIHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuICBmdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG4gICAgdmFyIG5hbWU7XG5cbiAgICBpZiAoIEFycmF5LmlzQXJyYXkoIG9iaiApICkge1xuXG4gICAgICAvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cbiAgICAgIGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuICAgICAgICBpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXG4gICAgICAgICAgLy8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuICAgICAgICAgIGFkZCggcHJlZml4LCB2ICk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuICAgICAgICAgIGJ1aWxkUGFyYW1zKFxuICAgICAgICAgICAgcHJlZml4ICsgJ1snICsgKCB0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYgdiAhPSBudWxsID8gaSA6ICcnICkgKyAnXScsXG4gICAgICAgICAgICB2LFxuICAgICAgICAgICAgdHJhZGl0aW9uYWwsXG4gICAgICAgICAgICBhZGRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9ICk7XG5cbiAgICB9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgdG9UeXBlKCBvYmogKSA9PT0gJ29iamVjdCcgKSB7XG5cbiAgICAgIC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cbiAgICAgIGZvciAoIG5hbWUgaW4gb2JqICkge1xuICAgICAgICBidWlsZFBhcmFtcyggcHJlZml4ICsgJ1snICsgbmFtZSArICddJywgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cbiAgICAgIGFkZCggcHJlZml4LCBvYmogKTtcbiAgICB9XG4gIH1cblxuICAvLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuICAvLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbiAgalF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuICAgIHZhciBwcmVmaXgsXG4gICAgICBzID0gW10sXG4gICAgICBhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZU9yRnVuY3Rpb24gKSB7XG5cbiAgICAgICAgLy8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxuICAgICAgICB2YXIgdmFsdWUgPSBpc0Z1bmN0aW9uKCB2YWx1ZU9yRnVuY3Rpb24gKSA/XG4gICAgICAgICAgdmFsdWVPckZ1bmN0aW9uKCkgOlxuICAgICAgICAgIHZhbHVlT3JGdW5jdGlvbjtcblxuICAgICAgICBzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArICc9JyArXG5cdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWUgKTtcbiAgICAgIH07XG5cbiAgICAvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuICAgIGlmICggQXJyYXkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblxuICAgICAgLy8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG4gICAgICBqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG4gICAgICB9ICk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuICAgICAgLy8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG4gICAgICBmb3IgKCBwcmVmaXggaW4gYSApIHtcbiAgICAgICAgYnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG4gICAgcmV0dXJuIHMuam9pbiggJyYnICk7XG4gIH07XG5cbiAgalF1ZXJ5LmZuLmV4dGVuZCgge1xuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcbiAgICB9LFxuICAgIHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgJ2VsZW1lbnRzJyApO1xuICAgICAgICByZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcbiAgICAgIH0gKVxuICAgICAgICAuZmlsdGVyKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgICAgICAgIC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuICAgICAgICAgIHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCAnOmRpc2FibGVkJyApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuICAgICAgICB9IClcbiAgICAgICAgLm1hcCggZnVuY3Rpb24oIGksIGVsZW0gKSB7XG4gICAgICAgICAgdmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG4gICAgICAgICAgaWYgKCB2YWwgPT0gbnVsbCApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xuICAgICAgICAgICAgICByZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsICdcXHJcXG4nICkgfTtcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsICdcXHJcXG4nICkgfTtcbiAgICAgICAgfSApLmdldCgpO1xuICAgIH1cbiAgfSApO1xuXG5cbiAgdmFyXG4gICAgcjIwID0gLyUyMC9nLFxuICAgIHJoYXNoID0gLyMuKiQvLFxuICAgIHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXG4gICAgcmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuXG4gICAgLy8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG4gICAgcmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcbiAgICBybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcbiAgICBycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cbiAgICAvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG4gICAgcHJlZmlsdGVycyA9IHt9LFxuXG4gICAgLyogVHJhbnNwb3J0cyBiaW5kaW5nc1xuXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuICAgIHRyYW5zcG9ydHMgPSB7fSxcblxuICAgIC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuICAgIGFsbFR5cGVzID0gJyovJy5jb25jYXQoICcqJyApLFxuXG4gICAgLy8gQW5jaG9yIHRhZyBmb3IgcGFyc2luZyB0aGUgZG9jdW1lbnQgb3JpZ2luXG4gICAgb3JpZ2luQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2EnICk7XG4gIG9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcblxuICAvLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG4gIGZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG4gICAgLy8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuICAgIHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG4gICAgICBpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09ICdzdHJpbmcnICkge1xuICAgICAgICBmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuICAgICAgICBkYXRhVHlwZUV4cHJlc3Npb24gPSAnKic7XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRhVHlwZSxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cbiAgICAgIGlmICggaXNGdW5jdGlvbiggZnVuYyApICkge1xuXG4gICAgICAgIC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cbiAgICAgICAgd2hpbGUgKCAoIGRhdGFUeXBlID0gZGF0YVR5cGVzWyBpKysgXSApICkge1xuXG4gICAgICAgICAgLy8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcbiAgICAgICAgICBpZiAoIGRhdGFUeXBlWyAwIF0gPT09ICcrJyApIHtcbiAgICAgICAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCAnKic7XG4gICAgICAgICAgICAoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGFwcGVuZFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnB1c2goIGZ1bmMgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG4gIGZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKSB7XG5cbiAgICB2YXIgaW5zcGVjdGVkID0ge30sXG4gICAgICBzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcblxuICAgIGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xuICAgICAgdmFyIHNlbGVjdGVkO1xuICAgICAgaW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcbiAgICAgIGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XG4gICAgICAgIHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG4gICAgICAgIGlmICggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09ICdzdHJpbmcnICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuICAgICAgICAgIG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcbiAgICAgICAgICBpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKCBzZWVraW5nVHJhbnNwb3J0ICkge1xuICAgICAgICAgIHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcbiAgICAgICAgfVxuICAgICAgfSApO1xuICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgIH1cblxuICAgIHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgJyonIF0gJiYgaW5zcGVjdCggJyonICk7XG4gIH1cblxuICAvLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbiAgLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbiAgLy8gRml4ZXMgIzk4ODdcbiAgZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XG4gICAgdmFyIGtleSwgZGVlcCxcbiAgICAgIGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuICAgIGZvciAoIGtleSBpbiBzcmMgKSB7XG4gICAgICBpZiAoIHNyY1sga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgKCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCBkZWVwICkge1xuICAgICAgalF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIC8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuICBmdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG4gICAgdmFyIGN0LCB0eXBlLCBmaW5hbERhdGFUeXBlLCBmaXJzdERhdGFUeXBlLFxuICAgICAgY29udGVudHMgPSBzLmNvbnRlbnRzLFxuICAgICAgZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cbiAgICAvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xuICAgIHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09ICcqJyApIHtcbiAgICAgIGRhdGFUeXBlcy5zaGlmdCgpO1xuICAgICAgaWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICBjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoICdDb250ZW50LVR5cGUnICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG4gICAgaWYgKCBjdCApIHtcbiAgICAgIGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG4gICAgICAgIGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG4gICAgICAgICAgZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuICAgIGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuICAgICAgZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcbiAgICAgIGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuICAgICAgICBpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyAnICcgKyBkYXRhVHlwZXNbIDAgXSBdICkge1xuICAgICAgICAgIGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG4gICAgICAgICAgZmlyc3REYXRhVHlwZSA9IHR5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG4gICAgICBmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcbiAgICAvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuICAgIC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAgICBpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG4gICAgICBpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuICAgICAgICBkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuICAgIH1cbiAgfVxuXG4gIC8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG4gIGZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcbiAgICB2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcbiAgICAgIGNvbnZlcnRlcnMgPSB7fSxcblxuICAgICAgLy8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuICAgICAgZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuICAgIC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuICAgIGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG4gICAgICBmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcbiAgICAgICAgY29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cbiAgICAvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuICAgIHdoaWxlICggY3VycmVudCApIHtcblxuICAgICAgaWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XG4gICAgICAgIGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuICAgICAgfVxuXG4gICAgICAvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuICAgICAgaWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuICAgICAgICByZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcbiAgICAgIH1cblxuICAgICAgcHJldiA9IGN1cnJlbnQ7XG4gICAgICBjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cbiAgICAgIGlmICggY3VycmVudCApIHtcblxuICAgICAgICAvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG4gICAgICAgIGlmICggY3VycmVudCA9PT0gJyonICkge1xuXG4gICAgICAgICAgY3VycmVudCA9IHByZXY7XG5cbiAgICAgICAgICAvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG4gICAgICAgIH0gZWxzZSBpZiAoIHByZXYgIT09ICcqJyAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG4gICAgICAgICAgLy8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcbiAgICAgICAgICBjb252ID0gY29udmVydGVyc1sgcHJldiArICcgJyArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyAnKiAnICsgY3VycmVudCBdO1xuXG4gICAgICAgICAgLy8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcbiAgICAgICAgICBpZiAoICFjb252ICkge1xuICAgICAgICAgICAgZm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuICAgICAgICAgICAgICAvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcbiAgICAgICAgICAgICAgdG1wID0gY29udjIuc3BsaXQoICcgJyApO1xuICAgICAgICAgICAgICBpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG4gICAgICAgICAgICAgICAgY29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyAnICcgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgJyogJyArIHRtcFsgMCBdIF07XG4gICAgICAgICAgICAgICAgaWYgKCBjb252ICkge1xuXG4gICAgICAgICAgICAgICAgICAvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXG4gICAgICAgICAgICAgICAgICBpZiAoIGNvbnYgPT09IHRydWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0bXBbIDAgXTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcbiAgICAgICAgICBpZiAoIGNvbnYgIT09IHRydWUgKSB7XG5cbiAgICAgICAgICAgIC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cbiAgICAgICAgICAgIGlmICggY29udiAmJiBzLnRocm93cyApIHtcbiAgICAgICAgICAgICAgcmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKCBlICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBzdGF0ZTogJ3BhcnNlcmVycm9yJyxcbiAgICAgICAgICAgICAgICAgIGVycm9yOiBjb252ID8gZSA6ICdObyBjb252ZXJzaW9uIGZyb20gJyArIHByZXYgKyAnIHRvICcgKyBjdXJyZW50XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IHN0YXRlOiAnc3VjY2VzcycsIGRhdGE6IHJlc3BvbnNlIH07XG4gIH1cblxuICBqUXVlcnkuZXh0ZW5kKCB7XG5cbiAgICAvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcbiAgICBhY3RpdmU6IDAsXG5cbiAgICAvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG4gICAgbGFzdE1vZGlmaWVkOiB7fSxcbiAgICBldGFnOiB7fSxcblxuICAgIGFqYXhTZXR0aW5nczoge1xuICAgICAgdXJsOiBsb2NhdGlvbi5ocmVmLFxuICAgICAgdHlwZTogJ0dFVCcsXG4gICAgICBpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBsb2NhdGlvbi5wcm90b2NvbCApLFxuICAgICAgZ2xvYmFsOiB0cnVlLFxuICAgICAgcHJvY2Vzc0RhdGE6IHRydWUsXG4gICAgICBhc3luYzogdHJ1ZSxcbiAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04JyxcblxuICAgICAgLypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuICAgICAgYWNjZXB0czoge1xuICAgICAgICAnKic6IGFsbFR5cGVzLFxuICAgICAgICB0ZXh0OiAndGV4dC9wbGFpbicsXG4gICAgICAgIGh0bWw6ICd0ZXh0L2h0bWwnLFxuICAgICAgICB4bWw6ICdhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sJyxcbiAgICAgICAganNvbjogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdCdcbiAgICAgIH0sXG5cbiAgICAgIGNvbnRlbnRzOiB7XG4gICAgICAgIHhtbDogL1xcYnhtbFxcYi8sXG4gICAgICAgIGh0bWw6IC9cXGJodG1sLyxcbiAgICAgICAganNvbjogL1xcYmpzb25cXGIvXG4gICAgICB9LFxuXG4gICAgICByZXNwb25zZUZpZWxkczoge1xuICAgICAgICB4bWw6ICdyZXNwb25zZVhNTCcsXG4gICAgICAgIHRleHQ6ICdyZXNwb25zZVRleHQnLFxuICAgICAgICBqc29uOiAncmVzcG9uc2VKU09OJ1xuICAgICAgfSxcblxuICAgICAgLy8gRGF0YSBjb252ZXJ0ZXJzXG4gICAgICAvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG4gICAgICBjb252ZXJ0ZXJzOiB7XG5cbiAgICAgICAgLy8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG4gICAgICAgICcqIHRleHQnOiBTdHJpbmcsXG5cbiAgICAgICAgLy8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG4gICAgICAgICd0ZXh0IGh0bWwnOiB0cnVlLFxuXG4gICAgICAgIC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cbiAgICAgICAgJ3RleHQganNvbic6IEpTT04ucGFyc2UsXG5cbiAgICAgICAgLy8gUGFyc2UgdGV4dCBhcyB4bWxcbiAgICAgICAgJ3RleHQgeG1sJzogalF1ZXJ5LnBhcnNlWE1MXG4gICAgICB9LFxuXG4gICAgICAvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuICAgICAgLy8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuICAgICAgLy8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcbiAgICAgIC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuICAgICAgZmxhdE9wdGlvbnM6IHtcbiAgICAgICAgdXJsOiB0cnVlLFxuICAgICAgICBjb250ZXh0OiB0cnVlXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG4gICAgLy8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuICAgIC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG4gICAgYWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcbiAgICAgIHJldHVybiBzZXR0aW5ncyA/XG5cbiAgICAgIC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgIGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcblxuICAgICAgLy8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuICAgICAgICBhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcbiAgICB9LFxuXG4gICAgYWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG4gICAgYWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cbiAgICAvLyBNYWluIG1ldGhvZFxuICAgIGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cbiAgICAgIC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG4gICAgICBpZiAoIHR5cGVvZiB1cmwgPT09ICdvYmplY3QnICkge1xuICAgICAgICBvcHRpb25zID0gdXJsO1xuICAgICAgICB1cmwgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgdmFyIHRyYW5zcG9ydCxcblxuICAgICAgICAvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG4gICAgICAgIGNhY2hlVVJMLFxuXG4gICAgICAgIC8vIFJlc3BvbnNlIGhlYWRlcnNcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuICAgICAgICByZXNwb25zZUhlYWRlcnMsXG5cbiAgICAgICAgLy8gdGltZW91dCBoYW5kbGVcbiAgICAgICAgdGltZW91dFRpbWVyLFxuXG4gICAgICAgIC8vIFVybCBjbGVhbnVwIHZhclxuICAgICAgICB1cmxBbmNob3IsXG5cbiAgICAgICAgLy8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuICAgICAgICBjb21wbGV0ZWQsXG5cbiAgICAgICAgLy8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG4gICAgICAgIGZpcmVHbG9iYWxzLFxuXG4gICAgICAgIC8vIExvb3AgdmFyaWFibGVcbiAgICAgICAgaSxcblxuICAgICAgICAvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcbiAgICAgICAgdW5jYWNoZWQsXG5cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuICAgICAgICBzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuICAgICAgICAvLyBDYWxsYmFja3MgY29udGV4dFxuICAgICAgICBjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcblxuICAgICAgICAvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG4gICAgICAgIGdsb2JhbEV2ZW50Q29udGV4dCA9IHMuY29udGV4dCAmJlxuXHRcdFx0XHQoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xuICAgICAgICAgIGpRdWVyeSggY2FsbGJhY2tDb250ZXh0ICkgOlxuICAgICAgICAgIGpRdWVyeS5ldmVudCxcblxuICAgICAgICAvLyBEZWZlcnJlZHNcbiAgICAgICAgZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcbiAgICAgICAgY29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoICdvbmNlIG1lbW9yeScgKSxcblxuICAgICAgICAvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuICAgICAgICBzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXG4gICAgICAgIC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG4gICAgICAgIHJlcXVlc3RIZWFkZXJzID0ge30sXG4gICAgICAgIHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblxuICAgICAgICAvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2VcbiAgICAgICAgc3RyQWJvcnQgPSAnY2FuY2VsZWQnLFxuXG4gICAgICAgIC8vIEZha2UgeGhyXG4gICAgICAgIGpxWEhSID0ge1xuICAgICAgICAgIHJlYWR5U3RhdGU6IDAsXG5cbiAgICAgICAgICAvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG4gICAgICAgICAgZ2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgICAgICBpZiAoIGNvbXBsZXRlZCApIHtcbiAgICAgICAgICAgICAgaWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgICAgIHdoaWxlICggKCBtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApICkgKSB7XG4gICAgICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSBdID0gbWF0Y2hbIDIgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaDtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLy8gUmF3IHN0cmluZ1xuICAgICAgICAgIGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGxldGVkID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLy8gQ2FjaGVzIHRoZSBoZWFkZXJcbiAgICAgICAgICBzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG4gICAgICAgICAgICBpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuICAgICAgICAgICAgICBuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gPVxuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fCBuYW1lO1xuICAgICAgICAgICAgICByZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLy8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcbiAgICAgICAgICBvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcbiAgICAgICAgICAgIGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG4gICAgICAgICAgICAgIHMubWltZVR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG4gICAgICAgICAgc3RhdHVzQ29kZTogZnVuY3Rpb24oIG1hcCApIHtcbiAgICAgICAgICAgIHZhciBjb2RlO1xuICAgICAgICAgICAgaWYgKCBtYXAgKSB7XG4gICAgICAgICAgICAgIGlmICggY29tcGxldGVkICkge1xuXG4gICAgICAgICAgICAgICAgLy8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG4gICAgICAgICAgICAgICAganFYSFIuYWx3YXlzKCBtYXBbIGpxWEhSLnN0YXR1cyBdICk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuICAgICAgICAgICAgICAgIGZvciAoIGNvZGUgaW4gbWFwICkge1xuICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLy8gQ2FuY2VsIHRoZSByZXF1ZXN0XG4gICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuICAgICAgICAgICAgdmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XG4gICAgICAgICAgICBpZiAoIHRyYW5zcG9ydCApIHtcbiAgICAgICAgICAgICAgdHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAvLyBBdHRhY2ggZGVmZXJyZWRzXG4gICAgICBkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApO1xuXG4gICAgICAvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcbiAgICAgIC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG4gICAgICAvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcbiAgICAgIHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyAnJyApXG4gICAgICAgIC5yZXBsYWNlKCBycHJvdG9jb2wsIGxvY2F0aW9uLnByb3RvY29sICsgJy8vJyApO1xuXG4gICAgICAvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcbiAgICAgIHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cbiAgICAgIC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3RcbiAgICAgIHMuZGF0YVR5cGVzID0gKCBzLmRhdGFUeXBlIHx8ICcqJyApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbICcnIF07XG5cbiAgICAgIC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB0aGUgb3JpZ2luIGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnQgb3JpZ2luLlxuICAgICAgaWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG4gICAgICAgIHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdhJyApO1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTVcbiAgICAgICAgLy8gSUUgdGhyb3dzIGV4Y2VwdGlvbiBvbiBhY2Nlc3NpbmcgdGhlIGhyZWYgcHJvcGVydHkgaWYgdXJsIGlzIG1hbGZvcm1lZCxcbiAgICAgICAgLy8gZS5nLiBodHRwOi8vZXhhbXBsZS5jb206ODB4L1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHVybEFuY2hvci5ocmVmID0gcy51cmw7XG5cbiAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSBvbmx5XG4gICAgICAgICAgLy8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcbiAgICAgICAgICB1cmxBbmNob3IuaHJlZiA9IHVybEFuY2hvci5ocmVmO1xuICAgICAgICAgIHMuY3Jvc3NEb21haW4gPSBvcmlnaW5BbmNob3IucHJvdG9jb2wgKyAnLy8nICsgb3JpZ2luQW5jaG9yLmhvc3QgIT09XG5cdFx0XHRcdFx0dXJsQW5jaG9yLnByb3RvY29sICsgJy8vJyArIHVybEFuY2hvci5ob3N0O1xuICAgICAgICB9IGNhdGNoICggZSApIHtcblxuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHBhcnNpbmcgdGhlIFVSTCwgYXNzdW1lIGl0IGlzIGNyb3NzRG9tYWluLFxuICAgICAgICAgIC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcbiAgICAgICAgICBzLmNyb3NzRG9tYWluID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcbiAgICAgIGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gJ3N0cmluZycgKSB7XG4gICAgICAgIHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFwcGx5IHByZWZpbHRlcnNcbiAgICAgIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG4gICAgICAvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuICAgICAgaWYgKCBjb21wbGV0ZWQgKSB7XG4gICAgICAgIHJldHVybiBqcVhIUjtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cbiAgICAgIC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG4gICAgICBmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuICAgICAgLy8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuICAgICAgaWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG4gICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyKCAnYWpheFN0YXJ0JyApO1xuICAgICAgfVxuXG4gICAgICAvLyBVcHBlcmNhc2UgdGhlIHR5cGVcbiAgICAgIHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuICAgICAgcy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XG5cbiAgICAgIC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuICAgICAgLy8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG4gICAgICAvLyBSZW1vdmUgaGFzaCB0byBzaW1wbGlmeSB1cmwgbWFuaXB1bGF0aW9uXG4gICAgICBjYWNoZVVSTCA9IHMudXJsLnJlcGxhY2UoIHJoYXNoLCAnJyApO1xuXG4gICAgICAvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuICAgICAgaWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG4gICAgICAgIC8vIFJlbWVtYmVyIHRoZSBoYXNoIHNvIHdlIGNhbiBwdXQgaXQgYmFja1xuICAgICAgICB1bmNhY2hlZCA9IHMudXJsLnNsaWNlKCBjYWNoZVVSTC5sZW5ndGggKTtcblxuICAgICAgICAvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZCwgYXBwZW5kIGRhdGEgdG8gdXJsXG4gICAgICAgIGlmICggcy5kYXRhICYmICggcy5wcm9jZXNzRGF0YSB8fCB0eXBlb2Ygcy5kYXRhID09PSAnc3RyaW5nJyApICkge1xuICAgICAgICAgIGNhY2hlVVJMICs9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyAnJicgOiAnPycgKSArIHMuZGF0YTtcblxuICAgICAgICAgIC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcbiAgICAgICAgICBkZWxldGUgcy5kYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIG9yIHVwZGF0ZSBhbnRpLWNhY2hlIHBhcmFtIGlmIG5lZWRlZFxuICAgICAgICBpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuICAgICAgICAgIGNhY2hlVVJMID0gY2FjaGVVUkwucmVwbGFjZSggcmFudGlDYWNoZSwgJyQxJyApO1xuICAgICAgICAgIHVuY2FjaGVkID0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/ICcmJyA6ICc/JyApICsgJ189JyArICggbm9uY2UrKyApICsgdW5jYWNoZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQdXQgaGFzaCBhbmQgYW50aS1jYWNoZSBvbiB0aGUgVVJMIHRoYXQgd2lsbCBiZSByZXF1ZXN0ZWQgKGdoLTE3MzIpXG4gICAgICAgIHMudXJsID0gY2FjaGVVUkwgKyB1bmNhY2hlZDtcblxuICAgICAgICAvLyBDaGFuZ2UgJyUyMCcgdG8gJysnIGlmIHRoaXMgaXMgZW5jb2RlZCBmb3JtIGJvZHkgY29udGVudCAoZ2gtMjY1OClcbiAgICAgIH0gZWxzZSBpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmXG5cdFx0XHQoIHMuY29udGVudFR5cGUgfHwgJycgKS5pbmRleE9mKCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyApID09PSAwICkge1xuICAgICAgICBzLmRhdGEgPSBzLmRhdGEucmVwbGFjZSggcjIwLCAnKycgKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cbiAgICAgIGlmICggcy5pZk1vZGlmaWVkICkge1xuICAgICAgICBpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG4gICAgICAgICAganFYSFIuc2V0UmVxdWVzdEhlYWRlciggJ0lmLU1vZGlmaWVkLVNpbmNlJywgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuICAgICAgICB9XG4gICAgICAgIGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG4gICAgICAgICAganFYSFIuc2V0UmVxdWVzdEhlYWRlciggJ0lmLU5vbmUtTWF0Y2gnLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuICAgICAgaWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG4gICAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoICdDb250ZW50LVR5cGUnLCBzLmNvbnRlbnRUeXBlICk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcbiAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG4gICAgICAgICdBY2NlcHQnLFxuICAgICAgICBzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdID9cbiAgICAgICAgICBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSAnKicgPyAnLCAnICsgYWxsVHlwZXMgKyAnOyBxPTAuMDEnIDogJycgKSA6XG4gICAgICAgICAgcy5hY2NlcHRzWyAnKicgXVxuICAgICAgKTtcblxuICAgICAgLy8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG4gICAgICBmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcbiAgICAgICAganFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuICAgICAgaWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgY29tcGxldGVkICkgKSB7XG5cbiAgICAgICAgLy8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG4gICAgICAgIHJldHVybiBqcVhIUi5hYm9ydCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cbiAgICAgIHN0ckFib3J0ID0gJ2Fib3J0JztcblxuICAgICAgLy8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG4gICAgICBjb21wbGV0ZURlZmVycmVkLmFkZCggcy5jb21wbGV0ZSApO1xuICAgICAganFYSFIuZG9uZSggcy5zdWNjZXNzICk7XG4gICAgICBqcVhIUi5mYWlsKCBzLmVycm9yICk7XG5cbiAgICAgIC8vIEdldCB0cmFuc3BvcnRcbiAgICAgIHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG4gICAgICAvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcbiAgICAgIGlmICggIXRyYW5zcG9ydCApIHtcbiAgICAgICAgZG9uZSggLTEsICdObyBUcmFuc3BvcnQnICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuICAgICAgICAvLyBTZW5kIGdsb2JhbCBldmVudFxuICAgICAgICBpZiAoIGZpcmVHbG9iYWxzICkge1xuICAgICAgICAgIGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCAnYWpheFNlbmQnLCBbIGpxWEhSLCBzIF0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG4gICAgICAgIGlmICggY29tcGxldGVkICkge1xuICAgICAgICAgIHJldHVybiBqcVhIUjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRpbWVvdXRcbiAgICAgICAgaWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG4gICAgICAgICAgdGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAganFYSFIuYWJvcnQoICd0aW1lb3V0JyApO1xuICAgICAgICAgIH0sIHMudGltZW91dCApO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcbiAgICAgICAgfSBjYXRjaCAoIGUgKSB7XG5cbiAgICAgICAgICAvLyBSZXRocm93IHBvc3QtY29tcGxldGlvbiBleGNlcHRpb25zXG4gICAgICAgICAgaWYgKCBjb21wbGV0ZWQgKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFByb3BhZ2F0ZSBvdGhlcnMgYXMgcmVzdWx0c1xuICAgICAgICAgIGRvbmUoIC0xLCBlICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG4gICAgICBmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcbiAgICAgICAgdmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcbiAgICAgICAgICBzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuICAgICAgICAvLyBJZ25vcmUgcmVwZWF0IGludm9jYXRpb25zXG4gICAgICAgIGlmICggY29tcGxldGVkICkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBsZXRlZCA9IHRydWU7XG5cbiAgICAgICAgLy8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcbiAgICAgICAgaWYgKCB0aW1lb3V0VGltZXIgKSB7XG4gICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuICAgICAgICAvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuICAgICAgICB0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuICAgICAgICByZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8ICcnO1xuXG4gICAgICAgIC8vIFNldCByZWFkeVN0YXRlXG4gICAgICAgIGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcbiAgICAgICAgaXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cbiAgICAgICAgLy8gR2V0IHJlc3BvbnNlIGRhdGFcbiAgICAgICAgaWYgKCByZXNwb25zZXMgKSB7XG4gICAgICAgICAgcmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG4gICAgICAgIHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XG5cbiAgICAgICAgLy8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcbiAgICAgICAgaWYgKCBpc1N1Y2Nlc3MgKSB7XG5cbiAgICAgICAgICAvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuICAgICAgICAgIGlmICggcy5pZk1vZGlmaWVkICkge1xuICAgICAgICAgICAgbW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggJ0xhc3QtTW9kaWZpZWQnICk7XG4gICAgICAgICAgICBpZiAoIG1vZGlmaWVkICkge1xuICAgICAgICAgICAgICBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCAnZXRhZycgKTtcbiAgICAgICAgICAgIGlmICggbW9kaWZpZWQgKSB7XG4gICAgICAgICAgICAgIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgbm8gY29udGVudFxuICAgICAgICAgIGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSAnSEVBRCcgKSB7XG4gICAgICAgICAgICBzdGF0dXNUZXh0ID0gJ25vY29udGVudCc7XG5cbiAgICAgICAgICAgIC8vIGlmIG5vdCBtb2RpZmllZFxuICAgICAgICAgIH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xuICAgICAgICAgICAgc3RhdHVzVGV4dCA9ICdub3Rtb2RpZmllZCc7XG5cbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG4gICAgICAgICAgICBzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICAgIGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG4gICAgICAgICAgICBpc1N1Y2Nlc3MgPSAhZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgLy8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuICAgICAgICAgIGVycm9yID0gc3RhdHVzVGV4dDtcbiAgICAgICAgICBpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcbiAgICAgICAgICAgIHN0YXR1c1RleHQgPSAnZXJyb3InO1xuICAgICAgICAgICAgaWYgKCBzdGF0dXMgPCAwICkge1xuICAgICAgICAgICAgICBzdGF0dXMgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG4gICAgICAgIGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAganFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyAnJztcblxuICAgICAgICAvLyBTdWNjZXNzL0Vycm9yXG4gICAgICAgIGlmICggaXNTdWNjZXNzICkge1xuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3NcbiAgICAgICAganFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xuICAgICAgICBzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmICggZmlyZUdsb2JhbHMgKSB7XG4gICAgICAgICAgZ2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/ICdhamF4U3VjY2VzcycgOiAnYWpheEVycm9yJyxcbiAgICAgICAgICAgIFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21wbGV0ZVxuICAgICAgICBjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG4gICAgICAgIGlmICggZmlyZUdsb2JhbHMgKSB7XG4gICAgICAgICAgZ2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoICdhamF4Q29tcGxldGUnLCBbIGpxWEhSLCBzIF0gKTtcblxuICAgICAgICAgIC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuICAgICAgICAgIGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG4gICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlciggJ2FqYXhTdG9wJyApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ganFYSFI7XG4gICAgfSxcblxuICAgIGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuICAgICAgcmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssICdqc29uJyApO1xuICAgIH0sXG5cbiAgICBnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuICAgICAgcmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgJ3NjcmlwdCcgKTtcbiAgICB9XG4gIH0gKTtcblxuICBqUXVlcnkuZWFjaCggWyAnZ2V0JywgJ3Bvc3QnIF0sIGZ1bmN0aW9uKCBpLCBtZXRob2QgKSB7XG4gICAgalF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXG4gICAgICAvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuICAgICAgaWYgKCBpc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG4gICAgICAgIHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuICAgICAgICBjYWxsYmFjayA9IGRhdGE7XG4gICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuICAgICAgcmV0dXJuIGpRdWVyeS5hamF4KCBqUXVlcnkuZXh0ZW5kKCB7XG4gICAgICAgIHVybDogdXJsLFxuICAgICAgICB0eXBlOiBtZXRob2QsXG4gICAgICAgIGRhdGFUeXBlOiB0eXBlLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBzdWNjZXNzOiBjYWxsYmFja1xuICAgICAgfSwgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHVybCApICYmIHVybCApICk7XG4gICAgfTtcbiAgfSApO1xuXG5cbiAgalF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCApIHtcbiAgICByZXR1cm4galF1ZXJ5LmFqYXgoIHtcbiAgICAgIHVybDogdXJsLFxuXG4gICAgICAvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKCMxMTI2NClcbiAgICAgIHR5cGU6ICdHRVQnLFxuICAgICAgZGF0YVR5cGU6ICdzY3JpcHQnLFxuICAgICAgY2FjaGU6IHRydWUsXG4gICAgICBhc3luYzogZmFsc2UsXG4gICAgICBnbG9iYWw6IGZhbHNlLFxuICAgICAgJ3Rocm93cyc6IHRydWVcbiAgICB9ICk7XG4gIH07XG5cblxuICBqUXVlcnkuZm4uZXh0ZW5kKCB7XG4gICAgd3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG4gICAgICB2YXIgd3JhcDtcblxuICAgICAgaWYgKCB0aGlzWyAwIF0gKSB7XG4gICAgICAgIGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuICAgICAgICAgIGh0bWwgPSBodG1sLmNhbGwoIHRoaXNbIDAgXSApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcbiAgICAgICAgd3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cbiAgICAgICAgaWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcbiAgICAgICAgICB3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG4gICAgICAgIH1cblxuICAgICAgICB3cmFwLm1hcCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGVsZW0gPSB0aGlzO1xuXG4gICAgICAgICAgd2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuICAgICAgICAgICAgZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgICAgIH0gKS5hcHBlbmQoIHRoaXMgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG4gICAgICBpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG4gICAgICAgICAgalF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuICAgICAgICB9ICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuICAgICAgICAgIGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG4gICAgICAgIGlmICggY29udGVudHMubGVuZ3RoICkge1xuICAgICAgICAgIGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuYXBwZW5kKCBodG1sICk7XG4gICAgICAgIH1cbiAgICAgIH0gKTtcbiAgICB9LFxuXG4gICAgd3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG4gICAgICB2YXIgaHRtbElzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCBodG1sICk7XG5cbiAgICAgIHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuICAgICAgICBqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBodG1sSXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xuICAgICAgfSApO1xuICAgIH0sXG5cbiAgICB1bndyYXA6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcbiAgICAgIHRoaXMucGFyZW50KCBzZWxlY3RvciApLm5vdCggJ2JvZHknICkuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgIGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcbiAgICAgIH0gKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSApO1xuXG5cbiAgalF1ZXJ5LmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgICByZXR1cm4gIWpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSggZWxlbSApO1xuICB9O1xuICBqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgICByZXR1cm4gISEoIGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApO1xuICB9O1xuXG5cblxuXG4gIGpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfSBjYXRjaCAoIGUgKSB7fVxuICB9O1xuXG4gIHZhciB4aHJTdWNjZXNzU3RhdHVzID0ge1xuXG4gICAgICAvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuICAgICAgMDogMjAwLFxuXG4gICAgICAvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuICAgICAgLy8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG4gICAgICAxMjIzOiAyMDRcbiAgICB9LFxuICAgIHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbiAgc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCAnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHJTdXBwb3J0ZWQgKTtcbiAgc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbiAgalF1ZXJ5LmFqYXhUcmFuc3BvcnQoIGZ1bmN0aW9uKCBvcHRpb25zICkge1xuICAgIHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcblxuICAgIC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3RcbiAgICBpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG4gICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICB4aHIgPSBvcHRpb25zLnhocigpO1xuXG4gICAgICAgICAgeGhyLm9wZW4oXG4gICAgICAgICAgICBvcHRpb25zLnR5cGUsXG4gICAgICAgICAgICBvcHRpb25zLnVybCxcbiAgICAgICAgICAgIG9wdGlvbnMuYXN5bmMsXG4gICAgICAgICAgICBvcHRpb25zLnVzZXJuYW1lLFxuICAgICAgICAgICAgb3B0aW9ucy5wYXNzd29yZFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG4gICAgICAgICAgaWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcbiAgICAgICAgICAgIGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG4gICAgICAgICAgICAgIHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG4gICAgICAgICAgaWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuICAgICAgICAgICAgeGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuICAgICAgICAgIC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcbiAgICAgICAgICAvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuICAgICAgICAgIC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuICAgICAgICAgIC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuICAgICAgICAgIGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbICdYLVJlcXVlc3RlZC1XaXRoJyBdICkge1xuICAgICAgICAgICAgaGVhZGVyc1sgJ1gtUmVxdWVzdGVkLVdpdGgnIF0gPSAnWE1MSHR0cFJlcXVlc3QnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNldCBoZWFkZXJzXG4gICAgICAgICAgZm9yICggaSBpbiBoZWFkZXJzICkge1xuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENhbGxiYWNrXG4gICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGVycm9yQ2FsbGJhY2sgPSB4aHIub25sb2FkID1cblx0XHRcdFx0XHRcdFx0XHR4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9udGltZW91dCA9XG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmICggdHlwZSA9PT0gJ2Fib3J0JyApIHtcbiAgICAgICAgICAgICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHR5cGUgPT09ICdlcnJvcicgKSB7XG5cbiAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4gICAgICAgICAgICAgICAgICAvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3NcbiAgICAgICAgICAgICAgICAgIC8vIGVycm9ycyBvbiBhbnkgcHJvcGVydHkgYWNjZXNzIHRoYXQgaXMgbm90IHJlYWR5U3RhdGVcbiAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09ICdudW1iZXInICkge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZSggMCwgJ2Vycm9yJyApO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGUoXG5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xuICAgICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1c1RleHRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29tcGxldGUoXG4gICAgICAgICAgICAgICAgICAgIHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzVGV4dCxcblxuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuICAgICAgICAgICAgICAgICAgICAvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG4gICAgICAgICAgICAgICAgICAgICggeGhyLnJlc3BvbnNlVHlwZSB8fCAndGV4dCcgKSAhPT0gJ3RleHQnIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gJ3N0cmluZycgP1xuICAgICAgICAgICAgICAgICAgICAgIHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XG4gICAgICAgICAgICAgICAgICAgICAgeyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXG4gICAgICAgICAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIExpc3RlbiB0byBldmVudHNcbiAgICAgICAgICB4aHIub25sb2FkID0gY2FsbGJhY2soKTtcbiAgICAgICAgICBlcnJvckNhbGxiYWNrID0geGhyLm9uZXJyb3IgPSB4aHIub250aW1lb3V0ID0gY2FsbGJhY2soICdlcnJvcicgKTtcblxuICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgb25seVxuICAgICAgICAgIC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG4gICAgICAgICAgLy8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuICAgICAgICAgIGlmICggeGhyLm9uYWJvcnQgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgIC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuICAgICAgICAgICAgICBpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG4gICAgICAgICAgICAgICAgLy8gQWxsb3cgb25lcnJvciB0byBiZSBjYWxsZWQgZmlyc3QsXG4gICAgICAgICAgICAgICAgLy8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG4gICAgICAgICAgICAgICAgLy8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcbiAgICAgICAgICAgICAgICAvLyBhcyB4aHIub25lcnJvciBjYW5ub3QgYmUgYWNjZXNzZWRcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIGNhbGxiYWNrICkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcbiAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrKCAnYWJvcnQnICk7XG5cbiAgICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICAvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG4gICAgICAgICAgICB4aHIuc2VuZCggb3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsICk7XG4gICAgICAgICAgfSBjYXRjaCAoIGUgKSB7XG5cbiAgICAgICAgICAgIC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG4gICAgICAgICAgICBpZiAoIGNhbGxiYWNrICkge1xuICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhYm9ydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSApO1xuXG5cblxuXG4gIC8vIFByZXZlbnQgYXV0by1leGVjdXRpb24gb2Ygc2NyaXB0cyB3aGVuIG5vIGV4cGxpY2l0IGRhdGFUeXBlIHdhcyBwcm92aWRlZCAoU2VlIGdoLTI0MzIpXG4gIGpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcbiAgICBpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG4gICAgICBzLmNvbnRlbnRzLnNjcmlwdCA9IGZhbHNlO1xuICAgIH1cbiAgfSApO1xuXG4gIC8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG4gIGpRdWVyeS5hamF4U2V0dXAoIHtcbiAgICBhY2NlcHRzOiB7XG4gICAgICBzY3JpcHQ6ICd0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsICcgK1xuXHRcdFx0J2FwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdCdcbiAgICB9LFxuICAgIGNvbnRlbnRzOiB7XG4gICAgICBzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuICAgIH0sXG4gICAgY29udmVydGVyczoge1xuICAgICAgJ3RleHQgc2NyaXB0JzogZnVuY3Rpb24oIHRleHQgKSB7XG4gICAgICAgIGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgfVxuICAgIH1cbiAgfSApO1xuXG4gIC8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbiAgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIoICdzY3JpcHQnLCBmdW5jdGlvbiggcyApIHtcbiAgICBpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgIHMuY2FjaGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCBzLmNyb3NzRG9tYWluICkge1xuICAgICAgcy50eXBlID0gJ0dFVCc7XG4gICAgfVxuICB9ICk7XG5cbiAgLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG4gIGpRdWVyeS5hamF4VHJhbnNwb3J0KCAnc2NyaXB0JywgZnVuY3Rpb24oIHMgKSB7XG5cbiAgICAvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIHJlcXVlc3RzXG4gICAgaWYgKCBzLmNyb3NzRG9tYWluICkge1xuICAgICAgdmFyIHNjcmlwdCwgY2FsbGJhY2s7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG4gICAgICAgICAgc2NyaXB0ID0galF1ZXJ5KCAnPHNjcmlwdD4nICkucHJvcCgge1xuICAgICAgICAgICAgY2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LFxuICAgICAgICAgICAgc3JjOiBzLnVybFxuICAgICAgICAgIH0gKS5vbihcbiAgICAgICAgICAgICdsb2FkIGVycm9yJyxcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcbiAgICAgICAgICAgICAgc2NyaXB0LnJlbW92ZSgpO1xuICAgICAgICAgICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgICAgIGlmICggZXZ0ICkge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlKCBldnQudHlwZSA9PT0gJ2Vycm9yJyA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcbiAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuICAgICAgICB9LFxuICAgICAgICBhYm9ydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSApO1xuXG5cblxuXG4gIHZhciBvbGRDYWxsYmFja3MgPSBbXSxcbiAgICByanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4gIC8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbiAgalF1ZXJ5LmFqYXhTZXR1cCgge1xuICAgIGpzb25wOiAnY2FsbGJhY2snLFxuICAgIGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyAnXycgKyAoIG5vbmNlKysgKSApO1xuICAgICAgdGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG4gICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgfVxuICB9ICk7XG5cbiAgLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG4gIGpRdWVyeS5hamF4UHJlZmlsdGVyKCAnanNvbiBqc29ucCcsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuICAgIHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcbiAgICAgIGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/XG4gICAgICAgICd1cmwnIDpcbiAgICAgICAgdHlwZW9mIHMuZGF0YSA9PT0gJ3N0cmluZycgJiZcblx0XHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8ICcnIClcblx0XHRcdFx0ICAuaW5kZXhPZiggJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcgKSA9PT0gMCAmJlxuXHRcdFx0XHRyanNvbnAudGVzdCggcy5kYXRhICkgJiYgJ2RhdGEnXG4gICAgICApO1xuXG4gICAgLy8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuICAgIGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gJ2pzb25wJyApIHtcblxuICAgICAgLy8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuICAgICAgY2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0gaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuICAgICAgICBzLmpzb25wQ2FsbGJhY2soKSA6XG4gICAgICAgIHMuanNvbnBDYWxsYmFjaztcblxuICAgICAgLy8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuICAgICAgaWYgKCBqc29uUHJvcCApIHtcbiAgICAgICAgc1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCAnJDEnICsgY2FsbGJhY2tOYW1lICk7XG4gICAgICB9IGVsc2UgaWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcbiAgICAgICAgcy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/ICcmJyA6ICc/JyApICsgcy5qc29ucCArICc9JyArIGNhbGxiYWNrTmFtZTtcbiAgICAgIH1cblxuICAgICAgLy8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuICAgICAgcy5jb252ZXJ0ZXJzWyAnc2NyaXB0IGpzb24nIF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG4gICAgICAgICAgalF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyAnIHdhcyBub3QgY2FsbGVkJyApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuICAgICAgfTtcblxuICAgICAgLy8gRm9yY2UganNvbiBkYXRhVHlwZVxuICAgICAgcy5kYXRhVHlwZXNbIDAgXSA9ICdqc29uJztcblxuICAgICAgLy8gSW5zdGFsbCBjYWxsYmFja1xuICAgICAgb3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuICAgICAgd2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcbiAgICAgIH07XG5cbiAgICAgIC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuICAgICAganFYSFIuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcbiAgICAgICAgaWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgIGpRdWVyeSggd2luZG93ICkucmVtb3ZlUHJvcCggY2FsbGJhY2tOYW1lICk7XG5cbiAgICAgICAgICAvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNhdmUgYmFjayBhcyBmcmVlXG4gICAgICAgIGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcbiAgICAgICAgICBzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XG5cbiAgICAgICAgICAvLyBTYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG4gICAgICAgICAgb2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG4gICAgICAgIGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcbiAgICAgICAgICBvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcbiAgICAgIH0gKTtcblxuICAgICAgLy8gRGVsZWdhdGUgdG8gc2NyaXB0XG4gICAgICByZXR1cm4gJ3NjcmlwdCc7XG4gICAgfVxuICB9ICk7XG5cblxuXG5cbiAgLy8gU3VwcG9ydDogU2FmYXJpIDggb25seVxuICAvLyBJbiBTYWZhcmkgOCBkb2N1bWVudHMgY3JlYXRlZCB2aWEgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50XG4gIC8vIGNvbGxhcHNlIHNpYmxpbmcgZm9ybXM6IHRoZSBzZWNvbmQgb25lIGJlY29tZXMgYSBjaGlsZCBvZiB0aGUgZmlyc3Qgb25lLlxuICAvLyBCZWNhdXNlIG9mIHRoYXQsIHRoaXMgc2VjdXJpdHkgbWVhc3VyZSBoYXMgdG8gYmUgZGlzYWJsZWQgaW4gU2FmYXJpIDguXG4gIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzczMzdcbiAgc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoIGZ1bmN0aW9uKCkge1xuICAgIHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCAnJyApLmJvZHk7XG4gICAgYm9keS5pbm5lckhUTUwgPSAnPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT4nO1xuICAgIHJldHVybiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyO1xuICB9ICkoKTtcblxuXG4gIC8vIEFyZ3VtZW50IFwiZGF0YVwiIHNob3VsZCBiZSBzdHJpbmcgb2YgaHRtbFxuICAvLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXG4gIC8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4gIC8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcbiAgalF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcbiAgICBpZiAoIHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJyApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKCB0eXBlb2YgY29udGV4dCA9PT0gJ2Jvb2xlYW4nICkge1xuICAgICAga2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuICAgICAgY29udGV4dCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XG5cbiAgICBpZiAoICFjb250ZXh0ICkge1xuXG4gICAgICAvLyBTdG9wIHNjcmlwdHMgb3IgaW5saW5lIGV2ZW50IGhhbmRsZXJzIGZyb20gYmVpbmcgZXhlY3V0ZWQgaW1tZWRpYXRlbHlcbiAgICAgIC8vIGJ5IHVzaW5nIGRvY3VtZW50LmltcGxlbWVudGF0aW9uXG4gICAgICBpZiAoIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ICkge1xuICAgICAgICBjb250ZXh0ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCAnJyApO1xuXG4gICAgICAgIC8vIFNldCB0aGUgYmFzZSBocmVmIGZvciB0aGUgY3JlYXRlZCBkb2N1bWVudFxuICAgICAgICAvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xuICAgICAgICAvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxuICAgICAgICBiYXNlID0gY29udGV4dC5jcmVhdGVFbGVtZW50KCAnYmFzZScgKTtcbiAgICAgICAgYmFzZS5ocmVmID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcbiAgICAgICAgY29udGV4dC5oZWFkLmFwcGVuZENoaWxkKCBiYXNlICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0ID0gZG9jdW1lbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICk7XG4gICAgc2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuICAgIC8vIFNpbmdsZSB0YWdcbiAgICBpZiAoIHBhcnNlZCApIHtcbiAgICAgIHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuICAgIH1cblxuICAgIHBhcnNlZCA9IGJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cbiAgICBpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG4gICAgICBqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbiAgfTtcblxuXG4gIC8qKlxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICovXG4gIGpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcbiAgICB2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICBvZmYgPSB1cmwuaW5kZXhPZiggJyAnICk7XG5cbiAgICBpZiAoIG9mZiA+IC0xICkge1xuICAgICAgc2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKCB1cmwuc2xpY2UoIG9mZiApICk7XG4gICAgICB1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuICAgIH1cblxuICAgIC8vIElmIGl0J3MgYSBmdW5jdGlvblxuICAgIGlmICggaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cbiAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG4gICAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICAgIHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuICAgICAgLy8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuICAgIH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSAnb2JqZWN0JyApIHtcbiAgICAgIHR5cGUgPSAnUE9TVCc7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3RcbiAgICBpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcbiAgICAgIGpRdWVyeS5hamF4KCB7XG4gICAgICAgIHVybDogdXJsLFxuXG4gICAgICAgIC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG4gICAgICAgIC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuICAgICAgICAvLyB1c2VyIGNhbiBvdmVycmlkZSBpdCB0aHJvdWdoIGFqYXhTZXR1cCBtZXRob2RcbiAgICAgICAgdHlwZTogdHlwZSB8fCAnR0VUJyxcbiAgICAgICAgZGF0YVR5cGU6ICdodG1sJyxcbiAgICAgICAgZGF0YTogcGFyYW1zXG4gICAgICB9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcblxuICAgICAgICAvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcbiAgICAgICAgcmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgc2VsZi5odG1sKCBzZWxlY3RvciA/XG5cbiAgICAgICAgLy8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG4gICAgICAgIC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuICAgICAgICAgIGpRdWVyeSggJzxkaXY+JyApLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuICAgICAgICAvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuICAgICAgICAgIHJlc3BvbnNlVGV4dCApO1xuXG4gICAgICAgIC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxuICAgICAgICAvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG4gICAgICAgIC8vIElmIGl0IGZhaWxzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJqcVhIUlwiLCBcInN0YXR1c1wiLCBcImVycm9yXCJcbiAgICAgIH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuICAgICAgICBzZWxmLmVhY2goIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KCB0aGlzLCByZXNwb25zZSB8fCBbIGpxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdICk7XG4gICAgICAgIH0gKTtcbiAgICAgIH0gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG5cblxuICAvLyBBdHRhY2ggYSBidW5jaCBvZiBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGNvbW1vbiBBSkFYIGV2ZW50c1xuICBqUXVlcnkuZWFjaCggW1xuICAgICdhamF4U3RhcnQnLFxuICAgICdhamF4U3RvcCcsXG4gICAgJ2FqYXhDb21wbGV0ZScsXG4gICAgJ2FqYXhFcnJvcicsXG4gICAgJ2FqYXhTdWNjZXNzJyxcbiAgICAnYWpheFNlbmQnXG4gIF0sIGZ1bmN0aW9uKCBpLCB0eXBlICkge1xuICAgIGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuICAgICAgcmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG4gICAgfTtcbiAgfSApO1xuXG5cblxuXG4gIGpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgICByZXR1cm4galF1ZXJ5LmdyZXAoIGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcbiAgICAgIHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuICAgIH0gKS5sZW5ndGg7XG4gIH07XG5cblxuXG5cbiAgalF1ZXJ5Lm9mZnNldCA9IHtcbiAgICBzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuICAgICAgdmFyIGN1clBvc2l0aW9uLCBjdXJMZWZ0LCBjdXJDU1NUb3AsIGN1clRvcCwgY3VyT2Zmc2V0LCBjdXJDU1NMZWZ0LCBjYWxjdWxhdGVQb3NpdGlvbixcbiAgICAgICAgcG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCAncG9zaXRpb24nICksXG4gICAgICAgIGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcbiAgICAgICAgcHJvcHMgPSB7fTtcblxuICAgICAgLy8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuICAgICAgaWYgKCBwb3NpdGlvbiA9PT0gJ3N0YXRpYycgKSB7XG4gICAgICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgfVxuXG4gICAgICBjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuICAgICAgY3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgJ3RvcCcgKTtcbiAgICAgIGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKCBlbGVtLCAnbGVmdCcgKTtcbiAgICAgIGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gJ2Fic29sdXRlJyB8fCBwb3NpdGlvbiA9PT0gJ2ZpeGVkJyApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCAnYXV0bycgKSA+IC0xO1xuXG4gICAgICAvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuICAgICAgLy8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG4gICAgICBpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuICAgICAgICBjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcbiAgICAgICAgY3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuICAgICAgICBjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcbiAgICAgICAgY3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoIGlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuICAgICAgICAvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgalF1ZXJ5LmV4dGVuZCgge30sIGN1ck9mZnNldCApICk7XG4gICAgICB9XG5cbiAgICAgIGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcbiAgICAgICAgcHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcbiAgICAgIH1cbiAgICAgIGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG4gICAgICAgIHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuICAgICAgfVxuXG4gICAgICBpZiAoICd1c2luZycgaW4gb3B0aW9ucyApIHtcbiAgICAgICAgb3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJFbGVtLmNzcyggcHJvcHMgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgalF1ZXJ5LmZuLmV4dGVuZCgge1xuXG4gICAgLy8gb2Zmc2V0KCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgYm9yZGVyIGJveCB0byB0aGUgZG9jdW1lbnQgb3JpZ2luXG4gICAgb2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuICAgICAgLy8gUHJlc2VydmUgY2hhaW5pbmcgZm9yIHNldHRlclxuICAgICAgaWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICB0aGlzIDpcbiAgICAgICAgICB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuICAgICAgICAgICAgalF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcbiAgICAgICAgICB9ICk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWN0LCB3aW4sXG4gICAgICAgIGVsZW0gPSB0aGlzWyAwIF07XG5cbiAgICAgIGlmICggIWVsZW0gKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIHplcm9zIGZvciBkaXNjb25uZWN0ZWQgYW5kIGhpZGRlbiAoZGlzcGxheTogbm9uZSkgZWxlbWVudHMgKGdoLTIzMTApXG4gICAgICAvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbiAgICAgIC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGFcbiAgICAgIC8vIGRpc2Nvbm5lY3RlZCBub2RlIGluIElFIHRocm93cyBhbiBlcnJvclxuICAgICAgaWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcbiAgICAgICAgcmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCBkb2N1bWVudC1yZWxhdGl2ZSBwb3NpdGlvbiBieSBhZGRpbmcgdmlld3BvcnQgc2Nyb2xsIHRvIHZpZXdwb3J0LXJlbGF0aXZlIGdCQ1JcbiAgICAgIHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgd2luID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCxcbiAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvLyBwb3NpdGlvbigpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIG1hcmdpbiBib3ggdG8gaXRzIG9mZnNldCBwYXJlbnQncyBwYWRkaW5nIGJveFxuICAgIC8vIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIGJlaGF2aW9yIG9mIENTUyBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuICAgIHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICggIXRoaXNbIDAgXSApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsIGRvYyxcbiAgICAgICAgZWxlbSA9IHRoaXNbIDAgXSxcbiAgICAgICAgcGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuICAgICAgLy8gcG9zaXRpb246Zml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHRoZSB2aWV3cG9ydCwgd2hpY2ggaXRzZWxmIGFsd2F5cyBoYXMgemVybyBvZmZzZXRcbiAgICAgIGlmICggalF1ZXJ5LmNzcyggZWxlbSwgJ3Bvc2l0aW9uJyApID09PSAnZml4ZWQnICkge1xuXG4gICAgICAgIC8vIEFzc3VtZSBwb3NpdGlvbjpmaXhlZCBpbXBsaWVzIGF2YWlsYWJpbGl0eSBvZiBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAgICAgICAgb2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblxuICAgICAgICAvLyBBY2NvdW50IGZvciB0aGUgKnJlYWwqIG9mZnNldCBwYXJlbnQsIHdoaWNoIGNhbiBiZSB0aGUgZG9jdW1lbnQgb3IgaXRzIHJvb3QgZWxlbWVudFxuICAgICAgICAvLyB3aGVuIGEgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnQgaXMgaWRlbnRpZmllZFxuICAgICAgICBkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHdoaWxlICggb2Zmc2V0UGFyZW50ICYmXG5cdFx0XHRcdCggb2Zmc2V0UGFyZW50ID09PSBkb2MuYm9keSB8fCBvZmZzZXRQYXJlbnQgPT09IGRvYy5kb2N1bWVudEVsZW1lbnQgKSAmJlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsICdwb3NpdGlvbicgKSA9PT0gJ3N0YXRpYycgKSB7XG5cbiAgICAgICAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQgIT09IGVsZW0gJiYgb2Zmc2V0UGFyZW50Lm5vZGVUeXBlID09PSAxICkge1xuXG4gICAgICAgICAgLy8gSW5jb3Jwb3JhdGUgYm9yZGVycyBpbnRvIGl0cyBvZmZzZXQsIHNpbmNlIHRoZXkgYXJlIG91dHNpZGUgaXRzIGNvbnRlbnQgb3JpZ2luXG4gICAgICAgICAgcGFyZW50T2Zmc2V0ID0galF1ZXJ5KCBvZmZzZXRQYXJlbnQgKS5vZmZzZXQoKTtcbiAgICAgICAgICBwYXJlbnRPZmZzZXQudG9wICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgJ2JvcmRlclRvcFdpZHRoJywgdHJ1ZSApO1xuICAgICAgICAgIHBhcmVudE9mZnNldC5sZWZ0ICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgJ2JvcmRlckxlZnRXaWR0aCcsIHRydWUgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgJ21hcmdpblRvcCcsIHRydWUgKSxcbiAgICAgICAgbGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sICdtYXJnaW5MZWZ0JywgdHJ1ZSApXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvLyBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBkb2N1bWVudEVsZW1lbnQgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgICAvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG4gICAgLy8gICAgZG9jdW1lbnRFbGVtZW50IG9mIHRoZSBwYXJlbnQgd2luZG93XG4gICAgLy8gMikgRm9yIHRoZSBoaWRkZW4gb3IgZGV0YWNoZWQgZWxlbWVudFxuICAgIC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcbiAgICAvL1xuICAgIC8vIGJ1dCB0aG9zZSBleGNlcHRpb25zIHdlcmUgbmV2ZXIgcHJlc2VudGVkIGFzIGEgcmVhbCBsaWZlIHVzZS1jYXNlc1xuICAgIC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuICAgIC8vXG4gICAgLy8gVGhpcyBsb2dpYywgaG93ZXZlciwgaXMgbm90IGd1YXJhbnRlZWQgYW5kIGNhbiBjaGFuZ2UgYXQgYW55IHBvaW50IGluIHRoZSBmdXR1cmVcbiAgICBvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xuXG4gICAgICAgIHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgJ3Bvc2l0aW9uJyApID09PSAnc3RhdGljJyApIHtcbiAgICAgICAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG4gICAgICB9ICk7XG4gICAgfVxuICB9ICk7XG5cbiAgLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG4gIGpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6ICdwYWdlWE9mZnNldCcsIHNjcm9sbFRvcDogJ3BhZ2VZT2Zmc2V0JyB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuICAgIHZhciB0b3AgPSAncGFnZVlPZmZzZXQnID09PSBwcm9wO1xuXG4gICAgalF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG4gICAgICByZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cbiAgICAgICAgLy8gQ29hbGVzY2UgZG9jdW1lbnRzIGFuZCB3aW5kb3dzXG4gICAgICAgIHZhciB3aW47XG4gICAgICAgIGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcbiAgICAgICAgICB3aW4gPSBlbGVtO1xuICAgICAgICB9IGVsc2UgaWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuICAgICAgICAgIHdpbiA9IGVsZW0uZGVmYXVsdFZpZXc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgIHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB3aW4gKSB7XG4gICAgICAgICAgd2luLnNjcm9sbFRvKFxuICAgICAgICAgICAgIXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcbiAgICAgICAgICAgIHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxuICAgICAgICAgICk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtWyBtZXRob2QgXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGggKTtcbiAgICB9O1xuICB9ICk7XG5cbiAgLy8gU3VwcG9ydDogU2FmYXJpIDw9NyAtIDkuMSwgQ2hyb21lIDw9MzcgLSA0OVxuICAvLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuICAvLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbiAgLy8gQmxpbmsgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODkzNDdcbiAgLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcbiAgLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbiAgalF1ZXJ5LmVhY2goIFsgJ3RvcCcsICdsZWZ0JyBdLCBmdW5jdGlvbiggaSwgcHJvcCApIHtcbiAgICBqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuICAgICAgZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuICAgICAgICBpZiAoIGNvbXB1dGVkICkge1xuICAgICAgICAgIGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cbiAgICAgICAgICAvLyBJZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcbiAgICAgICAgICByZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuICAgICAgICAgICAgalF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgJ3B4JyA6XG4gICAgICAgICAgICBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gIH0gKTtcblxuXG4gIC8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xuICBqUXVlcnkuZWFjaCggeyBIZWlnaHQ6ICdoZWlnaHQnLCBXaWR0aDogJ3dpZHRoJyB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcbiAgICBqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiAnaW5uZXInICsgbmFtZSwgY29udGVudDogdHlwZSwgJyc6ICdvdXRlcicgKyBuYW1lIH0sXG4gICAgICBmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuICAgICAgICAvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcbiAgICAgICAgalF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG4gICAgICAgICAgdmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gJ2Jvb2xlYW4nICksXG4gICAgICAgICAgICBleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/ICdtYXJnaW4nIDogJ2JvcmRlcicgKTtcblxuICAgICAgICAgIHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcbiAgICAgICAgICAgIHZhciBkb2M7XG5cbiAgICAgICAgICAgIGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblxuICAgICAgICAgICAgICAvLyAkKCB3aW5kb3cgKS5vdXRlcldpZHRoL0hlaWdodCByZXR1cm4gdy9oIGluY2x1ZGluZyBzY3JvbGxiYXJzIChnaC0xNzI5KVxuICAgICAgICAgICAgICByZXR1cm4gZnVuY05hbWUuaW5kZXhPZiggJ291dGVyJyApID09PSAwID9cbiAgICAgICAgICAgICAgICBlbGVtWyAnaW5uZXInICsgbmFtZSBdIDpcbiAgICAgICAgICAgICAgICBlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgJ2NsaWVudCcgKyBuYW1lIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcbiAgICAgICAgICAgIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcbiAgICAgICAgICAgICAgZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICAgICAgICAgICAgLy8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuICAgICAgICAgICAgICAvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3RcbiAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KFxuICAgICAgICAgICAgICAgIGVsZW0uYm9keVsgJ3Njcm9sbCcgKyBuYW1lIF0sIGRvY1sgJ3Njcm9sbCcgKyBuYW1lIF0sXG4gICAgICAgICAgICAgICAgZWxlbS5ib2R5WyAnb2Zmc2V0JyArIG5hbWUgXSwgZG9jWyAnb2Zmc2V0JyArIG5hbWUgXSxcbiAgICAgICAgICAgICAgICBkb2NbICdjbGllbnQnICsgbmFtZSBdXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblxuICAgICAgICAgICAgLy8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuICAgICAgICAgICAgICBqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcblxuICAgICAgICAgICAgLy8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICBqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuICAgICAgICAgIH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlICk7XG4gICAgICAgIH07XG4gICAgICB9ICk7XG4gIH0gKTtcblxuXG4gIGpRdWVyeS5lYWNoKCAoICdibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgcmVzaXplIHNjcm9sbCBjbGljayBkYmxjbGljayAnICtcblx0J21vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlICcgK1xuXHQnY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBjb250ZXh0bWVudScgKS5zcGxpdCggJyAnICksXG4gIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXG4gICAgLy8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcbiAgICBqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG4gICAgICAgIHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuICAgICAgICB0aGlzLnRyaWdnZXIoIG5hbWUgKTtcbiAgICB9O1xuICB9ICk7XG5cbiAgalF1ZXJ5LmZuLmV4dGVuZCgge1xuICAgIGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcbiAgICAgIHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuICAgIH1cbiAgfSApO1xuXG5cblxuXG4gIGpRdWVyeS5mbi5leHRlbmQoIHtcblxuICAgIGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG4gICAgICByZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG4gICAgfSxcbiAgICB1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG4gICAgICByZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG4gICAgICByZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuICAgIH0sXG4gICAgdW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cbiAgICAgIC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cbiAgICAgICAgdGhpcy5vZmYoIHNlbGVjdG9yLCAnKionICkgOlxuICAgICAgICB0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8ICcqKicsIGZuICk7XG4gICAgfVxuICB9ICk7XG5cbiAgLy8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG4gIC8vIGFyZ3VtZW50cy5cbiAgLy8galF1ZXJ5LnByb3h5IGlzIGRlcHJlY2F0ZWQgdG8gcHJvbW90ZSBzdGFuZGFyZHMgKHNwZWNpZmljYWxseSBGdW5jdGlvbiNiaW5kKVxuICAvLyBIb3dldmVyLCBpdCBpcyBub3Qgc2xhdGVkIGZvciByZW1vdmFsIGFueSB0aW1lIHNvb25cbiAgalF1ZXJ5LnByb3h5ID0gZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuICAgIHZhciB0bXAsIGFyZ3MsIHByb3h5O1xuXG4gICAgaWYgKCB0eXBlb2YgY29udGV4dCA9PT0gJ3N0cmluZycgKSB7XG4gICAgICB0bXAgPSBmblsgY29udGV4dCBdO1xuICAgICAgY29udGV4dCA9IGZuO1xuICAgICAgZm4gPSB0bXA7XG4gICAgfVxuXG4gICAgLy8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcbiAgICAvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuICAgIGlmICggIWlzRnVuY3Rpb24oIGZuICkgKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIFNpbXVsYXRlZCBiaW5kXG4gICAgYXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuICAgIHByb3h5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcbiAgICB9O1xuXG4gICAgLy8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG4gICAgcHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cbiAgICByZXR1cm4gcHJveHk7XG4gIH07XG5cbiAgalF1ZXJ5LmhvbGRSZWFkeSA9IGZ1bmN0aW9uKCBob2xkICkge1xuICAgIGlmICggaG9sZCApIHtcbiAgICAgIGpRdWVyeS5yZWFkeVdhaXQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgalF1ZXJ5LnJlYWR5KCB0cnVlICk7XG4gICAgfVxuICB9O1xuICBqUXVlcnkuaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG4gIGpRdWVyeS5wYXJzZUpTT04gPSBKU09OLnBhcnNlO1xuICBqUXVlcnkubm9kZU5hbWUgPSBub2RlTmFtZTtcbiAgalF1ZXJ5LmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICBqUXVlcnkuaXNXaW5kb3cgPSBpc1dpbmRvdztcbiAgalF1ZXJ5LmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbiAgalF1ZXJ5LnR5cGUgPSB0b1R5cGU7XG5cbiAgalF1ZXJ5Lm5vdyA9IERhdGUubm93O1xuXG4gIGpRdWVyeS5pc051bWVyaWMgPSBmdW5jdGlvbiggb2JqICkge1xuXG4gICAgLy8gQXMgb2YgalF1ZXJ5IDMuMCwgaXNOdW1lcmljIGlzIGxpbWl0ZWQgdG9cbiAgICAvLyBzdHJpbmdzIGFuZCBudW1iZXJzIChwcmltaXRpdmVzIG9yIG9iamVjdHMpXG4gICAgLy8gdGhhdCBjYW4gYmUgY29lcmNlZCB0byBmaW5pdGUgbnVtYmVycyAoZ2gtMjY2MilcbiAgICB2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcbiAgICByZXR1cm4gKCB0eXBlID09PSAnbnVtYmVyJyB8fCB0eXBlID09PSAnc3RyaW5nJyApICYmXG5cblx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0IWlzTmFOKCBvYmogLSBwYXJzZUZsb2F0KCBvYmogKSApO1xuICB9O1xuXG5cblxuXG4gIC8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuICAvLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4gIC8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuICAvLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4gIC8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuICAvLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbiAgLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG4gIC8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4gIC8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbiAgLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG4gIGlmICggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgIGRlZmluZSggJ2pxdWVyeScsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBqUXVlcnk7XG4gICAgfSApO1xuICB9XG5cblxuXG5cbiAgdmFyXG5cbiAgICAvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcbiAgICBfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuICAgIC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgXyQgPSB3aW5kb3cuJDtcblxuICBqUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuICAgIGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcbiAgICAgIHdpbmRvdy4kID0gXyQ7XG4gICAgfVxuXG4gICAgaWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcbiAgICAgIHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuICAgIH1cblxuICAgIHJldHVybiBqUXVlcnk7XG4gIH07XG5cbiAgLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbiAgLy8gKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuICAvLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpXG4gIGlmICggIW5vR2xvYmFsICkge1xuICAgIHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbiAgfVxuXG5cblxuXG4gIHJldHVybiBqUXVlcnk7XG59ICk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vfi9qcXVlcnkvZGlzdC9qcXVlcnkuanMiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBOUVBO0FBQ0E7QUFnRkE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE5S0E7QUFDQTtBQWdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBVUE7QUFDQTtBQWJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQW9CQTtBQUNBO0FBdkJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBK0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQXRDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUEyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdkRBO0FBQ0E7QUFDQTtBQXlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXhFQTtBQTRFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdEZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBa0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7QUFqR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQW9IQTtBQUNBO0FBdkhBO0FBQ0E7QUFDQTtBQXlIQTtBQUNBO0FBQ0E7QUE3SEE7QUErSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBOUlBO0FBZ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFyS0E7QUF5S0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQWZBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFFQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXhFQTtBQUNBO0FBMEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqTkE7QUFDQTtBQW1OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqTUE7QUFuVEE7QUFDQTtBQXVmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFUQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBWkE7QUFjQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBVEE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBS0E7QUF6Q0E7QUFDQTtBQTRDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQTlFQTtBQUNBO0FBZ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhEQTtBQWtEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakhBO0FBQ0E7QUFtSEE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFBQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwTkE7QUFaQTtBQUNBO0FBbU9BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBVEE7QUFDQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBelZBO0FBQ0E7QUE0VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEzQkE7QUFDQTtBQTZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBOUlBO0FBZ0pBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXJCQTtBQUNBO0FBdUJBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoRkE7QUFDQTtBQW1GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQS9EQTtBQUNBO0FBaUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakVBO0FBbUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBUkE7QUFBQTtBQUNBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7QUFDQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUF2QkE7QUF5QkE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTtBQUNBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUExQ0E7QUE1VkE7QUFDQTtBQWtaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuQ0E7QUFDQTtBQXFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBekRBO0FBQ0E7QUEyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbEJBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBM0NBO0FBQ0E7QUE4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBZkE7QUFDQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBL0VBO0FBQ0E7QUFpRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBeklBO0FBQ0E7QUEySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUFzQkE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUFBO0FBQUE7QUFTQTtBQUNBO0FBRkE7QUFSQTtBQUFBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBREE7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdkpBO0FBQ0E7QUF5SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdERBO0FBd0RBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBZEE7QUFDQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUF0QkE7QUFDQTtBQXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXpDQTtBQUNBO0FBMkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQ0E7QUFEQTtBQUNBO0FBc0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFBQTtBQUFBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMUNBO0FBNENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBeENBO0FBM0NBO0FBQ0E7QUFzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXJDQTtBQUNBO0FBdUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXhIQTtBQUNBO0FBMEhBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUFEQTtBQUNBO0FBZUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBNUVBO0FBQ0E7QUE4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF2QkE7QUFEQTtBQUNBO0FBMkJBO0FBQ0E7QUFDQTtBQUZBO0FBN0RBO0FBQ0E7QUFrRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdkJBO0FBeUJBO0FBQ0E7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBN0pBO0FBQ0E7QUFrS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWxFQTtBQUNBO0FBb0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRFQTtBQWZBO0FBREE7QUFDQTtBQTBGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUZBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFqS0E7QUFDQTtBQW1LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQXJCQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbENBO0FBQ0E7QUFxQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQVBBO0FBQUE7QUFDQTtBQUNBO0FBU0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUFBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7QUFDQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUE5REE7QUFDQTtBQW1FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQU5BO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUF4Q0E7QUFDQTtBQUNBO0FBeUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQS9DQTtBQUNBO0FBQ0E7QUFnREE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwRUE7QUFDQTtBQXNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMWhCQTtBQUNBO0FBNGhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBL0RBO0FBQ0E7QUFrRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFBQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbklBO0FBcUlBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUlBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQVJBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXZCQTtBQXlCQTtBQUNBO0FBQ0E7QUFJQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQWpEQTtBQUNBO0FBbURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBeEdBO0FBQ0E7QUEwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFsQkE7QUFDQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (module) {\n  if (!module.webpackPolyfill) {\n    module.deprecate = function () {};\n    module.paths = [];\n    // module.parent = undefined by default\n    if (!module.children) module.children = [];\n    Object.defineProperty(module, 'loaded', {\n      enumerable: true,\n      get: function get() {\n        return module.l;\n      }\n    });\n    Object.defineProperty(module, 'id', {\n      enumerable: true,\n      get: function get() {\n        return module.i;\n      }\n    });\n    module.webpackPolyfill = 1;\n  }\n  return module;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9+L3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanM/MTdhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG4gIGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcbiAgICBtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuICAgIG1vZHVsZS5wYXRocyA9IFtdO1xyXG4gICAgLy8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcbiAgICBpZighbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsICdsb2FkZWQnLCB7XHJcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vZHVsZS5sO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsICdpZCcsIHtcclxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gbW9kdWxlLmk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcbiAgfVxyXG4gIHJldHVybiBtb2R1bGU7XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9+L3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanMiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n");

/***/ })
/******/ ]);